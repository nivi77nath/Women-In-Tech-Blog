{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tslib = require('tslib');\n\nvar React = require('react');\n\nvar heyListen = require('hey-listen');\n\nvar styleValueTypes = require('style-value-types');\n\nvar popmotion = require('popmotion');\n\nvar sync = require('framesync');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\n\nvar createDefinition = function (propNames) {\n  return {\n    isEnabled: function (props) {\n      return propNames.some(function (name) {\n        return !!props[name];\n      });\n    }\n  };\n};\n\nvar featureDefinitions = {\n  measureLayout: createDefinition([\"layout\", \"layoutId\", \"drag\", \"_layoutResetTransform\"]),\n  animation: createDefinition([\"animate\", \"exit\", \"variants\", \"whileHover\", \"whileTap\", \"whileFocus\", \"whileDrag\"]),\n  exit: createDefinition([\"exit\"]),\n  drag: createDefinition([\"drag\", \"dragControls\"]),\n  focus: createDefinition([\"whileFocus\"]),\n  hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n  tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n  pan: createDefinition([\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"]),\n  layoutAnimation: createDefinition([\"layout\", \"layoutId\"])\n};\n\nfunction loadFeatures(features) {\n  for (var key in features) {\n    var Component = features[key];\n    if (Component !== null) featureDefinitions[key].Component = Component;\n  }\n}\n\nvar LazyContext = React.createContext({\n  strict: false\n});\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */\n\nfunction useFeatures(props, visualElement, preloadedFeatures) {\n  var features = [];\n  var lazyContext = React.useContext(LazyContext);\n  if (!visualElement) return null;\n  /**\n   * If we're in development mode, check to make sure we're not rendering a motion component\n   * as a child of LazyMotion, as this will break the file-size benefits of using it.\n   */\n\n  if (process.env.NODE_ENV !== \"production\" && preloadedFeatures && lazyContext.strict) {\n    heyListen.invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n  }\n\n  for (var i = 0; i < numFeatures; i++) {\n    var name_1 = featureNames[i];\n    var _a = featureDefinitions[name_1],\n        isEnabled = _a.isEnabled,\n        Component = _a.Component;\n    /**\n     * It might be possible in the future to use this moment to\n     * dynamically request functionality. In initial tests this\n     * was producing a lot of duplication amongst bundles.\n     */\n\n    if (isEnabled(props) && Component) {\n      features.push(React__namespace.createElement(Component, tslib.__assign({\n        key: name_1\n      }, props, {\n        visualElement: visualElement\n      })));\n    }\n  }\n\n  return features;\n}\n/**\n * @public\n */\n\n\nvar MotionConfigContext = React.createContext({\n  transformPagePoint: function (p) {\n    return p;\n  },\n  isStatic: false\n});\nvar MotionContext = React.createContext({});\n\nfunction useVisualElementContext() {\n  return React.useContext(MotionContext).visualElement;\n}\n/**\n * @public\n */\n\n\nvar PresenceContext = React.createContext(null);\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\n\nfunction useConstant(init) {\n  var ref = React.useRef(null);\n\n  if (ref.current === null) {\n    ref.current = init();\n  }\n\n  return ref.current;\n}\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\n\n\nfunction usePresence() {\n  var context = React.useContext(PresenceContext);\n  if (context === null) return [true, null];\n  var isPresent = context.isPresent,\n      onExitComplete = context.onExitComplete,\n      register = context.register; // It's safe to call the following hooks conditionally (after an early return) because the context will always\n  // either be null or non-null for the lifespan of the component.\n  // Replace with useOpaqueId when released in React\n\n  var id = useUniqueId();\n  React.useEffect(function () {\n    return register(id);\n  }, []);\n\n  var safeToRemove = function () {\n    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);\n  };\n\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useIsPresent() {\n  return isPresent(React.useContext(PresenceContext));\n}\n\nfunction isPresent(context) {\n  return context === null ? true : context.isPresent;\n}\n\nvar counter = 0;\n\nvar incrementId = function () {\n  return counter++;\n};\n\nvar useUniqueId = function () {\n  return useConstant(incrementId);\n};\n/**\n * @internal\n */\n\n\nvar LayoutGroupContext = React.createContext(null);\nvar isBrowser = typeof window !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n\nfunction useLayoutId(_a) {\n  var layoutId = _a.layoutId;\n  var layoutGroupId = React.useContext(LayoutGroupContext);\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n  var config = React.useContext(MotionConfigContext);\n  var lazyContext = React.useContext(LazyContext);\n  var parent = useVisualElementContext();\n  var presenceContext = React.useContext(PresenceContext);\n  var layoutId = useLayoutId(props);\n  var visualElementRef = React.useRef(undefined);\n  /**\n   * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n   */\n\n  if (!createVisualElement) createVisualElement = lazyContext.renderer;\n\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component, {\n      visualState: visualState,\n      parent: parent,\n      props: tslib.__assign(tslib.__assign({}, props), {\n        layoutId: layoutId\n      }),\n      presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n      blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false\n    });\n  }\n\n  var visualElement = visualElementRef.current;\n  useIsomorphicLayoutEffect(function () {\n    if (!visualElement) return;\n    visualElement.setProps(tslib.__assign(tslib.__assign(tslib.__assign({}, config), props), {\n      layoutId: layoutId\n    }));\n    visualElement.isPresent = isPresent(presenceContext);\n    visualElement.isPresenceRoot = !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);\n    /**\n     * Fire a render to ensure the latest state is reflected on-screen.\n     */\n\n    visualElement.syncRender();\n  });\n  React.useEffect(function () {\n    var _a;\n\n    if (!visualElement) return;\n    /**\n     * In a future refactor we can replace the features-as-components and\n     * have this loop through them all firing \"effect\" listeners\n     */\n\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n  });\n  useIsomorphicLayoutEffect(function () {\n    return function () {\n      return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount();\n    };\n  }, []);\n  return visualElement;\n}\n\nfunction isRefObject(ref) {\n  return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\n\n\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  return React.useCallback(function (instance) {\n    var _a;\n\n    instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n\n    if (visualElement) {\n      instance ? visualElement.mount(instance) : visualElement.unmount();\n    }\n\n    if (externalRef) {\n      if (typeof externalRef === \"function\") {\n        externalRef(instance);\n      } else if (isRefObject(externalRef)) {\n        externalRef.current = instance;\n      }\n    }\n  },\n  /**\n   * Only pass a new ref callback to React if we've received a visual element\n   * factory. Otherwise we'll be mounting/remounting every time externalRef\n   * or other dependencies change.\n   */\n  [visualElement]);\n}\n/**\n * Decides if the supplied variable is an array of variant labels\n */\n\n\nfunction isVariantLabels(v) {\n  return Array.isArray(v);\n}\n/**\n * Decides if the supplied variable is variant label\n */\n\n\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || isVariantLabels(v);\n}\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\n\n\nfunction getCurrent(visualElement) {\n  var current = {};\n  visualElement.forEachValue(function (value, key) {\n    return current[key] = value.get();\n  });\n  return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\n\n\nfunction getVelocity$1(visualElement) {\n  var velocity = {};\n  visualElement.forEachValue(function (value, key) {\n    return velocity[key] = value.getVelocity();\n  });\n  return velocity;\n}\n\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n  var _a;\n\n  if (currentValues === void 0) {\n    currentValues = {};\n  }\n\n  if (currentVelocity === void 0) {\n    currentVelocity = {};\n  }\n\n  if (typeof definition === \"string\") {\n    definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n  }\n\n  return typeof definition === \"function\" ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity) : definition;\n}\n\nfunction resolveVariant(visualElement, definition, custom) {\n  var props = visualElement.getProps();\n  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));\n}\n\nfunction checkIfControllingVariants(props) {\n  var _a;\n\n  return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \"function\" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);\n}\n\nfunction checkIfVariantNode(props) {\n  return Boolean(checkIfControllingVariants(props) || props.variants);\n}\n\nfunction getCurrentTreeVariants(props, context) {\n  if (checkIfControllingVariants(props)) {\n    var initial = props.initial,\n        animate = props.animate;\n    return {\n      initial: initial === false || isVariantLabel(initial) ? initial : undefined,\n      animate: isVariantLabel(animate) ? animate : undefined\n    };\n  }\n\n  return props.inherit !== false ? context : {};\n}\n\nfunction useCreateMotionContext(props, isStatic) {\n  var _a = getCurrentTreeVariants(props, React.useContext(MotionContext)),\n      initial = _a.initial,\n      animate = _a.animate;\n\n  return React.useMemo(function () {\n    return {\n      initial: initial,\n      animate: animate\n    };\n  },\n  /**\n   * Only break memoisation in static mode\n   */\n  isStatic ? [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)] : []);\n}\n\nfunction variantLabelsAsDependency(prop) {\n  return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\n\n\nfunction createMotionComponent(_a) {\n  var preloadedFeatures = _a.preloadedFeatures,\n      createVisualElement = _a.createVisualElement,\n      useRender = _a.useRender,\n      useVisualState = _a.useVisualState,\n      Component = _a.Component;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n\n  function MotionComponent(props, externalRef) {\n    /**\n     * If we're rendering in a static environment, we only visually update the component\n     * as a result of a React-rerender rather than interactions or animations. This\n     * means we don't need to load additional memory structures like VisualElement,\n     * or any gesture/animation features.\n     */\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    var features = null;\n    /**\n     * Create the tree context. This is memoized and will only trigger renders\n     * when the current tree variant changes in static mode.\n     */\n\n    var context = useCreateMotionContext(props, isStatic);\n    /**\n     *\n     */\n\n    var visualState = useVisualState(props, isStatic);\n\n    if (!isStatic && isBrowser) {\n      /**\n       * Create a VisualElement for this component. A VisualElement provides a common\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n       * providing a way of rendering to these APIs outside of the React render loop\n       * for more performant animations and interactions\n       */\n      context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\n      /**\n       * Load Motion gesture and animation features. These are rendered as renderless\n       * components so each feature can optionally make use of React lifecycle methods.\n       *\n       * TODO: The intention is to move these away from a React-centric to a\n       * VisualElement-centric lifecycle scheme.\n       */\n\n      features = useFeatures(props, context.visualElement, preloadedFeatures);\n    }\n    /**\n     * The mount order and hierarchy is specific to ensure our element ref\n     * is hydrated by the time features fire their effects.\n     */\n\n\n    return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)), features);\n  }\n\n  return React.forwardRef(MotionComponent);\n}\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion(Component)\n * ```\n *\n * @public\n */\n\n\nfunction createMotionProxy(createConfig) {\n  function custom(Component, customMotionComponentConfig) {\n    if (customMotionComponentConfig === void 0) {\n      customMotionComponentConfig = {};\n    }\n\n    return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n  }\n  /**\n   * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n   * Rather than generating them anew every render.\n   */\n\n\n  var componentCache = new Map();\n  return new Proxy(custom, {\n    /**\n     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n     * The prop name is passed through as `key` and we can use that to generate a `motion`\n     * DOM component with that name.\n     */\n    get: function (_target, key) {\n      /**\n       * If this element doesn't exist in the component cache, create it and cache.\n       */\n      if (!componentCache.has(key)) {\n        componentCache.set(key, custom(key));\n      }\n\n      return componentCache.get(key);\n    }\n  });\n}\n/**\n * We keep these listed seperately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\n\n\nvar lowercaseSVGElements = [\"animate\", \"circle\", \"defs\", \"desc\", \"ellipse\", \"g\", \"image\", \"line\", \"filter\", \"marker\", \"mask\", \"metadata\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"rect\", \"stop\", \"svg\", \"switch\", \"symbol\", \"text\", \"tspan\", \"use\", \"view\"];\n\nfunction isSVGComponent(Component) {\n  if (\n  /**\n   * If it's not a string, it's a custom React component. Currently we only support\n   * HTML custom React components.\n   */\n  typeof Component !== \"string\" ||\n  /**\n   * If it contains a dash, the element is a custom HTML webcomponent.\n   */\n  Component.includes(\"-\")) {\n    return false;\n  } else if (\n  /**\n   * If it's in our list of lowercase SVG tags, it's an SVG component\n   */\n  lowercaseSVGElements.indexOf(Component) > -1 ||\n  /**\n   * If it contains a capital letter, it's an SVG component\n   */\n  /[A-Z]/.test(Component)) {\n    return true;\n  }\n\n  return false;\n}\n\nvar valueScaleCorrection = {};\n/**\n * @internal\n */\n\nfunction addScaleCorrection(correctors) {\n  for (var key in correctors) {\n    valueScaleCorrection[key] = correctors[key];\n  }\n}\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\n\n\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\n\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\n/**\n * Generate a list of every possible transform key.\n */\n\nvar transformProps = [\"transformPerspective\", \"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n  return transformAxes.forEach(function (axesKey) {\n    return transformProps.push(operationKey + axesKey);\n  });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\n\nfunction sortTransformProps(a, b) {\n  return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\n\n\nvar transformPropSet = new Set(transformProps);\n\nfunction isTransformProp(key) {\n  return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\n\n\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\n\nfunction isTransformOriginProp(key) {\n  return transformOriginProps.has(key);\n}\n\nfunction isForcedMotionValue(key, _a) {\n  var layout = _a.layout,\n      layoutId = _a.layoutId;\n  return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== undefined) && (!!valueScaleCorrection[key] || key === \"opacity\");\n}\n\nvar isMotionValue = function (value) {\n  return value !== null && typeof value === \"object\" && value.getVelocity;\n};\n\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\n\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n  var transform = _a.transform,\n      transformKeys = _a.transformKeys;\n  var _c = _b.enableHardwareAcceleration,\n      enableHardwareAcceleration = _c === void 0 ? true : _c,\n      _d = _b.allowTransformNone,\n      allowTransformNone = _d === void 0 ? true : _d; // The transform string we're going to build into.\n\n  var transformString = \"\"; // Transform keys into their default order - this will determine the output order.\n\n  transformKeys.sort(sortTransformProps); // Track whether the defined transform has a defined z so we don't add a\n  // second to enable hardware acceleration\n\n  var transformHasZ = false; // Loop over each transform and build them into transformString\n\n  var numTransformKeys = transformKeys.length;\n\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key = transformKeys[i];\n    transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n    if (key === \"z\") transformHasZ = true;\n  }\n\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString += \"translateZ(0)\";\n  } else {\n    transformString = transformString.trim();\n  } // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n\n\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n\n  return transformString;\n}\n/**\n * Build a transformOrigin style. Uses the same defaults as the browser for\n * undefined origins.\n */\n\n\nfunction buildTransformOrigin(_a) {\n  var _b = _a.originX,\n      originX = _b === void 0 ? \"50%\" : _b,\n      _c = _a.originY,\n      originY = _c === void 0 ? \"50%\" : _c,\n      _d = _a.originZ,\n      originZ = _d === void 0 ? 0 : _d;\n  return originX + \" \" + originY + \" \" + originZ;\n}\n/**\n * Returns true if the provided key is a CSS variable\n */\n\n\nfunction isCSSVariable$1(key) {\n  return key.startsWith(\"--\");\n}\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\n\n\nvar getValueAsType = function (value, type) {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n\nvar int = tslib.__assign(tslib.__assign({}, styleValueTypes.number), {\n  transform: Math.round\n});\n\nvar numberValueTypes = {\n  // Border props\n  borderWidth: styleValueTypes.px,\n  borderTopWidth: styleValueTypes.px,\n  borderRightWidth: styleValueTypes.px,\n  borderBottomWidth: styleValueTypes.px,\n  borderLeftWidth: styleValueTypes.px,\n  borderRadius: styleValueTypes.px,\n  radius: styleValueTypes.px,\n  borderTopLeftRadius: styleValueTypes.px,\n  borderTopRightRadius: styleValueTypes.px,\n  borderBottomRightRadius: styleValueTypes.px,\n  borderBottomLeftRadius: styleValueTypes.px,\n  // Positioning props\n  width: styleValueTypes.px,\n  maxWidth: styleValueTypes.px,\n  height: styleValueTypes.px,\n  maxHeight: styleValueTypes.px,\n  size: styleValueTypes.px,\n  top: styleValueTypes.px,\n  right: styleValueTypes.px,\n  bottom: styleValueTypes.px,\n  left: styleValueTypes.px,\n  // Spacing props\n  padding: styleValueTypes.px,\n  paddingTop: styleValueTypes.px,\n  paddingRight: styleValueTypes.px,\n  paddingBottom: styleValueTypes.px,\n  paddingLeft: styleValueTypes.px,\n  margin: styleValueTypes.px,\n  marginTop: styleValueTypes.px,\n  marginRight: styleValueTypes.px,\n  marginBottom: styleValueTypes.px,\n  marginLeft: styleValueTypes.px,\n  // Transform props\n  rotate: styleValueTypes.degrees,\n  rotateX: styleValueTypes.degrees,\n  rotateY: styleValueTypes.degrees,\n  rotateZ: styleValueTypes.degrees,\n  scale: styleValueTypes.scale,\n  scaleX: styleValueTypes.scale,\n  scaleY: styleValueTypes.scale,\n  scaleZ: styleValueTypes.scale,\n  skew: styleValueTypes.degrees,\n  skewX: styleValueTypes.degrees,\n  skewY: styleValueTypes.degrees,\n  distance: styleValueTypes.px,\n  translateX: styleValueTypes.px,\n  translateY: styleValueTypes.px,\n  translateZ: styleValueTypes.px,\n  x: styleValueTypes.px,\n  y: styleValueTypes.px,\n  z: styleValueTypes.px,\n  perspective: styleValueTypes.px,\n  transformPerspective: styleValueTypes.px,\n  opacity: styleValueTypes.alpha,\n  originX: styleValueTypes.progressPercentage,\n  originY: styleValueTypes.progressPercentage,\n  originZ: styleValueTypes.px,\n  // Misc\n  zIndex: int,\n  // SVG\n  fillOpacity: styleValueTypes.alpha,\n  strokeOpacity: styleValueTypes.alpha,\n  numOctaves: int\n};\n\nfunction buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n  var _a;\n\n  var style = state.style,\n      vars = state.vars,\n      transform = state.transform,\n      transformKeys = state.transformKeys,\n      transformOrigin = state.transformOrigin; // Empty the transformKeys array. As we're throwing out refs to its items\n  // this might not be as cheap as suspected. Maybe using the array as a buffer\n  // with a manual incrementation would be better.\n\n  transformKeys.length = 0; // Track whether we encounter any transform or transformOrigin values.\n\n  var hasTransform = false;\n  var hasTransformOrigin = false; // Does the calculated transform essentially equal \"none\"?\n\n  var transformIsNone = true;\n  /**\n   * Loop over all our latest animated values and decide whether to handle them\n   * as a style or CSS variable.\n   *\n   * Transforms and transform origins are kept seperately for further processing.\n   */\n\n  for (var key in latestValues) {\n    var value = latestValues[key];\n    /**\n     * If this is a CSS variable we don't do any further processing.\n     */\n\n    if (isCSSVariable$1(key)) {\n      vars[key] = value;\n      continue;\n    } // Convert the value to its default value type, ie 0 -> \"0px\"\n\n\n    var valueType = numberValueTypes[key];\n    var valueAsType = getValueAsType(value, valueType);\n\n    if (isTransformProp(key)) {\n      // If this is a transform, flag to enable further transform processing\n      hasTransform = true;\n      transform[key] = valueAsType;\n      transformKeys.push(key); // If we already know we have a non-default transform, early return\n\n      if (!transformIsNone) continue; // Otherwise check to see if this is a default transform\n\n      if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0)) transformIsNone = false;\n    } else if (isTransformOriginProp(key)) {\n      transformOrigin[key] = valueAsType; // If this is a transform origin, flag and enable further transform-origin processing\n\n      hasTransformOrigin = true;\n    } else {\n      /**\n       * If layout projection is on, and we need to perform scale correction for this\n       * value type, perform it.\n       */\n      if ((projection === null || projection === void 0 ? void 0 : projection.isHydrated) && (layoutState === null || layoutState === void 0 ? void 0 : layoutState.isHydrated) && valueScaleCorrection[key]) {\n        var correctedValue = valueScaleCorrection[key].process(value, layoutState, projection);\n        /**\n         * Scale-correctable values can define a number of other values to break\n         * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n         */\n\n        var applyTo = valueScaleCorrection[key].applyTo;\n\n        if (applyTo) {\n          var num = applyTo.length;\n\n          for (var i = 0; i < num; i++) {\n            style[applyTo[i]] = correctedValue;\n          }\n        } else {\n          style[key] = correctedValue;\n        }\n      } else {\n        style[key] = valueAsType;\n      }\n    }\n  }\n\n  if (layoutState && projection && buildProjectionTransform && buildProjectionTransformOrigin) {\n    style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform : undefined);\n\n    if (transformTemplate) {\n      style.transform = transformTemplate(transform, style.transform);\n    }\n\n    style.transformOrigin = buildProjectionTransformOrigin(layoutState);\n  } else {\n    if (hasTransform) {\n      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n    }\n\n    if (hasTransformOrigin) {\n      style.transformOrigin = buildTransformOrigin(transformOrigin);\n    }\n  }\n}\n\nvar createHtmlRenderState = function () {\n  return {\n    style: {},\n    transform: {},\n    transformKeys: [],\n    transformOrigin: {},\n    vars: {}\n  };\n};\n\nfunction copyRawValuesOnly(target, source, props) {\n  for (var key in source) {\n    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n  var transformTemplate = _a.transformTemplate;\n  return React.useMemo(function () {\n    var state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, undefined, undefined, {\n      enableHardwareAcceleration: !isStatic\n    }, transformTemplate);\n    var vars = state.vars,\n        style = state.style;\n    return tslib.__assign(tslib.__assign({}, vars), style);\n  }, [visualState]);\n}\n\nfunction useStyle(props, visualState, isStatic) {\n  var styleProp = props.style || {};\n  var style = {};\n  /**\n   * Copy non-Motion Values straight into style\n   */\n\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n\n  if (props.transformValues) {\n    style = props.transformValues(style);\n  }\n\n  return style;\n}\n\nfunction useHTMLProps(props, visualState, isStatic) {\n  // The `any` isn't ideal but it is the type of createElement props argument\n  var htmlProps = {};\n  var style = useStyle(props, visualState, isStatic);\n\n  if (Boolean(props.drag)) {\n    // Disable the ghost element when a user drags\n    htmlProps.draggable = false; // Disable text selection\n\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\"; // Disable scrolling on the draggable direction\n\n    style.touchAction = props.drag === true ? \"none\" : \"pan-\" + (props.drag === \"x\" ? \"y\" : \"x\");\n  }\n\n  htmlProps.style = style;\n  return htmlProps;\n}\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\n\n\nvar validMotionProps = new Set([\"initial\", \"animate\", \"exit\", \"style\", \"variants\", \"transition\", \"transformTemplate\", \"transformValues\", \"custom\", \"inherit\", \"layout\", \"layoutId\", \"_layoutResetTransform\", \"onLayoutAnimationComplete\", \"onViewportBoxUpdate\", \"onLayoutMeasure\", \"onBeforeLayoutMeasure\", \"onAnimationStart\", \"onAnimationComplete\", \"onUpdate\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"onMeasureDragConstraints\", \"onDirectionLock\", \"onDragTransitionEnd\", \"drag\", \"dragControls\", \"dragListener\", \"dragConstraints\", \"dragDirectionLock\", \"_dragX\", \"_dragY\", \"dragElastic\", \"dragMomentum\", \"dragPropagation\", \"dragTransition\", \"whileDrag\", \"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"onHoverStart\", \"onHoverEnd\", \"whileFocus\", \"whileTap\", \"whileHover\"]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\n\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\nvar shouldForward = function (key) {\n  return !isValidMotionProp(key);\n};\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\n\n\ntry {\n  var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n\n  shouldForward = function (key) {\n    // Handle events explicitly as Emotion validates them all as true\n    if (key.startsWith(\"on\")) {\n      return !isValidMotionProp(key);\n    } else {\n      return emotionIsPropValid_1(key);\n    }\n  };\n} catch (_a) {// We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\n\nfunction filterProps(props, isDom, forwardMotionProps) {\n  var filteredProps = {};\n\n  for (var key in props) {\n    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key)) {\n      filteredProps[key] = props[key];\n    }\n  }\n\n  return filteredProps;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : styleValueTypes.px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\n\n\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n  var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n  return pxOriginX + \" \" + pxOriginY;\n} // Convert a progress 0-1 to a pixels value based on the provided length\n\n\nvar progressToPixels = function (progress, length) {\n  return styleValueTypes.px.transform(progress * length);\n};\n\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\n\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n  if (spacing === void 0) {\n    spacing = 1;\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (useDashCase === void 0) {\n    useDashCase = true;\n  } // We use dash case when setting attributes directly to the DOM node and camel case\n  // when defining props on a React component.\n\n\n  var keys = useDashCase ? dashKeys : camelKeys; // Build the dash offset\n\n  attrs[keys.offset] = progressToPixels(-offset, totalLength); // Build the dash array\n\n  var pathLength = progressToPixels(length, totalLength);\n  var pathSpacing = progressToPixels(spacing, totalLength);\n  attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\n\n\nfunction buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n  var attrX = _a.attrX,\n      attrY = _a.attrY,\n      originX = _a.originX,\n      originY = _a.originY,\n      pathLength = _a.pathLength,\n      _b = _a.pathSpacing,\n      pathSpacing = _b === void 0 ? 1 : _b,\n      _c = _a.pathOffset,\n      pathOffset = _c === void 0 ? 0 : _c,\n      // This is object creation, which we try to avoid per-frame.\n  latest = tslib.__rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n\n  buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);\n  state.attrs = state.style;\n  state.style = {};\n  var attrs = state.attrs,\n      style = state.style,\n      dimensions = state.dimensions,\n      totalPathLength = state.totalPathLength;\n  /**\n   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n   * and copy it into style.\n   */\n\n  if (attrs.transform) {\n    if (dimensions) style.transform = attrs.transform;\n    delete attrs.transform;\n  } // Parse transformOrigin\n\n\n  if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n  } // Treat x/y not as shortcuts but as actual attributes\n\n\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY; // Build SVG path if one has been measured\n\n  if (totalPathLength !== undefined && pathLength !== undefined) {\n    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n  }\n}\n\nvar createSvgRenderState = function () {\n  return tslib.__assign(tslib.__assign({}, createHtmlRenderState()), {\n    attrs: {}\n  });\n};\n\nfunction useSVGProps(props, visualState) {\n  var visualProps = React.useMemo(function () {\n    var state = createSvgRenderState();\n    buildSVGAttrs(state, visualState, undefined, undefined, {\n      enableHardwareAcceleration: false\n    }, props.transformTemplate);\n    return tslib.__assign(tslib.__assign({}, state.attrs), {\n      style: tslib.__assign({}, state.style)\n    });\n  }, [visualState]);\n\n  if (props.style) {\n    var rawStyles = {};\n    copyRawValuesOnly(rawStyles, props.style, props);\n    visualProps.style = tslib.__assign(tslib.__assign({}, rawStyles), visualProps.style);\n  }\n\n  return visualProps;\n}\n\nfunction createUseRender(forwardMotionProps) {\n  if (forwardMotionProps === void 0) {\n    forwardMotionProps = false;\n  }\n\n  var useRender = function (Component, props, ref, _a, isStatic) {\n    var latestValues = _a.latestValues;\n    var useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;\n    var visualProps = useVisualProps(props, latestValues, isStatic);\n    var filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n\n    var elementProps = tslib.__assign(tslib.__assign(tslib.__assign({}, filteredProps), visualProps), {\n      ref: ref\n    });\n\n    return React.createElement(Component, elementProps);\n  };\n\n  return useRender;\n}\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\n\nvar camelToDash = function (str) {\n  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\nfunction renderHTML(element, _a) {\n  var style = _a.style,\n      vars = _a.vars; // Directly assign style into the Element's style prop. In tests Object.assign is the\n  // fastest way to assign styles.\n\n  Object.assign(element.style, style); // Loop over any CSS variables and assign those.\n\n  for (var key in vars) {\n    element.style.setProperty(key, vars[key]);\n  }\n}\n/**\n * A set of attribute names that are always read/written as camel case.\n */\n\n\nvar camelCaseAttributes = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\", \"viewBox\", \"gradientTransform\"]);\n\nfunction renderSVG(element, renderState) {\n  renderHTML(element, renderState);\n\n  for (var key in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n  }\n}\n\nfunction scrapeMotionValuesFromProps$1(props) {\n  var style = props.style;\n  var newValues = {};\n\n  for (var key in style) {\n    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n      newValues[key] = style[key];\n    }\n  }\n\n  return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props) {\n  var newValues = scrapeMotionValuesFromProps$1(props);\n\n  for (var key in props) {\n    if (isMotionValue(props[key])) {\n      var targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n      newValues[targetKey] = props[key];\n    }\n  }\n\n  return newValues;\n}\n\nfunction isAnimationControls(v) {\n  return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\nvar isKeyframesTarget = function (v) {\n  return Array.isArray(v);\n};\n\nvar isCustomValue = function (v) {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\n\nvar resolveFinalValueInKeyframes = function (v) {\n  // TODO maybe throw if v.length - 1 is placeholder token?\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\n\n\nfunction resolveMotionValue(value) {\n  var unwrappedValue = isMotionValue(value) ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\nfunction makeState(_a, props, context, presenceContext) {\n  var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps,\n      createRenderState = _a.createRenderState,\n      onMount = _a.onMount;\n  var state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n    renderState: createRenderState()\n  };\n\n  if (onMount) {\n    state.mount = function (instance) {\n      return onMount(props, instance, state);\n    };\n  }\n\n  return state;\n}\n\nvar makeUseVisualState = function (config) {\n  return function (props, isStatic) {\n    var context = React.useContext(MotionContext);\n    var presenceContext = React.useContext(PresenceContext);\n    return isStatic ? makeState(config, props, context, presenceContext) : useConstant(function () {\n      return makeState(config, props, context, presenceContext);\n    });\n  };\n};\n\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  var values = {};\n  var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n  var motionValues = scrapeMotionValues(props);\n\n  for (var key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n\n  var initial = props.initial,\n      animate = props.animate;\n  var isControllingVariants = checkIfControllingVariants(props);\n  var isVariantNode = checkIfVariantNode(props);\n\n  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {\n    initial !== null && initial !== void 0 ? initial : initial = context.initial;\n    animate !== null && animate !== void 0 ? animate : animate = context.animate;\n  }\n\n  var variantToSet = blockInitialAnimation || initial === false ? animate : initial;\n\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    list.forEach(function (definition) {\n      var resolved = resolveVariantFromProps(props, definition);\n      if (!resolved) return;\n      var transitionEnd = resolved.transitionEnd;\n      resolved.transition;\n\n      var target = tslib.__rest(resolved, [\"transitionEnd\", \"transition\"]);\n\n      for (var key in target) values[key] = target[key];\n\n      for (var key in transitionEnd) values[key] = transitionEnd[key];\n    });\n  }\n\n  return values;\n}\n\nvar svgMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    createRenderState: createSvgRenderState,\n    onMount: function (props, instance, _a) {\n      var renderState = _a.renderState,\n          latestValues = _a.latestValues;\n\n      try {\n        renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n      } catch (e) {\n        // Most likely trying to measure an unrendered element under Firefox\n        renderState.dimensions = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (isPath(instance)) {\n        renderState.totalPathLength = instance.getTotalLength();\n      }\n\n      buildSVGAttrs(renderState, latestValues, undefined, undefined, {\n        enableHardwareAcceleration: false\n      }, props.transformTemplate); // TODO: Replace with direct assignment\n\n      renderSVG(instance, renderState);\n    }\n  })\n};\n\nfunction isPath(element) {\n  return element.tagName === \"path\";\n}\n\nvar htmlMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n    createRenderState: createHtmlRenderState\n  })\n};\n\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement) {\n  var _b = _a.forwardMotionProps,\n      forwardMotionProps = _b === void 0 ? false : _b;\n  var baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;\n  return tslib.__assign(tslib.__assign({}, baseConfig), {\n    preloadedFeatures: preloadedFeatures,\n    useRender: createUseRender(forwardMotionProps),\n    createVisualElement: createVisualElement,\n    Component: Component\n  });\n}\n\nvar AnimationType;\n\n(function (AnimationType) {\n  AnimationType[\"Animate\"] = \"animate\";\n  AnimationType[\"Hover\"] = \"whileHover\";\n  AnimationType[\"Tap\"] = \"whileTap\";\n  AnimationType[\"Drag\"] = \"whileDrag\";\n  AnimationType[\"Focus\"] = \"whileFocus\";\n  AnimationType[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\nfunction addDomEvent(target, eventName, handler, options) {\n  target.addEventListener(eventName, handler, options);\n  return function () {\n    return target.removeEventListener(eventName, handler, options);\n  };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\n\n\nfunction useDomEvent(ref, eventName, handler, options) {\n  React.useEffect(function () {\n    var element = ref.current;\n\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\n\n\nfunction useFocusGesture(_a) {\n  var whileFocus = _a.whileFocus,\n      visualElement = _a.visualElement;\n\n  var onFocus = function () {\n    var _a;\n\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, true);\n  };\n\n  var onBlur = function () {\n    var _a;\n\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, false);\n  };\n\n  useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : undefined);\n  useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : undefined);\n}\n\nfunction isMouseEvent(event) {\n  // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n\n  return event instanceof MouseEvent;\n}\n\nfunction isTouchEvent(event) {\n  var hasTouches = !!event.touches;\n  return hasTouches;\n}\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\n\n\nfunction filterPrimaryPointer(eventHandler) {\n  return function (event) {\n    var isMouseEvent = event instanceof MouseEvent;\n    var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;\n\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\n\nvar defaultPagePoint = {\n  pageX: 0,\n  pageY: 0\n};\n\nfunction pointFromTouch(e, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  var primaryTouch = e.touches[0] || e.changedTouches[0];\n  var point = primaryTouch || defaultPagePoint;\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction pointFromMouse(point, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction extractEventInfo(event, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\n\nfunction getViewportPointFromEvent(event) {\n  return extractEventInfo(event, \"client\");\n}\n\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n  if (shouldFilterPrimaryPointer === void 0) {\n    shouldFilterPrimaryPointer = false;\n  }\n\n  var listener = function (event) {\n    return handler(event, extractEventInfo(event));\n  };\n\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n}; // We check for event support via functions in case they've been mocked by a testing suite.\n\n\nvar supportsPointerEvents = function () {\n  return isBrowser && window.onpointerdown === null;\n};\n\nvar supportsTouchEvents = function () {\n  return isBrowser && window.ontouchstart === null;\n};\n\nvar supportsMouseEvents = function () {\n  return isBrowser && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\n\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n\n  return name;\n}\n\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction createLock(name) {\n  var lock = null;\n  return function () {\n    var openLock = function () {\n      lock = null;\n    };\n\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n\n    return false;\n  };\n}\n\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\n\nfunction getGlobalLock(drag) {\n  var lock = false;\n\n  if (drag === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    var openHorizontal_1 = globalHorizontalLock();\n    var openVertical_1 = globalVerticalLock();\n\n    if (openHorizontal_1 && openVertical_1) {\n      lock = function () {\n        openHorizontal_1();\n        openVertical_1();\n      };\n    } else {\n      // Release the locks because we don't use them\n      if (openHorizontal_1) openHorizontal_1();\n      if (openVertical_1) openVertical_1();\n    }\n  }\n\n  return lock;\n}\n\nfunction isDragActive() {\n  // Check the gesture lock - if we get it, it means no drag gesture is active\n  // and we can safely fire the tap gesture.\n  var openGestureLock = getGlobalLock(true);\n  if (!openGestureLock) return true;\n  openGestureLock();\n  return false;\n}\n\nfunction createHoverEvent(visualElement, isActive, callback) {\n  return function (event, info) {\n    var _a;\n\n    if (!isMouseEvent(event) || isDragActive()) return;\n    callback === null || callback === void 0 ? void 0 : callback(event, info);\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\n  };\n}\n\nfunction useHoverGesture(_a) {\n  var onHoverStart = _a.onHoverStart,\n      onHoverEnd = _a.onHoverEnd,\n      whileHover = _a.whileHover,\n      visualElement = _a.visualElement;\n  usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover ? createHoverEvent(visualElement, true, onHoverStart) : undefined);\n  usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover ? createHoverEvent(visualElement, false, onHoverEnd) : undefined);\n}\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\n\n\nvar isNodeOrChild = function (parent, child) {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\nfunction useUnmountEffect(callback) {\n  return React.useEffect(function () {\n    return function () {\n      return callback();\n    };\n  }, []);\n}\n/**\n * @param handlers -\n * @internal\n */\n\n\nfunction useTapGesture(_a) {\n  var onTap = _a.onTap,\n      onTapStart = _a.onTapStart,\n      onTapCancel = _a.onTapCancel,\n      whileTap = _a.whileTap,\n      visualElement = _a.visualElement;\n  var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  var isPressing = React.useRef(false);\n  var cancelPointerEndListeners = React.useRef(null);\n\n  function removePointerEndListener() {\n    var _a;\n\n    (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n    cancelPointerEndListeners.current = null;\n  }\n\n  function checkPointerEnd() {\n    var _a;\n\n    removePointerEndListener();\n    isPressing.current = false;\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd()) return;\n    /**\n     * We only count this as a tap gesture if the event.target is the same\n     * as, or a child of, this component's element\n     */\n\n    !isNodeOrChild(visualElement.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n  }\n\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd()) return;\n    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n  }\n\n  function onPointerDown(event, info) {\n    var _a;\n\n    removePointerEndListener();\n    if (isPressing.current) return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = popmotion.pipe(addPointerEvent(window, \"pointerup\", onPointerUp), addPointerEvent(window, \"pointercancel\", onPointerCancel));\n    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n  }\n\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined);\n  useUnmountEffect(removePointerEndListener);\n}\n\nvar makeRenderlessComponent = function (hook) {\n  return function (props) {\n    hook(props);\n    return null;\n  };\n};\n\nvar gestureAnimations = {\n  tap: makeRenderlessComponent(useTapGesture),\n  focus: makeRenderlessComponent(useFocusGesture),\n  hover: makeRenderlessComponent(useHoverGesture)\n};\n\nfunction shallowCompare(next, prev) {\n  if (!Array.isArray(prev)) return false;\n  var prevLength = prev.length;\n  if (prevLength !== next.length) return false;\n\n  for (var i = 0; i < prevLength; i++) {\n    if (prev[i] !== next[i]) return false;\n  }\n\n  return true;\n}\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n\n\nvar secondsToMilliseconds = function (seconds) {\n  return seconds * 1000;\n};\n\nvar easingLookup = {\n  linear: popmotion.linear,\n  easeIn: popmotion.easeIn,\n  easeInOut: popmotion.easeInOut,\n  easeOut: popmotion.easeOut,\n  circIn: popmotion.circIn,\n  circInOut: popmotion.circInOut,\n  circOut: popmotion.circOut,\n  backIn: popmotion.backIn,\n  backInOut: popmotion.backInOut,\n  backOut: popmotion.backOut,\n  anticipate: popmotion.anticipate,\n  bounceIn: popmotion.bounceIn,\n  bounceInOut: popmotion.bounceInOut,\n  bounceOut: popmotion.bounceOut\n};\n\nvar easingDefinitionToFunction = function (definition) {\n  if (Array.isArray(definition)) {\n    // If cubic bezier definition, create bezier curve\n    heyListen.invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n\n    var _a = tslib.__read(definition, 4),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    return popmotion.cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    // Else lookup from table\n    heyListen.invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n    return easingLookup[definition];\n  }\n\n  return definition;\n};\n\nvar isEasingArray = function (ease) {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\n\n\nvar isAnimatable = function (key, value) {\n  // If the list of keys tat might be non-animatable grows, replace with Set\n  if (key === \"zIndex\") return false; // If it's a number or a keyframes array, we can animate it. We might at some point\n  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n  // but for now lets leave it like this for performance reasons\n\n  if (typeof value === \"number\" || Array.isArray(value)) return true;\n\n  if (typeof value === \"string\" && // It's animatable if we have a string\n  styleValueTypes.complex.test(value) && // And it contains numbers and/or colors\n  !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nvar underDampedSpring = function () {\n  return {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10\n  };\n};\n\nvar criticallyDampedSpring = function (to) {\n  return {\n    type: \"spring\",\n    stiffness: 550,\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n    restDelta: 0.01,\n    restSpeed: 10\n  };\n};\n\nvar linearTween = function () {\n  return {\n    type: \"keyframes\",\n    ease: \"linear\",\n    duration: 0.3\n  };\n};\n\nvar keyframes = function (values) {\n  return {\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values\n  };\n};\n\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: criticallyDampedSpring,\n  scaleY: criticallyDampedSpring,\n  scale: criticallyDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: criticallyDampedSpring\n};\n\nvar getDefaultTransition = function (valueKey, to) {\n  var transitionFactory;\n\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n\n  return tslib.__assign({\n    to: to\n  }, transitionFactory(to));\n};\n/**\n * A map of default value types for common values\n */\n\n\nvar defaultValueTypes = tslib.__assign(tslib.__assign({}, numberValueTypes), {\n  // Color props\n  color: styleValueTypes.color,\n  backgroundColor: styleValueTypes.color,\n  outlineColor: styleValueTypes.color,\n  fill: styleValueTypes.color,\n  stroke: styleValueTypes.color,\n  // Border props\n  borderColor: styleValueTypes.color,\n  borderTopColor: styleValueTypes.color,\n  borderRightColor: styleValueTypes.color,\n  borderBottomColor: styleValueTypes.color,\n  borderLeftColor: styleValueTypes.color,\n  filter: styleValueTypes.filter,\n  WebkitFilter: styleValueTypes.filter\n});\n/**\n * Gets the default ValueType for the provided value key\n */\n\n\nvar getDefaultValueType = function (key) {\n  return defaultValueTypes[key];\n};\n\nfunction getAnimatableNone(key, value) {\n  var _a;\n\n  var defaultValueType = getDefaultValueType(key);\n  if (defaultValueType !== styleValueTypes.filter) defaultValueType = styleValueTypes.complex; // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n\n  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\n\n\nfunction isTransitionDefined(_a) {\n  _a.when;\n  _a.delay;\n  _a.delayChildren;\n  _a.staggerChildren;\n  _a.staggerDirection;\n  _a.repeat;\n  _a.repeatType;\n  _a.repeatDelay;\n  _a.from;\n\n  var transition = tslib.__rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n\n  return !!Object.keys(transition).length;\n}\n\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\n\nfunction convertTransitionToAnimationOptions(_a) {\n  var ease = _a.ease,\n      times = _a.times,\n      yoyo = _a.yoyo,\n      flip = _a.flip,\n      loop = _a.loop,\n      transition = tslib.__rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n\n  var options = tslib.__assign({}, transition);\n\n  if (times) options[\"offset\"] = times;\n  /**\n   * Convert any existing durations from seconds to milliseconds\n   */\n\n  if (transition.duration) options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay) options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  /**\n   * Map easing names to Popmotion's easing functions\n   */\n\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  /**\n   * Support legacy transition API\n   */\n\n\n  if (transition.type === \"tween\") options.type = \"keyframes\";\n  /**\n   * TODO: These options are officially removed from the API.\n   */\n\n  if (yoyo || loop || flip) {\n    heyListen.warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  /**\n   * TODO: Popmotion 9 has the ability to automatically detect whether to use\n   * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n   * It'd be good to introduce a similar thing here.\n   */\n\n\n  if (transition.type !== \"spring\") options.type = \"keyframes\";\n  return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\n\n\nfunction getDelayFromTransition(transition, key) {\n  var _a;\n\n  var valueTransition = getValueTransition(transition, key) || {};\n  return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;\n}\n\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = tslib.__spreadArray([], tslib.__read(options.to));\n    options.to[0] = options.from;\n  }\n\n  return options;\n}\n\nfunction getPopmotionAnimationOptions(transition, options, key) {\n  var _a;\n\n  if (Array.isArray(options.to)) {\n    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;\n  }\n\n  hydrateKeyframes(options);\n  /**\n   * Get a default transition if none is determined to be defined.\n   */\n\n  if (!isTransitionDefined(transition)) {\n    transition = tslib.__assign(tslib.__assign({}, transition), getDefaultTransition(key, options.to));\n  }\n\n  return tslib.__assign(tslib.__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\n\n\nfunction getAnimation(key, value, target, transition, onComplete) {\n  var _a;\n\n  var valueTransition = getValueTransition(transition, key);\n  var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n  var isTargetAnimatable = isAnimatable(key, target);\n\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    /**\n     * If we're trying to animate from \"none\", try and get an animatable version\n     * of the target. This could be improved to work both ways.\n     */\n    origin = getAnimatableNone(key, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n\n  var isOriginAnimatable = isAnimatable(key, origin);\n  heyListen.warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n\n  function start() {\n    var options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete: onComplete,\n      onUpdate: function (v) {\n        return value.set(v);\n      }\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? popmotion.inertia(tslib.__assign(tslib.__assign({}, options), valueTransition)) : popmotion.animate(tslib.__assign(tslib.__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), {\n      onUpdate: function (v) {\n        var _a;\n\n        options.onUpdate(v);\n        (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n      },\n      onComplete: function () {\n        var _a;\n\n        options.onComplete();\n        (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n      }\n    }));\n  }\n\n  function set() {\n    var _a;\n\n    value.set(target);\n    onComplete();\n    (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n    return {\n      stop: function () {}\n    };\n  }\n\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\n\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\n\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone(\"\", potentialUnitType);\n}\n\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n *\n * @internal\n */\n\n\nfunction startAnimation(key, value, target, transition) {\n  if (transition === void 0) {\n    transition = {};\n  }\n\n  return value.start(function (onComplete) {\n    var delayTimer;\n    var controls;\n    var animation = getAnimation(key, value, target, transition, onComplete);\n    var delay = getDelayFromTransition(transition, key);\n\n    var start = function () {\n      return controls = animation();\n    };\n\n    if (delay) {\n      delayTimer = setTimeout(start, secondsToMilliseconds(delay));\n    } else {\n      start();\n    }\n\n    return function () {\n      clearTimeout(delayTimer);\n      controls === null || controls === void 0 ? void 0 : controls.stop();\n    };\n  });\n}\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\n\n\nvar isNumericalString = function (v) {\n  return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\n\nfunction addUniqueItem(arr, item) {\n  arr.indexOf(item) === -1 && arr.push(item);\n}\n\nfunction removeItem(arr, item) {\n  var index = arr.indexOf(item);\n  index > -1 && arr.splice(index, 1);\n}\n\nvar SubscriptionManager =\n/** @class */\nfunction () {\n  function SubscriptionManager() {\n    this.subscriptions = [];\n  }\n\n  SubscriptionManager.prototype.add = function (handler) {\n    var _this = this;\n\n    addUniqueItem(this.subscriptions, handler);\n    return function () {\n      return removeItem(_this.subscriptions, handler);\n    };\n  };\n\n  SubscriptionManager.prototype.notify = function (a, b, c) {\n    var numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions) return;\n\n    if (numSubscriptions === 1) {\n      /**\n       * If there's only a single handler we can just call it without invoking a loop.\n       */\n      this.subscriptions[0](a, b, c);\n    } else {\n      for (var i = 0; i < numSubscriptions; i++) {\n        /**\n         * Check whether the handler exists before firing as it's possible\n         * the subscriptions were modified during this loop running.\n         */\n        var handler = this.subscriptions[i];\n        handler && handler(a, b, c);\n      }\n    }\n  };\n\n  SubscriptionManager.prototype.getSize = function () {\n    return this.subscriptions.length;\n  };\n\n  SubscriptionManager.prototype.clear = function () {\n    this.subscriptions.length = 0;\n  };\n\n  return SubscriptionManager;\n}();\n\nvar isFloat = function (value) {\n  return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\n\n\nvar MotionValue =\n/** @class */\nfunction () {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  function MotionValue(init) {\n    var _this = this;\n    /**\n     * Duration, in milliseconds, since last updating frame.\n     *\n     * @internal\n     */\n\n\n    this.timeDelta = 0;\n    /**\n     * Timestamp of the last time this `MotionValue` was updated.\n     *\n     * @internal\n     */\n\n    this.lastUpdated = 0;\n    /**\n     * Functions to notify when the `MotionValue` updates.\n     *\n     * @internal\n     */\n\n    this.updateSubscribers = new SubscriptionManager();\n    /**\n     * Functions to notify when the velocity updates.\n     *\n     * @internal\n     */\n\n    this.velocityUpdateSubscribers = new SubscriptionManager();\n    /**\n     * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n     *\n     * @internal\n     */\n\n    this.renderSubscribers = new SubscriptionManager();\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n\n    this.canTrackVelocity = false;\n\n    this.updateAndNotify = function (v, render) {\n      if (render === void 0) {\n        render = true;\n      }\n\n      _this.prev = _this.current;\n      _this.current = v; // Update timestamp\n\n      var _a = sync.getFrameData(),\n          delta = _a.delta,\n          timestamp = _a.timestamp;\n\n      if (_this.lastUpdated !== timestamp) {\n        _this.timeDelta = delta;\n        _this.lastUpdated = timestamp;\n        sync__default['default'].postRender(_this.scheduleVelocityCheck);\n      } // Update update subscribers\n\n\n      if (_this.prev !== _this.current) {\n        _this.updateSubscribers.notify(_this.current);\n      } // Update velocity subscribers\n\n\n      if (_this.velocityUpdateSubscribers.getSize()) {\n        _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n      } // Update render subscribers\n\n\n      if (render) {\n        _this.renderSubscribers.notify(_this.current);\n      }\n    };\n    /**\n     * Schedule a velocity check for the next frame.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.scheduleVelocityCheck = function () {\n      return sync__default['default'].postRender(_this.velocityCheck);\n    };\n    /**\n     * Updates `prev` with `current` if the value hasn't been updated this frame.\n     * This ensures velocity calculations return `0`.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.velocityCheck = function (_a) {\n      var timestamp = _a.timestamp;\n\n      if (timestamp !== _this.lastUpdated) {\n        _this.prev = _this.current;\n\n        _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n      }\n    };\n\n    this.hasAnimated = false;\n    this.prev = this.current = init;\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * @library\n   *\n   * ```jsx\n   * function MyComponent() {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <Frame x={x} />\n   * }\n   * ```\n   *\n   * @motion\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @internalremarks\n   *\n   * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n   *\n   * ```jsx\n   * useOnChange(x, () => {})\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.onChange = function (subscription) {\n    return this.updateSubscribers.add(subscription);\n  };\n\n  MotionValue.prototype.clearListeners = function () {\n    this.updateSubscribers.clear();\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` requests a render.\n   *\n   * @param subscriber - A function that's provided the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.onRenderRequest = function (subscription) {\n    // Render immediately\n    subscription(this.get());\n    return this.renderSubscribers.add(subscription);\n  };\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.attach = function (passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  };\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.set = function (v, render) {\n    if (render === void 0) {\n      render = true;\n    }\n\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  };\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.get = function () {\n    return this.current;\n  };\n  /**\n   * @public\n   */\n\n\n  MotionValue.prototype.getPrevious = function () {\n    return this.prev;\n  };\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.getVelocity = function () {\n    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n    return this.canTrackVelocity ? // These casts could be avoided if parseFloat would be typed better\n    popmotion.velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  };\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.start = function (animation) {\n    var _this = this;\n\n    this.stop();\n    return new Promise(function (resolve) {\n      _this.hasAnimated = true;\n      _this.stopAnimation = animation(resolve);\n    }).then(function () {\n      return _this.clearAnimation();\n    });\n  };\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.stop = function () {\n    if (this.stopAnimation) this.stopAnimation();\n    this.clearAnimation();\n  };\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.isAnimating = function () {\n    return !!this.stopAnimation;\n  };\n\n  MotionValue.prototype.clearAnimation = function () {\n    this.stopAnimation = null;\n  };\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.destroy = function () {\n    this.updateSubscribers.clear();\n    this.renderSubscribers.clear();\n    this.stop();\n  };\n\n  return MotionValue;\n}();\n/**\n * @internal\n */\n\n\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n/**\n * Tests a provided value against a ValueType\n */\n\n\nvar testValueType = function (v) {\n  return function (type) {\n    return type.test(v);\n  };\n};\n/**\n * ValueType for \"auto\"\n */\n\n\nvar auto = {\n  test: function (v) {\n    return v === \"auto\";\n  },\n  parse: function (v) {\n    return v;\n  }\n};\n/**\n * A list of value types commonly used for dimensions\n */\n\nvar dimensionValueTypes = [styleValueTypes.number, styleValueTypes.px, styleValueTypes.percent, styleValueTypes.degrees, styleValueTypes.vw, styleValueTypes.vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\n\nvar findDimensionValueType = function (v) {\n  return dimensionValueTypes.find(testValueType(v));\n};\n/**\n * A list of all ValueTypes\n */\n\n\nvar valueTypes = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(dimensionValueTypes)), [styleValueTypes.color, styleValueTypes.complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\n\n\nvar findValueType = function (v) {\n  return valueTypes.find(testValueType(v));\n};\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\n\n\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\n\nfunction setTarget(visualElement, definition) {\n  var resolved = resolveVariant(visualElement, definition);\n\n  var _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {},\n      _b = _a.transitionEnd,\n      transitionEnd = _b === void 0 ? {} : _b;\n\n  _a.transition;\n\n  var target = tslib.__rest(_a, [\"transitionEnd\", \"transition\"]);\n\n  target = tslib.__assign(tslib.__assign({}, target), transitionEnd);\n\n  for (var key in target) {\n    var value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\n\nfunction setVariants(visualElement, variantLabels) {\n  var reversedLabels = tslib.__spreadArray([], tslib.__read(variantLabels)).reverse();\n\n  reversedLabels.forEach(function (key) {\n    var _a;\n\n    var variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      setVariants(child, variantLabels);\n    });\n  });\n}\n\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\n\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b, _c;\n\n  var _d;\n\n  var newValueKeys = Object.keys(target).filter(function (key) {\n    return !visualElement.hasValue(key);\n  });\n  var numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n\n  for (var i = 0; i < numNewValues; i++) {\n    var key = newValueKeys[i];\n    var targetValue = target[key];\n    var value = null;\n    /**\n     * If the target is a series of keyframes, we can use the first value\n     * in the array. If this first value is null, we'll still need to read from the DOM.\n     */\n\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\n     * If the target isn't keyframes, or the first keyframe was null, we need to\n     * first check if an origin value was explicitly defined in the transition as \"from\",\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n     */\n\n\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\n     * If value is still undefined or null, ignore it. Preferably this would throw,\n     * but this was causing issues in Framer.\n     */\n\n\n    if (value === undefined || value === null) continue;\n\n    if (typeof value === \"string\" && isNumericalString(value)) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!findValueType(value) && styleValueTypes.complex.test(targetValue)) {\n      value = getAnimatableNone(key, targetValue);\n    }\n\n    visualElement.addValue(key, motionValue(value));\n    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;\n    visualElement.setBaseTarget(key, value);\n  }\n}\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  var _a, _b;\n\n  var origin = {};\n\n  for (var key in target) {\n    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n  }\n\n  return origin;\n}\n/**\n * @internal\n */\n\n\nfunction animateVisualElement(visualElement, definition, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  visualElement.notifyAnimationStart();\n  var animation;\n\n  if (Array.isArray(definition)) {\n    var animations = definition.map(function (variant) {\n      return animateVariant(visualElement, variant, options);\n    });\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n\n  return animation.then(function () {\n    return visualElement.notifyAnimationComplete(definition);\n  });\n}\n\nfunction animateVariant(visualElement, variant, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var resolved = resolveVariant(visualElement, variant, options.custom);\n  var _b = (resolved || {}).transition,\n      transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n\n  var getAnimation = resolved ? function () {\n    return animateTarget(visualElement, resolved, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n  var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function (forwardDelay) {\n    if (forwardDelay === void 0) {\n      forwardDelay = 0;\n    }\n\n    var _a = transition.delayChildren,\n        delayChildren = _a === void 0 ? 0 : _a,\n        staggerChildren = transition.staggerChildren,\n        staggerDirection = transition.staggerDirection;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n\n  var when = transition.when;\n\n  if (when) {\n    var _c = tslib.__read(when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation], 2),\n        first = _c[0],\n        last = _c[1];\n\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\n * @internal\n */\n\n\nfunction animateTarget(visualElement, definition, _a) {\n  var _b;\n\n  var _c = _a === void 0 ? {} : _a,\n      _d = _c.delay,\n      delay = _d === void 0 ? 0 : _d,\n      transitionOverride = _c.transitionOverride,\n      type = _c.type;\n\n  var _e = visualElement.makeTargetAnimatable(definition),\n      _f = _e.transition,\n      transition = _f === void 0 ? visualElement.getDefaultTransition() : _f,\n      transitionEnd = _e.transitionEnd,\n      target = tslib.__rest(_e, [\"transition\", \"transitionEnd\"]);\n\n  if (transitionOverride) transition = transitionOverride;\n  var animations = [];\n  var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n\n  for (var key in target) {\n    var value = visualElement.getValue(key);\n    var valueTarget = target[key];\n\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n\n    var animation = startAnimation(key, value, valueTarget, tslib.__assign({\n      delay: delay\n    }, transition));\n    animations.push(animation);\n  }\n\n  return Promise.all(animations).then(function () {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\n\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n  if (delayChildren === void 0) {\n    delayChildren = 0;\n  }\n\n  if (staggerChildren === void 0) {\n    staggerChildren = 0;\n  }\n\n  if (staggerDirection === void 0) {\n    staggerDirection = 1;\n  }\n\n  var animations = [];\n  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function (i) {\n    if (i === void 0) {\n      i = 0;\n    }\n\n    return i * staggerChildren;\n  } : function (i) {\n    if (i === void 0) {\n      i = 0;\n    }\n\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {\n    animations.push(animateVariant(child, variant, tslib.__assign(tslib.__assign({}, options), {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(function () {\n      return child.notifyAnimationComplete(variant);\n    }));\n  });\n  return Promise.all(animations);\n}\n\nfunction stopAnimation(visualElement) {\n  visualElement.forEachValue(function (value) {\n    return value.stop();\n  });\n}\n\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\n\n\nfunction shouldBlockAnimation(_a, key) {\n  var protectedKeys = _a.protectedKeys,\n      needsAnimating = _a.needsAnimating;\n  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\nvar variantPriorityOrder = [AnimationType.Animate, AnimationType.Hover, AnimationType.Tap, AnimationType.Drag, AnimationType.Focus, AnimationType.Exit];\n\nvar reversePriorityOrder = tslib.__spreadArray([], tslib.__read(variantPriorityOrder)).reverse();\n\nvar numAnimationTypes = variantPriorityOrder.length;\n\nfunction animateList(visualElement) {\n  return function (animations) {\n    return Promise.all(animations.map(function (_a) {\n      var animation = _a.animation,\n          options = _a.options;\n      return animateVisualElement(visualElement, animation, options);\n    }));\n  };\n}\n\nfunction createAnimationState(visualElement) {\n  var animate = animateList(visualElement);\n  var state = createState();\n  var allAnimatedKeys = {};\n  var isInitialRender = true;\n  /**\n   * This function will be used to reduce the animation definitions for\n   * each active animation type into an object of resolved values for it.\n   */\n\n  var buildResolvedTypeValues = function (acc, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n\n    if (resolved) {\n      resolved.transition;\n\n      var transitionEnd = resolved.transitionEnd,\n          target = tslib.__rest(resolved, [\"transition\", \"transitionEnd\"]);\n\n      acc = tslib.__assign(tslib.__assign(tslib.__assign({}, acc), target), transitionEnd);\n    }\n\n    return acc;\n  };\n\n  function isAnimated(key) {\n    return allAnimatedKeys[key] !== undefined;\n  }\n  /**\n   * This just allows us to inject mocked animation functions\n   * @internal\n   */\n\n\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\n   * When we receive new props, we need to:\n   * 1. Create a list of protected keys for each type. This is a directory of\n   *    value keys that are currently being \"handled\" by types of a higher priority\n   *    so that whenever an animation is played of a given type, these values are\n   *    protected from being animated.\n   * 2. Determine if an animation type needs animating.\n   * 3. Determine if any values have been removed from a type and figure out\n   *    what to animate those to.\n   */\n\n\n  function animateChanges(options, changedActiveType) {\n    var _a;\n\n    var props = visualElement.getProps();\n    var context = visualElement.getVariantContext(true) || {};\n    /**\n     * A list of animations that we'll build into as we iterate through the animation\n     * types. This will get executed at the end of the function.\n     */\n\n    var animations = [];\n    /**\n     * Keep track of which values have been removed. Then, as we hit lower priority\n     * animation types, we can check if they contain removed values and animate to that.\n     */\n\n    var removedKeys = new Set();\n    /**\n     * A dictionary of all encountered keys. This is an object to let us build into and\n     * copy it without iteration. Each time we hit an animation type we set its protected\n     * keys - the keys its not allowed to animate - to the latest version of this object.\n     */\n\n    var encounteredKeys = {};\n    /**\n     * If a variant has been removed at a given index, and this component is controlling\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\n     */\n\n    var removedVariantIndex = Infinity;\n\n    var _loop_1 = function (i) {\n      var type = reversePriorityOrder[i];\n      var typeState = state[type];\n      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      var propIsVariant = isVariantLabel(prop);\n      /**\n       * If this type has *just* changed isActive status, set activeDelta\n       * to that status. Otherwise set to null.\n       */\n\n      var activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\n       * If this prop is an inherited variant, rather than been set directly on the\n       * component itself, we want to make sure we allow the parent to trigger animations.\n       *\n       * TODO: Can probably change this to a !isControllingVariants check\n       */\n\n      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      /**\n       *\n       */\n\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\n       * Set all encountered keys so far as the protected keys for this type. This will\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n       */\n\n\n      typeState.protectedKeys = tslib.__assign({}, encounteredKeys); // Check if we can skip analysing this prop early\n\n      if ( // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type\n      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        return \"continue\";\n      }\n      /**\n       * As we go look through the values defined on this type, if we detect\n       * a changed value or a value that was removed in a higher priority, we set\n       * this to true and add this prop to the animation list.\n       */\n\n\n      var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) || // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      /**\n       * As animations can be set as variant lists, variants or target objects, we\n       * coerce everything to an array if it isn't one already\n       */\n\n      var definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\n       * Build an object of all the resolved values. We'll use this in the subsequent\n       * animateChanges calls to determine whether a value has changed.\n       */\n\n      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\n       * Now we need to loop through all the keys in the prev prop and this prop,\n       * and decide:\n       * 1. If the value has changed, and needs animating\n       * 2. If it has been removed, and needs adding to the removedKeys set\n       * 3. If it has been removed in a higher priority type and needs animating\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n       *    needs adding to the type's protectedKeys list.\n       */\n\n      var _b = typeState.prevResolvedValues,\n          prevResolvedValues = _b === void 0 ? {} : _b;\n\n      var allKeys = tslib.__assign(tslib.__assign({}, prevResolvedValues), resolvedValues);\n\n      var markToAnimate = function (key) {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n\n      for (var key in allKeys) {\n        var next = resolvedValues[key];\n        var prev = prevResolvedValues[key]; // If we've already handled this we can just skip ahead\n\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\n         * If the value has changed, we probably want to animate it.\n         */\n\n        if (next !== prev) {\n          /**\n           * If both values are keyframes, we need to shallow compare them to\n           * detect whether any value has changed. If it has, we animate it.\n           */\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev)) {\n              markToAnimate(key);\n            } else {\n              /**\n               * If it hasn't changed, we want to ensure it doesn't animate by\n               * adding it to the list of protected keys.\n               */\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== undefined) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\n           * If next hasn't changed and it isn't undefined, we want to check if it's\n           * been removed by a higher priority\n           */\n          markToAnimate(key);\n        } else {\n          /**\n           * If it hasn't changed, we add it to the list of protected values\n           * to ensure it doesn't get animated.\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\n       * Update the typeState so next time animateChanges is called we can compare the\n       * latest prop and resolvedValues to these.\n       */\n\n\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      /**\n       *\n       */\n\n      if (typeState.isActive) {\n        encounteredKeys = tslib.__assign(tslib.__assign({}, encounteredKeys), resolvedValues);\n      }\n\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\n       * If this is an inherited prop we want to hard-block animations\n       * TODO: Test as this should probably still handle animations triggered\n       * by removed values?\n       */\n\n\n      if (shouldAnimateType && !isInherited) {\n        animations.push.apply(animations, tslib.__spreadArray([], tslib.__read(definitionList.map(function (animation) {\n          return {\n            animation: animation,\n            options: tslib.__assign({\n              type: type\n            }, options)\n          };\n        }))));\n      }\n    };\n    /**\n     * Iterate through all animation types in reverse priority order. For each, we want to\n     * detect which values it's handling and whether or not they've changed (and therefore\n     * need to be animated). If any values have been removed, we want to detect those in\n     * lower priority props and flag for animation.\n     */\n\n\n    for (var i = 0; i < numAnimationTypes; i++) {\n      _loop_1(i);\n    }\n\n    allAnimatedKeys = tslib.__assign({}, encounteredKeys);\n    /**\n     * If there are some removed value that haven't been dealt with,\n     * we need to create a new animation that falls back either to the value\n     * defined in the style prop, or the last read value.\n     */\n\n    if (removedKeys.size) {\n      var fallbackAnimation_1 = {};\n      removedKeys.forEach(function (key) {\n        var fallbackTarget = visualElement.getBaseTarget(key);\n\n        if (fallbackTarget !== undefined) {\n          fallbackAnimation_1[key] = fallbackTarget;\n        }\n      });\n      animations.push({\n        animation: fallbackAnimation_1\n      });\n    }\n\n    var shouldAnimate = Boolean(animations.length);\n\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\n   * Change whether a certain animation type is active.\n   */\n\n\n  function setActive(type, isActive, options) {\n    var _a; // If the active state hasn't changed, we can safely do nothing here\n\n\n    if (state[type].isActive === isActive) return Promise.resolve(); // Propagate active change to children\n\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      var _a;\n\n      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    return animateChanges(options, type);\n  }\n\n  return {\n    isAnimated: isAnimated,\n    animateChanges: animateChanges,\n    setActive: setActive,\n    setAnimateFunction: setAnimateFunction,\n    getState: function () {\n      return state;\n    }\n  };\n}\n\nfunction variantsHaveChanged(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (isVariantLabels(next)) {\n    return !shallowCompare(next, prev);\n  }\n\n  return false;\n}\n\nfunction createTypeState(isActive) {\n  if (isActive === void 0) {\n    isActive = false;\n  }\n\n  return {\n    isActive: isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\n\nfunction createState() {\n  var _a;\n\n  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;\n}\n\nvar animations = {\n  animation: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        animate = _a.animate;\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n\n    if (isAnimationControls(animate)) {\n      React.useEffect(function () {\n        return animate.subscribe(visualElement);\n      }, [animate]);\n    }\n  }),\n  exit: makeRenderlessComponent(function (props) {\n    var custom = props.custom,\n        visualElement = props.visualElement;\n\n    var _a = tslib.__read(usePresence(), 2),\n        isPresent = _a[0],\n        onExitComplete = _a[1];\n\n    var presenceContext = React.useContext(PresenceContext);\n    React.useEffect(function () {\n      var _a, _b;\n\n      var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, {\n        custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom\n      });\n      !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(onExitComplete));\n    }, [isPresent]);\n  })\n};\n/**\n * @internal\n */\n\nvar PanSession =\n/** @class */\nfunction () {\n  function PanSession(event, handlers, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        transformPagePoint = _b.transformPagePoint;\n    /**\n     * @internal\n     */\n\n\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      var isDistancePastThreshold = popmotion.distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = sync.getFrameData().timestamp;\n\n      _this.history.push(tslib.__assign(tslib.__assign({}, point), {\n        timestamp: timestamp\n      }));\n\n      var _a = _this.handlers,\n          onStart = _a.onStart,\n          onMove = _a.onMove;\n\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n\n      onMove && onMove(_this.lastMoveEvent, info);\n    };\n\n    this.handlePointerMove = function (event, info) {\n      _this.lastMoveEvent = event;\n      _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint); // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n      if (isMouseEvent(event) && event.buttons === 0) {\n        _this.handlePointerUp(event, info);\n\n        return;\n      } // Throttle mouse move event to once per frame\n\n\n      sync__default['default'].update(_this.updatePoint, true);\n    };\n\n    this.handlePointerUp = function (event, info) {\n      _this.end();\n\n      var _a = _this.handlers,\n          onEnd = _a.onEnd,\n          onSessionEnd = _a.onSessionEnd;\n      var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n\n      if (_this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n\n      onSessionEnd && onSessionEnd(event, panInfo);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = sync.getFrameData().timestamp;\n    this.history = [tslib.__assign(tslib.__assign({}, point), {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = popmotion.pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n\n  PanSession.prototype.updateHandlers = function (handlers) {\n    this.handlers = handlers;\n  };\n\n  PanSession.prototype.end = function () {\n    this.removeListeners && this.removeListeners();\n    sync.cancelSync.update(this.updatePoint);\n  };\n\n  return PanSession;\n}();\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point: point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n\nfunction noop(any) {\n  return any;\n}\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\n\n\nfunction convertBoundingBoxToAxisBox(_a) {\n  var top = _a.top,\n      left = _a.left,\n      right = _a.right,\n      bottom = _a.bottom;\n  return {\n    x: {\n      min: left,\n      max: right\n    },\n    y: {\n      min: top,\n      max: bottom\n    }\n  };\n}\n\nfunction convertAxisBoxToBoundingBox(_a) {\n  var x = _a.x,\n      y = _a.y;\n  return {\n    top: y.min,\n    bottom: y.max,\n    left: x.min,\n    right: x.max\n  };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\n\n\nfunction transformBoundingBox(_a, transformPoint) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n\n  if (transformPoint === void 0) {\n    transformPoint = noop;\n  }\n\n  var topLeft = transformPoint({\n    x: left,\n    y: top\n  });\n  var bottomRight = transformPoint({\n    x: right,\n    y: bottom\n  });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n/**\n * Create an empty axis box of zero size\n */\n\n\nfunction axisBox() {\n  return {\n    x: {\n      min: 0,\n      max: 1\n    },\n    y: {\n      min: 0,\n      max: 1\n    }\n  };\n}\n\nfunction copyAxisBox(box) {\n  return {\n    x: tslib.__assign({}, box.x),\n    y: tslib.__assign({}, box.y)\n  };\n}\n/**\n * Create an empty box delta\n */\n\n\nvar zeroDelta = {\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n};\n\nfunction delta() {\n  return {\n    x: tslib.__assign({}, zeroDelta),\n    y: tslib.__assign({}, zeroDelta)\n  };\n} // Call a handler once for each axis\n\n\nfunction eachAxis(handler) {\n  return [handler(\"x\"), handler(\"y\")];\n}\n\nvar clampProgress = function (v) {\n  return popmotion.clamp(0, 1, v);\n};\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\n\n\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n\n  return popmotion.distance(value, target) < maxDistance;\n}\n\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\n\n\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = calcLength(source);\n  var targetLength = calcLength(target);\n\n  if (targetLength > sourceLength) {\n    origin = popmotion.progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = popmotion.progress(source.min, source.max - targetLength, target.min);\n  }\n\n  return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateAxisDelta(delta, source, target, origin) {\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  delta.origin = origin;\n  delta.originPoint = popmotion.mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = popmotion.mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n  updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\n\n\nfunction defaultOrigin(origin) {\n  return typeof origin === \"number\" ? origin : 0.5;\n}\n\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\n\nfunction calcRelativeBox(projection, parentProjection) {\n  calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n  calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\n\n\nfunction applyConstraints(point, _a, elastic) {\n  var min = _a.min,\n      max = _a.max;\n\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? popmotion.mix(min, point, elastic.min) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? popmotion.mix(max, point, elastic.max) : Math.min(point, max);\n  }\n\n  return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\n\n\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n  // Calculate a min point for this axis and apply it to the current pointer\n  var min = point - length * progress;\n  return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\n\n\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== undefined ? axis.min + min : undefined,\n    max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n  };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\n\n\nfunction calcRelativeConstraints(layoutBox, _a) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\n\n\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  var _a;\n\n  var min = constraintsAxis.min - layoutAxis.min;\n  var max = constraintsAxis.max - layoutAxis.max; // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    _a = tslib.__read([max, min], 2), min = _a[0], max = _a[1];\n  }\n\n  return {\n    min: layoutAxis.min + min,\n    max: layoutAxis.min + max\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\n\n\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\n\n\nfunction calcPositionFromProgress(axis, constraints, progress) {\n  var axisLength = axis.max - axis.min;\n  var min = popmotion.mix(constraints.min, constraints.max - axisLength, progress);\n  return {\n    min: min,\n    max: min + axisLength\n  };\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\n\n\nfunction rebaseAxisConstraints(layout, constraints) {\n  var relativeConstraints = {};\n\n  if (constraints.min !== undefined) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n\n  if (constraints.max !== undefined) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n\n  return relativeConstraints;\n}\n\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\n\nfunction resolveDragElastic(dragElastic) {\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\n\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\n\nfunction resolvePointElastic(dragElastic, label) {\n  var _a;\n\n  return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\n\n\nfunction getBoundingBox(element, transformPagePoint) {\n  var box = element.getBoundingClientRect();\n  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n\nvar compareByDepth = function (a, b) {\n  return a.depth - b.depth;\n};\n\nfunction isProjecting(visualElement) {\n  var isEnabled = visualElement.projection.isEnabled;\n  return isEnabled || visualElement.shouldResetTransform();\n}\n\nfunction collectProjectingAncestors(visualElement, ancestors) {\n  if (ancestors === void 0) {\n    ancestors = [];\n  }\n\n  var parent = visualElement.parent;\n  if (parent) collectProjectingAncestors(parent, ancestors);\n  if (isProjecting(visualElement)) ancestors.push(visualElement);\n  return ancestors;\n}\n\nfunction collectProjectingChildren(visualElement) {\n  var children = [];\n\n  var addChild = function (child) {\n    if (isProjecting(child)) children.push(child);\n    child.children.forEach(addChild);\n  };\n\n  visualElement.children.forEach(addChild);\n  return children.sort(compareByDepth);\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\n\n\nfunction updateLayoutMeasurement(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  var layoutState = visualElement.getLayoutState();\n  visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n  layoutState.isHydrated = true;\n  layoutState.layout = visualElement.measureViewportBox();\n  layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n  visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n  sync__default['default'].update(function () {\n    return visualElement.rebaseProjectionTarget();\n  });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\n\n\nfunction snapshotViewportBox(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n  /**\n   * Update targetBox to match the prevViewportBox. This is just to ensure\n   * that targetBox is affected by scroll in the same way as the measured box\n   */\n\n  visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nfunction tweenAxis(target, prev, next, p) {\n  target.min = popmotion.mix(prev.min, next.min, p);\n  target.max = popmotion.mix(prev.max, next.max, p);\n}\n\nfunction calcRelativeOffsetAxis(parent, child) {\n  return {\n    min: child.min - parent.min,\n    max: child.max - parent.min\n  };\n}\n\nfunction calcRelativeOffset(parent, child) {\n  return {\n    x: calcRelativeOffsetAxis(parent.x, child.x),\n    y: calcRelativeOffsetAxis(parent.y, child.y)\n  };\n}\n\nfunction checkIfParentHasChanged(prev, next) {\n  var prevId = prev.getLayoutId();\n  var nextId = next.getLayoutId();\n  return prevId !== nextId || nextId === undefined && prev !== next;\n}\n\nfunction isDraggable(visualElement) {\n  var _a = visualElement.getProps(),\n      drag = _a.drag,\n      _dragX = _a._dragX;\n\n  return drag && !_dragX;\n}\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetAxis(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetBox(box, originBox) {\n  resetAxis(box.x, originBox.x);\n  resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\n\n\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\n\n\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\n\n\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x,\n      y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\n\n\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n  var _b = tslib.__read(_a, 3),\n      key = _b[0],\n      scaleKey = _b[1],\n      originKey = _b[2]; // Copy the current axis to the final axis before mutation\n\n\n  final.min = axis.min;\n  final.max = axis.max;\n  var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n  var originPoint = popmotion.mix(axis.min, axis.max, axisOrigin); // Apply the axis delta to the final axis\n\n  applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\n\n\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\n\nfunction applyBoxTransforms(finalBox, box, transforms) {\n  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\n\n\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale, originPoint);\n\n  if (boxScale !== undefined) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n\n  return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\n\n\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  var originPoint = popmotion.mix(axis.min, axis.max, origin) - translate;\n  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeAxisTransforms(axis, transforms, _a) {\n  var _b = tslib.__read(_a, 3),\n      key = _b[0],\n      scaleKey = _b[1],\n      originKey = _b[2];\n\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeBoxTransforms(box, transforms) {\n  removeAxisTransforms(box.x, transforms, xKeys);\n  removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\n\n\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  var treeLength = treePath.length;\n  if (!treeLength) return; // Reset the treeScale\n\n  treeScale.x = treeScale.y = 1;\n  var node;\n  var delta;\n\n  for (var i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.getLayoutState().delta; // Incoporate each ancestor's scale into a culmulative treeScale for this component\n\n    treeScale.x *= delta.x.scale;\n    treeScale.y *= delta.y.scale; // Apply each ancestor's calculated delta into this component's recorded layout box\n\n    applyBoxDelta(box, delta); // If this is a draggable ancestor, also incorporate the node's transform to the layout box\n\n    if (isDraggable(node)) {\n      applyBoxTransforms(box, box, node.getLatestValues());\n    }\n  }\n}\n/**\n * Returns a boolean stating whether or not we converted the projection\n * to relative projection.\n */\n\n\nfunction convertToRelativeProjection(visualElement, isLayoutDrag) {\n  if (isLayoutDrag === void 0) {\n    isLayoutDrag = true;\n  }\n\n  var projectionParent = visualElement.getProjectionParent();\n  if (!projectionParent) return false;\n  var offset;\n\n  if (isLayoutDrag) {\n    offset = calcRelativeOffset(projectionParent.projection.target, visualElement.projection.target);\n    removeBoxTransforms(offset, projectionParent.getLatestValues());\n  } else {\n    offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n  }\n\n  eachAxis(function (axis) {\n    return visualElement.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);\n  });\n  return true;\n}\n\nvar unresolvedJobs = new Set();\n\nfunction pushJob(stack, job, pointer) {\n  if (!stack[pointer]) stack[pointer] = [];\n  stack[pointer].push(job);\n}\n\nfunction batchLayout(callback) {\n  unresolvedJobs.add(callback);\n  return function () {\n    return unresolvedJobs.delete(callback);\n  };\n}\n\nfunction flushLayout() {\n  if (!unresolvedJobs.size) return;\n  var pointer = 0;\n  var reads = [[]];\n  var writes = [];\n\n  var setRead = function (job) {\n    return pushJob(reads, job, pointer);\n  };\n\n  var setWrite = function (job) {\n    pushJob(writes, job, pointer);\n    pointer++;\n  };\n  /**\n   * Resolve jobs into their array stacks\n   */\n\n\n  unresolvedJobs.forEach(function (callback) {\n    callback(setRead, setWrite);\n    pointer = 0;\n  });\n  unresolvedJobs.clear();\n  /**\n   * Execute jobs\n   */\n\n  var numStacks = writes.length;\n\n  for (var i = 0; i <= numStacks; i++) {\n    reads[i] && reads[i].forEach(executeJob);\n    writes[i] && writes[i].forEach(executeJob);\n  }\n}\n\nvar executeJob = function (job) {\n  return job();\n};\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\n\nvar lastPointerEvent;\n\nvar VisualElementDragControls =\n/** @class */\nfunction () {\n  function VisualElementDragControls(_a) {\n    var visualElement = _a.visualElement;\n    /**\n     * Track whether we're currently dragging.\n     *\n     * @internal\n     */\n\n    this.isDragging = false;\n    /**\n     * The current direction of drag, or `null` if both.\n     *\n     * @internal\n     */\n\n    this.currentDirection = null;\n    /**\n     * The permitted boundaries of travel, in pixels.\n     *\n     * @internal\n     */\n\n    this.constraints = false;\n    /**\n     * The per-axis resolved elastic values.\n     *\n     * @internal\n     */\n\n    this.elastic = axisBox();\n    /**\n     * A reference to the host component's latest props.\n     *\n     * @internal\n     */\n\n    this.props = {};\n    /**\n     * @internal\n     */\n\n    this.hasMutatedConstraints = false;\n    /**\n     * Track the initial position of the cursor relative to the dragging element\n     * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n     * an ideal bounding box for the VisualElement renderer to project into every frame.\n     *\n     * @internal\n     */\n\n    this.cursorProgress = {\n      x: 0.5,\n      y: 0.5\n    }; // When updating _dragX, or _dragY instead of the VisualElement,\n    // persist their values between drag gestures.\n\n    this.originPoint = {}; // This is a reference to the global drag gesture lock, ensuring only one component\n    // can \"capture\" the drag of one or both axes.\n    // TODO: Look into moving this into pansession?\n\n    this.openGlobalLock = null;\n    /**\n     * @internal\n     */\n\n    this.panSession = null;\n    this.visualElement = visualElement;\n    this.visualElement.enableLayoutProjection();\n    elementDragControls.set(visualElement, this);\n  }\n  /**\n   * Instantiate a PanSession for the drag gesture\n   *\n   * @public\n   */\n\n\n  VisualElementDragControls.prototype.start = function (originEvent, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.snapToCursor,\n        snapToCursor = _c === void 0 ? false : _c,\n        cursorProgress = _b.cursorProgress;\n\n    var onSessionStart = function (event) {\n      var _a; // Stop any animations on both axis values immediately. This allows the user to throw and catch\n      // the component.\n\n\n      _this.stopMotion();\n      /**\n       * Save the initial point. We'll use this to calculate the pointer's position rather\n       * than the one we receive when the gesture actually starts. By then, the pointer will\n       * have already moved, and the perception will be of the pointer \"slipping\" across the element\n       */\n\n\n      var initialPoint = getViewportPointFromEvent(event).point;\n      (_a = _this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(_this);\n      _this.cancelLayout = batchLayout(function (read, write) {\n        var ancestors = collectProjectingAncestors(_this.visualElement);\n        var children = collectProjectingChildren(_this.visualElement);\n\n        var tree = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(children));\n\n        var hasManuallySetCursorOrigin = false;\n        /**\n         * Apply a simple lock to the projection target. This ensures no animations\n         * can run on the projection box while this lock is active.\n         */\n\n        _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();\n        write(function () {\n          tree.forEach(function (element) {\n            return element.resetTransform();\n          });\n        });\n        read(function () {\n          updateLayoutMeasurement(_this.visualElement);\n          children.forEach(updateLayoutMeasurement);\n        });\n        write(function () {\n          tree.forEach(function (element) {\n            return element.restoreTransform();\n          });\n\n          if (snapToCursor) {\n            hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);\n          }\n        });\n        read(function () {\n          var isRelativeDrag = Boolean(_this.getAxisMotionValue(\"x\") && !_this.isExternalDrag());\n\n          if (!isRelativeDrag) {\n            _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));\n          }\n\n          _this.visualElement.scheduleUpdateLayoutProjection();\n          /**\n           * When dragging starts, we want to find where the cursor is relative to the bounding box\n           * of the element. Every frame, we calculate a new bounding box using this relative position\n           * and let the visualElement renderer figure out how to reproject the element into this bounding\n           * box.\n           *\n           * By doing it this way, rather than applying an x/y transform directly to the element,\n           * we can ensure the component always visually sticks to the cursor as we'd expect, even\n           * if the DOM element itself changes layout as a result of React updates the user might\n           * make based on the drag position.\n           */\n\n\n          var projection = _this.visualElement.projection;\n          eachAxis(function (axis) {\n            if (!hasManuallySetCursorOrigin) {\n              var _a = projection.target[axis],\n                  min = _a.min,\n                  max = _a.max;\n              _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : popmotion.progress(min, max, initialPoint[axis]);\n            }\n            /**\n             * If we have external drag MotionValues, record their origin point. On pointermove\n             * we'll apply the pan gesture offset directly to this value.\n             */\n\n\n            var axisValue = _this.getAxisMotionValue(axis);\n\n            if (axisValue) {\n              _this.originPoint[axis] = axisValue.get();\n            }\n          });\n        });\n        write(function () {\n          sync.flushSync.update();\n          sync.flushSync.preRender();\n          sync.flushSync.render();\n          sync.flushSync.postRender();\n        });\n        read(function () {\n          return _this.resolveDragConstraints();\n        });\n      });\n    };\n\n    var onStart = function (event, info) {\n      var _a, _b, _c; // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n\n\n      var _d = _this.props,\n          drag = _d.drag,\n          dragPropagation = _d.dragPropagation;\n\n      if (drag && !dragPropagation) {\n        if (_this.openGlobalLock) _this.openGlobalLock();\n        _this.openGlobalLock = getGlobalLock(drag); // If we don 't have the lock, don't start dragging\n\n        if (!_this.openGlobalLock) return;\n      }\n\n      flushLayout(); // Set current drag status\n\n      _this.isDragging = true;\n      _this.currentDirection = null; // Fire onDragStart event\n\n      (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n      (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);\n    };\n\n    var onMove = function (event, info) {\n      var _a, _b, _c, _d;\n\n      var _e = _this.props,\n          dragPropagation = _e.dragPropagation,\n          dragDirectionLock = _e.dragDirectionLock; // If we didn't successfully receive the gesture lock, early return.\n\n      if (!dragPropagation && !_this.openGlobalLock) return;\n      var offset = info.offset; // Attempt to detect drag direction if directionLock is true\n\n      if (dragDirectionLock && _this.currentDirection === null) {\n        _this.currentDirection = getCurrentDirection(offset); // If we've successfully set a direction, notify listener\n\n        if (_this.currentDirection !== null) {\n          (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n        }\n\n        return;\n      } // Update each point with the latest position\n\n\n      _this.updateAxis(\"x\", info.point, offset);\n\n      _this.updateAxis(\"y\", info.point, offset); // Fire onDrag event\n\n\n      (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info); // Update the last pointer event\n\n      lastPointerEvent = event;\n    };\n\n    var onSessionEnd = function (event, info) {\n      return _this.stop(event, info);\n    };\n\n    var transformPagePoint = this.props.transformPagePoint;\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart: onSessionStart,\n      onStart: onStart,\n      onMove: onMove,\n      onSessionEnd: onSessionEnd\n    }, {\n      transformPagePoint: transformPagePoint\n    });\n  };\n\n  VisualElementDragControls.prototype.resolveDragConstraints = function () {\n    var _this = this;\n\n    var _a = this.props,\n        dragConstraints = _a.dragConstraints,\n        dragElastic = _a.dragElastic;\n    var layout = this.visualElement.getLayoutState().layoutCorrected;\n\n    if (dragConstraints) {\n      this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(layout, dragConstraints) : calcRelativeConstraints(layout, dragConstraints);\n    } else {\n      this.constraints = false;\n    }\n\n    this.elastic = resolveDragElastic(dragElastic);\n    /**\n     * If we're outputting to external MotionValues, we want to rebase the measured constraints\n     * from viewport-relative to component-relative.\n     */\n\n    if (this.constraints && !this.hasMutatedConstraints) {\n      eachAxis(function (axis) {\n        if (_this.getAxisMotionValue(axis)) {\n          _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);\n        }\n      });\n    }\n  };\n\n  VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n    var _a = this.props,\n        onMeasureDragConstraints = _a.onMeasureDragConstraints,\n        transformPagePoint = _a.transformPagePoint;\n    var constraintsElement = constraints.current;\n    heyListen.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n    var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n    /**\n     * If there's an onMeasureDragConstraints listener we call it and\n     * if different constraints are returned, set constraints to that\n     */\n\n    if (onMeasureDragConstraints) {\n      var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n      }\n    }\n\n    return measuredConstraints;\n  };\n\n  VisualElementDragControls.prototype.cancelDrag = function () {\n    var _a, _b;\n\n    this.visualElement.unlockProjectionTarget();\n    (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);\n    this.isDragging = false;\n    this.panSession && this.panSession.end();\n    this.panSession = null;\n\n    if (!this.props.dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n\n    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n  };\n\n  VisualElementDragControls.prototype.stop = function (event, info) {\n    var _a, _b, _c;\n\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = null;\n    var isDragging = this.isDragging;\n    this.cancelDrag();\n    if (!isDragging) return;\n    var velocity = info.velocity;\n    this.animateDragEnd(velocity);\n    (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);\n  };\n\n  VisualElementDragControls.prototype.snapToCursor = function (point) {\n    var _this = this;\n\n    return eachAxis(function (axis) {\n      var drag = _this.props.drag; // If we're not dragging this axis, do an early return.\n\n      if (!shouldDrag(axis, drag, _this.currentDirection)) return;\n\n      var axisValue = _this.getAxisMotionValue(axis);\n\n      if (axisValue) {\n        var box = _this.visualElement.getLayoutState().layout;\n\n        var length_1 = box[axis].max - box[axis].min;\n        var center = box[axis].min + length_1 / 2;\n        var offset = point[axis] - center;\n        _this.originPoint[axis] = point[axis];\n        axisValue.set(offset);\n      } else {\n        _this.cursorProgress[axis] = 0.5;\n        return true;\n      }\n    }).includes(true);\n  };\n  /**\n   * Update the specified axis with the latest pointer information.\n   */\n\n\n  VisualElementDragControls.prototype.updateAxis = function (axis, point, offset) {\n    var drag = this.props.drag; // If we're not dragging this axis, do an early return.\n\n    if (!shouldDrag(axis, drag, this.currentDirection)) return;\n    return this.getAxisMotionValue(axis) ? this.updateAxisMotionValue(axis, offset) : this.updateVisualElementAxis(axis, point);\n  };\n\n  VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {\n    var axisValue = this.getAxisMotionValue(axis);\n    if (!offset || !axisValue) return;\n    var nextValue = this.originPoint[axis] + offset[axis];\n    var update = this.constraints ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis]) : nextValue;\n    axisValue.set(update);\n  };\n\n  VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, point) {\n    var _a; // Get the actual layout bounding box of the element\n\n\n    var axisLayout = this.visualElement.getLayoutState().layout[axis]; // Calculate its current length. In the future we might want to lerp this to animate\n    // between lengths if the layout changes as we change the DOM\n\n    var axisLength = axisLayout.max - axisLayout.min; // Get the initial progress that the pointer sat on this axis on gesture start.\n\n    var axisProgress = this.cursorProgress[axis]; // Calculate a new min point based on the latest pointer position, constraints and elastic\n\n    var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]); // Update the axis viewport target with this new min and the length\n\n    this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\n  };\n\n  VisualElementDragControls.prototype.setProps = function (_a) {\n    var _b = _a.drag,\n        drag = _b === void 0 ? false : _b,\n        _c = _a.dragDirectionLock,\n        dragDirectionLock = _c === void 0 ? false : _c,\n        _d = _a.dragPropagation,\n        dragPropagation = _d === void 0 ? false : _d,\n        _e = _a.dragConstraints,\n        dragConstraints = _e === void 0 ? false : _e,\n        _f = _a.dragElastic,\n        dragElastic = _f === void 0 ? defaultElastic : _f,\n        _g = _a.dragMomentum,\n        dragMomentum = _g === void 0 ? true : _g,\n        remainingProps = tslib.__rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n\n    this.props = tslib.__assign({\n      drag: drag,\n      dragDirectionLock: dragDirectionLock,\n      dragPropagation: dragPropagation,\n      dragConstraints: dragConstraints,\n      dragElastic: dragElastic,\n      dragMomentum: dragMomentum\n    }, remainingProps);\n  };\n  /**\n   * Drag works differently depending on which props are provided.\n   *\n   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n   * - If the component will perform layout animations, we output the gesture to the component's\n   *      visual bounding box\n   * - Otherwise, we apply the delta to the x/y motion values.\n   */\n\n\n  VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n    var _a = this.props,\n        layout = _a.layout,\n        layoutId = _a.layoutId;\n    var dragKey = \"_drag\" + axis.toUpperCase();\n\n    if (this.props[dragKey]) {\n      return this.props[dragKey];\n    } else if (!layout && layoutId === undefined) {\n      return this.visualElement.getValue(axis, 0);\n    }\n  };\n\n  VisualElementDragControls.prototype.isLayoutDrag = function () {\n    return !this.getAxisMotionValue(\"x\");\n  };\n\n  VisualElementDragControls.prototype.isExternalDrag = function () {\n    var _a = this.props,\n        _dragX = _a._dragX,\n        _dragY = _a._dragY;\n    return _dragX || _dragY;\n  };\n\n  VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragMomentum = _a.dragMomentum,\n        dragElastic = _a.dragElastic,\n        dragTransition = _a.dragTransition;\n    /**\n     * Everything beyond the drag gesture should be performed with\n     * relative projection so children stay in sync with their parent element.\n     */\n\n    var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());\n    /**\n     * If we had previously resolved constraints relative to the viewport,\n     * we need to also convert those to a relative coordinate space for the animation\n     */\n\n    var constraints = this.constraints || {};\n\n    if (isRelative && Object.keys(constraints).length && this.isLayoutDrag()) {\n      var projectionParent = this.visualElement.getProjectionParent();\n\n      if (projectionParent) {\n        var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);\n        eachAxis(function (axis) {\n          var _a = relativeConstraints_1[axis],\n              min = _a.min,\n              max = _a.max;\n          constraints[axis] = {\n            min: isNaN(min) ? undefined : min,\n            max: isNaN(max) ? undefined : max\n          };\n        });\n      }\n    }\n\n    var momentumAnimations = eachAxis(function (axis) {\n      var _a;\n\n      if (!shouldDrag(axis, drag, _this.currentDirection)) {\n        return;\n      }\n\n      var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n      /**\n       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n       * of spring animations so we should look into adding a disable spring option to `inertia`.\n       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n       * using the value of `dragElastic`.\n       */\n\n      var bounceStiffness = dragElastic ? 200 : 1000000;\n      var bounceDamping = dragElastic ? 40 : 10000000;\n\n      var inertia = tslib.__assign(tslib.__assign({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness: bounceStiffness,\n        bounceDamping: bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition); // If we're not animating on an externally-provided `MotionValue` we can use the\n      // component's animation controls which will handle interactions with whileHover (etc),\n      // otherwise we just have to animate the `MotionValue` itself.\n\n\n      return _this.getAxisMotionValue(axis) ? _this.startAxisValueAnimation(axis, inertia) : _this.visualElement.startLayoutAnimation(axis, inertia, isRelative);\n    }); // Run all animations and then resolve the new drag constraints.\n\n    return Promise.all(momentumAnimations).then(function () {\n      var _a, _b;\n\n      (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n\n  VisualElementDragControls.prototype.stopMotion = function () {\n    var _this = this;\n\n    eachAxis(function (axis) {\n      var axisValue = _this.getAxisMotionValue(axis);\n\n      axisValue ? axisValue.stop() : _this.visualElement.stopLayoutAnimation();\n    });\n  };\n\n  VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n    var axisValue = this.getAxisMotionValue(axis);\n    if (!axisValue) return;\n    var currentValue = axisValue.get();\n    axisValue.set(currentValue);\n    axisValue.set(currentValue); // Set twice to hard-reset velocity\n\n    return startAnimation(axis, axisValue, 0, transition);\n  };\n\n  VisualElementDragControls.prototype.scalePoint = function () {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragConstraints = _a.dragConstraints;\n    if (!isRefObject(dragConstraints) || !this.constraintsBox) return; // Stop any current animations as there can be some visual glitching if we resize mid animation\n\n    this.stopMotion(); // Record the relative progress of the targetBox relative to the constraintsBox\n\n    var boxProgress = {\n      x: 0,\n      y: 0\n    };\n    eachAxis(function (axis) {\n      boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\n    });\n    /**\n     * For each axis, calculate the current progress of the layout axis within the constraints.\n     * Then, using the latest layout and constraints measurements, reposition the new layout axis\n     * proportionally within the constraints.\n     */\n\n    this.updateConstraints(function () {\n      eachAxis(function (axis) {\n        if (!shouldDrag(axis, drag, null)) return; // Calculate the position of the targetBox relative to the constraintsBox using the\n        // previously calculated progress\n\n        var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]),\n            min = _a.min,\n            max = _a.max;\n\n        _this.visualElement.setProjectionTargetAxis(axis, min, max);\n      });\n    });\n    /**\n     * If any other draggable components are queuing the same tasks synchronously\n     * this will wait until they've all been scheduled before flushing.\n     */\n\n    setTimeout(flushLayout, 1);\n  };\n\n  VisualElementDragControls.prototype.updateConstraints = function (onReady) {\n    var _this = this;\n\n    this.cancelLayout = batchLayout(function (read, write) {\n      var ancestors = collectProjectingAncestors(_this.visualElement);\n      write(function () {\n        return ancestors.forEach(function (element) {\n          return element.resetTransform();\n        });\n      });\n      read(function () {\n        return updateLayoutMeasurement(_this.visualElement);\n      });\n      write(function () {\n        return ancestors.forEach(function (element) {\n          return element.restoreTransform();\n        });\n      });\n      read(function () {\n        _this.resolveDragConstraints();\n      });\n      if (onReady) write(onReady);\n    });\n  };\n\n  VisualElementDragControls.prototype.mount = function (visualElement) {\n    var _this = this;\n\n    var element = visualElement.getInstance();\n    /**\n     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n     */\n\n    var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n      var _a = _this.props,\n          drag = _a.drag,\n          _b = _a.dragListener,\n          dragListener = _b === void 0 ? true : _b;\n      drag && dragListener && _this.start(event);\n    });\n    /**\n     * Attach a window resize listener to scale the draggable target within its defined\n     * constraints as the window resizes.\n     */\n\n    var stopResizeListener = addDomEvent(window, \"resize\", function () {\n      _this.scalePoint();\n    });\n    /**\n     * Ensure drag constraints are resolved correctly relative to the dragging element\n     * whenever its layout changes.\n     */\n\n    var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n      if (_this.isDragging) {\n        _this.resolveDragConstraints();\n      }\n    });\n    /**\n     * If the previous component with this same layoutId was dragging at the time\n     * it was unmounted, we want to continue the same gesture on this component.\n     */\n\n    var prevDragCursor = visualElement.prevDragCursor;\n\n    if (prevDragCursor) {\n      this.start(lastPointerEvent, {\n        cursorProgress: prevDragCursor\n      });\n    }\n    /**\n     * Return a function that will teardown the drag gesture\n     */\n\n\n    return function () {\n      stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n      stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n\n      _this.cancelDrag();\n    };\n  };\n\n  return VisualElementDragControls;\n}();\n\nfunction shouldDrag(direction, drag, currentDirection) {\n  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\n\n\nfunction getCurrentDirection(offset, lockThreshold) {\n  if (lockThreshold === void 0) {\n    lockThreshold = 10;\n  }\n\n  var direction = null;\n\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n\n  return direction;\n}\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\n\n\nfunction useDrag(props) {\n  var groupDragControls = props.dragControls,\n      visualElement = props.visualElement;\n  var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n  var dragControls = useConstant(function () {\n    return new VisualElementDragControls({\n      visualElement: visualElement\n    });\n  });\n  dragControls.setProps(tslib.__assign(tslib.__assign({}, props), {\n    transformPagePoint: transformPagePoint\n  })); // If we've been provided a DragControls for manual control over the drag gesture,\n  // subscribe this component to it on mount.\n\n  React.useEffect(function () {\n    return groupDragControls && groupDragControls.subscribe(dragControls);\n  }, [dragControls]); // Mount the drag controls with the visualElement\n\n  React.useEffect(function () {\n    return dragControls.mount(visualElement);\n  }, []);\n}\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\n\n\nfunction usePanGesture(_a) {\n  var onPan = _a.onPan,\n      onPanStart = _a.onPanStart,\n      onPanEnd = _a.onPanEnd,\n      onPanSessionStart = _a.onPanSessionStart,\n      visualElement = _a.visualElement;\n  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  var panSession = React.useRef(null);\n  var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function (event, info) {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  React.useEffect(function () {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint: transformPagePoint\n    });\n  }\n\n  usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(function () {\n    return panSession.current && panSession.current.end();\n  });\n}\n\nvar drag = {\n  pan: makeRenderlessComponent(usePanGesture),\n  drag: makeRenderlessComponent(useDrag)\n};\n/**\n * @public\n */\n\nvar Presence;\n\n(function (Presence) {\n  Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n  Presence[Presence[\"Present\"] = 1] = \"Present\";\n  Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n/**\n * @public\n */\n\n\nexports.VisibilityAction = void 0;\n\n(function (VisibilityAction) {\n  VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n  VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(exports.VisibilityAction || (exports.VisibilityAction = {}));\n\nfunction isCSSVariable(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\n\n\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nfunction parseCSSVariable(current) {\n  var match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n\n  var _a = tslib.__read(match, 3),\n      token = _a[1],\n      fallback = _a[2];\n\n  return [token, fallback];\n}\n\nvar maxDepth = 4;\n\nfunction getVariableValue(current, element, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  heyListen.invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n\n  var _a = tslib.__read(parseCSSVariable(current), 2),\n      token = _a[0],\n      fallback = _a[1]; // No CSS variable detected\n\n\n  if (!token) return; // Attempt to read this CSS variable off the element\n\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\n\n\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var _b;\n\n  var target = tslib.__rest(_a, []);\n\n  var element = visualElement.getInstance();\n  if (!(element instanceof HTMLElement)) return {\n    target: target,\n    transitionEnd: transitionEnd\n  }; // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n\n  if (transitionEnd) {\n    transitionEnd = tslib.__assign({}, transitionEnd);\n  } // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n\n\n  visualElement.forEachValue(function (value) {\n    var current = value.get();\n    if (!isCSSVariable(current)) return;\n    var resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  }); // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n\n  for (var key in target) {\n    var current = target[key];\n    if (!isCSSVariable(current)) continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved) continue; // Clone target if it hasn't already been\n\n    target[key] = resolved; // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n\n    if (transitionEnd) (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;\n  }\n\n  return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\n\n\nfunction correctBorderRadius(latest, _layoutState, _a) {\n  var target = _a.target;\n  /**\n   * If latest is a string, if it's a percentage we can return immediately as it's\n   * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n   */\n\n  if (typeof latest === \"string\") {\n    if (styleValueTypes.px.test(latest)) {\n      latest = parseFloat(latest);\n    } else {\n      return latest;\n    }\n  }\n  /**\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n   * pixel value as a percentage of each axis\n   */\n\n\n  var x = pixelsToPercent(latest, target.x);\n  var y = pixelsToPercent(latest, target.y);\n  return x + \"% \" + y + \"%\";\n}\n\nvar varToken = \"_$css\";\n\nfunction correctBoxShadow(latest, _a) {\n  var delta = _a.delta,\n      treeScale = _a.treeScale;\n  var original = latest;\n  /**\n   * We need to first strip and store CSS variables from the string.\n   */\n\n  var containsCSSVariables = latest.includes(\"var(\");\n  var cssVariables = [];\n\n  if (containsCSSVariables) {\n    latest = latest.replace(cssVariableRegex, function (match) {\n      cssVariables.push(match);\n      return varToken;\n    });\n  }\n\n  var shadow = styleValueTypes.complex.parse(latest); // TODO: Doesn't support multiple shadows\n\n  if (shadow.length > 5) return original;\n  var template = styleValueTypes.complex.createTransformer(latest);\n  var offset = typeof shadow[0] !== \"number\" ? 1 : 0; // Calculate the overall context scale\n\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y;\n  shadow[0 + offset] /= xScale;\n  shadow[1 + offset] /= yScale;\n  /**\n   * Ideally we'd correct x and y scales individually, but because blur and\n   * spread apply to both we have to take a scale average and apply that instead.\n   * We could potentially improve the outcome of this by incorporating the ratio between\n   * the two scales.\n   */\n\n  var averageScale = popmotion.mix(xScale, yScale, 0.5); // Blur\n\n  if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale; // Spread\n\n  if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n  var output = template(shadow);\n\n  if (containsCSSVariables) {\n    var i_1 = 0;\n    output = output.replace(varToken, function () {\n      var cssVariable = cssVariables[i_1];\n      i_1++;\n      return cssVariable;\n    });\n  }\n\n  return output;\n}\n\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar defaultScaleCorrectors = {\n  borderRadius: tslib.__assign(tslib.__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\nvar progressTarget = 1000;\n\nvar Animate =\n/** @class */\nfunction (_super) {\n  tslib.__extends(Animate, _super);\n\n  function Animate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A mutable object that tracks the target viewport box\n     * for the current animation frame.\n     */\n\n\n    _this.frameTarget = axisBox();\n    /**\n     * The current animation target, we use this to check whether to start\n     * a new animation or continue the existing one.\n     */\n\n    _this.currentAnimationTarget = axisBox();\n    /**\n     * Track whether we're animating this axis.\n     */\n\n    _this.isAnimating = {\n      x: false,\n      y: false\n    };\n    _this.stopAxisAnimation = {\n      x: undefined,\n      y: undefined\n    };\n    _this.isAnimatingTree = false;\n\n    _this.animate = function (target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n\n      var originBox = _a.originBox,\n          targetBox = _a.targetBox,\n          visibilityAction = _a.visibilityAction,\n          shouldStackAnimate = _a.shouldStackAnimate,\n          onComplete = _a.onComplete,\n          prevParent = _a.prevParent,\n          config = tslib.__rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\", \"prevParent\"]);\n\n      var _b = _this.props,\n          visualElement = _b.visualElement,\n          layout = _b.layout;\n      /**\n       * Early return if we've been instructed not to animate this render.\n       */\n\n      if (shouldStackAnimate === false) {\n        _this.isAnimatingTree = false;\n        return _this.safeToRemove();\n      }\n      /**\n       * Prioritise tree animations\n       */\n\n\n      if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n        return;\n      } else if (shouldStackAnimate) {\n        _this.isAnimatingTree = true;\n      }\n      /**\n       * Allow the measured origin (prev bounding box) and target (actual layout) to be\n       * overridden by the provided config.\n       */\n\n\n      origin = originBox || origin;\n      target = targetBox || target;\n      /**\n       * If this element has a projecting parent, there's an opportunity to animate\n       * it relatively to that parent rather than relatively to the viewport. This\n       * allows us to add orchestrated animations.\n       */\n\n      var isRelative = false;\n      var projectionParent = visualElement.getProjectionParent();\n\n      if (projectionParent) {\n        var prevParentViewportBox = projectionParent.prevViewportBox;\n        var parentLayout = projectionParent.getLayoutState().layout;\n        /**\n         * If we're being provided a previous parent VisualElement by AnimateSharedLayout\n         */\n\n        if (prevParent) {\n          /**\n           * If we've been provided an explicit target box it means we're animating back\n           * to this previous parent. So we can make a relative box by comparing to the previous\n           * parent's layout\n           */\n          if (targetBox) {\n            parentLayout = prevParent.getLayoutState().layout;\n          }\n          /**\n           * Likewise if we've been provided an explicit origin box it means we're\n           * animating out from a different element. So we should figure out where that was\n           * on screen relative to the new parent element.\n           */\n\n\n          if (originBox && !checkIfParentHasChanged(prevParent, projectionParent) && prevParent.prevViewportBox) {\n            prevParentViewportBox = prevParent.prevViewportBox;\n          }\n        }\n\n        if (prevParentViewportBox && isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\n          isRelative = true;\n          origin = calcRelativeOffset(prevParentViewportBox, origin);\n          target = calcRelativeOffset(parentLayout, target);\n        }\n      }\n\n      var boxHasMoved = hasMoved(origin, target);\n      var animations = eachAxis(function (axis) {\n        var _a, _b;\n        /**\n         * If layout is set to \"position\", we can resize the origin box based on the target\n         * box and only animate its position.\n         */\n\n\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n\n        if (visualElement.projection.isTargetLocked) {\n          return;\n        } else if (visibilityAction !== undefined) {\n          visualElement.setVisibility(visibilityAction === exports.VisibilityAction.Show);\n        } else if (boxHasMoved) {\n          // If the box has moved, animate between it's current visual state and its\n          // final state\n          return _this.animateAxis(axis, target[axis], origin[axis], tslib.__assign(tslib.__assign({}, config), {\n            isRelative: isRelative\n          }));\n        } else {\n          (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); // If the box has remained in the same place, immediately set the axis target\n          // to the final desired state\n\n          return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\n        }\n      }); // Force a render to ensure there's no flash of uncorrected bounding box.\n\n      visualElement.syncRender();\n      /**\n       * If this visualElement isn't present (ie it's been removed from the tree by the user but\n       * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n       * have successfully finished.\n       */\n\n      return Promise.all(animations).then(function () {\n        _this.isAnimatingTree = false;\n        onComplete && onComplete();\n        visualElement.notifyLayoutAnimationComplete();\n      });\n    };\n\n    return _this;\n  }\n\n  Animate.prototype.componentDidMount = function () {\n    var _this = this;\n\n    var visualElement = this.props.visualElement;\n    visualElement.animateMotionValue = startAnimation;\n    visualElement.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n\n    visualElement.layoutSafeToRemove = function () {\n      return _this.safeToRemove();\n    };\n\n    addScaleCorrection(defaultScaleCorrectors);\n  };\n\n  Animate.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    this.unsubLayoutReady();\n    eachAxis(function (axis) {\n      var _a, _b;\n\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  /**\n   * TODO: This manually performs animations on the visualElement's layout progress\n   * values. It'd be preferable to amend the startLayoutAxisAnimation\n   * API to accept more custom animations like this.\n   */\n\n\n  Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n    var _this = this;\n\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        transition = _d.transition,\n        isRelative = _d.isRelative;\n    /**\n     * If we're not animating to a new target, don't run this animation\n     */\n\n\n    if (this.isAnimating[axis] && axisIsEqual(target, this.currentAnimationTarget[axis])) {\n      return;\n    }\n\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    this.isAnimating[axis] = true;\n    var visualElement = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n    /**\n     * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n     * be re-incoporated into a subsequent spring animation.\n     */\n\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    /**\n     * Create an animation function to run once per frame. This will tween the visual bounding box from\n     * origin to target using the latest progress value.\n     */\n\n    var frame = function () {\n      // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n      var p = layoutProgress.get() / progressTarget; // Tween the axis and update the visualElement with the latest values\n\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\n    }; // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n\n\n    frame(); // Create a function to stop animation on this specific axis\n\n    var unsubscribeProgress = layoutProgress.onChange(frame);\n\n    this.stopAxisAnimation[axis] = function () {\n      _this.isAnimating[axis] = false;\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n\n    this.currentAnimationTarget[axis] = target;\n    var layoutTransition = transition || visualElement.getDefaultTransition() || defaultLayoutTransition; // Start the animation on this axis\n\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \"layout\")).then(this.stopAxisAnimation[axis]);\n    return animation;\n  };\n\n  Animate.prototype.safeToRemove = function () {\n    var _a, _b;\n\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n\n  Animate.prototype.render = function () {\n    return null;\n  };\n\n  return Animate;\n}(React__namespace.Component);\n\nfunction AnimateLayoutContextProvider(props) {\n  var _a = tslib.__read(usePresence(), 2),\n      safeToRemove = _a[1];\n\n  return React__namespace.createElement(Animate, tslib.__assign({}, props, {\n    safeToRemove: safeToRemove\n  }));\n}\n\nfunction hasMoved(a, b) {\n  return !isZeroBox(a) && !isZeroBox(b) && (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y));\n}\n\nvar zeroAxis = {\n  min: 0,\n  max: 0\n};\n\nfunction isZeroBox(a) {\n  return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\n\nfunction axisIsEqual(a, b) {\n  return a.min === b.min && a.max === b.max;\n}\n\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\n\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\n  return prevParent || !prevParent && !(originBox || targetBox);\n}\n/**\n * Default handlers for batching VisualElements\n */\n\n\nvar defaultHandler = {\n  layoutReady: function (child) {\n    return child.notifyLayoutReady();\n  }\n};\n/**\n * Create a batcher to process VisualElements\n */\n\nfunction createBatcher() {\n  var queue = new Set();\n  return {\n    add: function (child) {\n      return queue.add(child);\n    },\n    flush: function (_a) {\n      var _b = _a === void 0 ? defaultHandler : _a,\n          layoutReady = _b.layoutReady,\n          parent = _b.parent;\n\n      batchLayout(function (read, write) {\n        var order = Array.from(queue).sort(compareByDepth);\n        var ancestors = parent ? collectProjectingAncestors(parent) : [];\n        write(function () {\n          var allElements = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(order));\n\n          allElements.forEach(function (element) {\n            return element.resetTransform();\n          });\n        });\n        read(function () {\n          order.forEach(updateLayoutMeasurement);\n        });\n        write(function () {\n          ancestors.forEach(function (element) {\n            return element.restoreTransform();\n          });\n          order.forEach(layoutReady);\n        });\n        read(function () {\n          /**\n           * After all children have started animating, ensure any Entering components are set to Present.\n           * If we add deferred animations (set up all animations and then start them in two loops) this\n           * could be moved to the start loop. But it needs to happen after all the animations configs\n           * are generated in AnimateSharedLayout as this relies on presence data\n           */\n          order.forEach(function (child) {\n            if (child.isPresent) child.presence = Presence.Present;\n          });\n        });\n        write(function () {\n          /**\n           * Starting these animations will have queued jobs on the frame loop. In some situations,\n           * like when removing an element, these will be processed too late after the DOM is manipulated,\n           * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n           * we ensure there's no flash.\n           */\n          sync.flushSync.preRender();\n          sync.flushSync.render();\n        });\n        read(function () {\n          /**\n           * Schedule a callback at the end of the following frame to assign the latest projection\n           * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n           * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n           * child attempts to calculate its previous relative position against a prevViewportBox\n           * it will be against its latest projection box instead, as the snapshot is useless beyond this\n           * render.\n           */\n          sync__default['default'].postRender(function () {\n            return order.forEach(assignProjectionToSnapshot);\n          });\n          queue.clear();\n        });\n      }); // TODO: Need to find a layout-synchronous way of flushing this\n\n      flushLayout();\n    }\n  };\n}\n\nfunction assignProjectionToSnapshot(child) {\n  child.prevViewportBox = child.projection.target;\n}\n\nvar SharedLayoutContext = React.createContext(createBatcher());\n/**\n * @internal\n */\n\nvar FramerTreeLayoutContext = React.createContext(createBatcher());\n\nfunction isSharedLayout(context) {\n  return !!context.forceUpdate;\n}\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\n\n\nvar Measure =\n/** @class */\nfunction (_super) {\n  tslib.__extends(Measure, _super);\n\n  function Measure() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * If this is a child of a SyncContext, register the VisualElement with it on mount.\n   */\n\n\n  Measure.prototype.componentDidMount = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        framerSyncLayout = _a.framerSyncLayout,\n        visualElement = _a.visualElement;\n    isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n    isSharedLayout(framerSyncLayout) && framerSyncLayout.register(visualElement);\n    visualElement.onUnmount(function () {\n      if (isSharedLayout(syncLayout)) {\n        syncLayout.remove(visualElement);\n      }\n\n      if (isSharedLayout(framerSyncLayout)) {\n        framerSyncLayout.remove(visualElement);\n      }\n    });\n  };\n  /**\n   * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n   * handle the snapshotting.\n   *\n   * If it is stand-alone component, add it to the batcher.\n   */\n\n\n  Measure.prototype.getSnapshotBeforeUpdate = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        visualElement = _a.visualElement;\n\n    if (isSharedLayout(syncLayout)) {\n      syncLayout.syncUpdate();\n    } else {\n      snapshotViewportBox(visualElement);\n      syncLayout.add(visualElement);\n    }\n\n    return null;\n  };\n\n  Measure.prototype.componentDidUpdate = function () {\n    var syncLayout = this.props.syncLayout;\n    if (!isSharedLayout(syncLayout)) syncLayout.flush();\n  };\n\n  Measure.prototype.render = function () {\n    return null;\n  };\n\n  return Measure;\n}(React__default['default'].Component);\n\nfunction MeasureContextProvider(props) {\n  var syncLayout = React.useContext(SharedLayoutContext);\n  var framerSyncLayout = React.useContext(FramerTreeLayoutContext);\n  return React__default['default'].createElement(Measure, tslib.__assign({}, props, {\n    syncLayout: syncLayout,\n    framerSyncLayout: framerSyncLayout\n  }));\n}\n\nvar layoutAnimations = {\n  measureLayout: MeasureContextProvider,\n  layoutAnimation: AnimateLayoutContextProvider\n};\n\nvar createProjectionState = function () {\n  return {\n    isEnabled: false,\n    isHydrated: false,\n    isTargetLocked: false,\n    target: axisBox(),\n    targetFinal: axisBox()\n  };\n};\n\nfunction createLayoutState() {\n  return {\n    isHydrated: false,\n    layout: axisBox(),\n    layoutCorrected: axisBox(),\n    treeScale: {\n      x: 1,\n      y: 1\n    },\n    delta: delta(),\n    deltaFinal: delta(),\n    deltaTransform: \"\"\n  };\n}\n\nvar zeroLayout = createLayoutState();\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\n\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n  var x = _a.x,\n      y = _a.y;\n  /**\n   * The translations we use to calculate are always relative to the viewport coordinate space.\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n   */\n\n  var xTranslate = x.translate / treeScale.x;\n  var yTranslate = y.translate / treeScale.y;\n  var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n\n  if (latestTransform) {\n    var rotate = latestTransform.rotate,\n        rotateX = latestTransform.rotateX,\n        rotateY = latestTransform.rotateY;\n    if (rotate) transform += \"rotate(\" + rotate + \") \";\n    if (rotateX) transform += \"rotateX(\" + rotateX + \") \";\n    if (rotateY) transform += \"rotateY(\" + rotateY + \") \";\n  }\n\n  transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n  return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\n\n\nfunction buildLayoutProjectionTransformOrigin(_a) {\n  var deltaFinal = _a.deltaFinal;\n  return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\n\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, {\n  x: 1,\n  y: 1\n});\nvar names = [\"LayoutMeasure\", \"BeforeLayoutMeasure\", \"LayoutUpdate\", \"ViewportBoxUpdate\", \"Update\", \"Render\", \"AnimationComplete\", \"LayoutAnimationComplete\", \"AnimationStart\", \"SetAxisTarget\", \"Unmount\"];\n\nfunction createLifecycles() {\n  var managers = names.map(function () {\n    return new SubscriptionManager();\n  });\n  var propSubscriptions = {};\n  var lifecycles = {\n    clearAllListeners: function () {\n      return managers.forEach(function (manager) {\n        return manager.clear();\n      });\n    },\n    updatePropListeners: function (props) {\n      return names.forEach(function (name) {\n        var _a;\n\n        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n        var on = \"on\" + name;\n        var propListener = props[on];\n\n        if (propListener) {\n          propSubscriptions[name] = lifecycles[on](propListener);\n        }\n      });\n    }\n  };\n  managers.forEach(function (manager, i) {\n    lifecycles[\"on\" + names[i]] = function (handler) {\n      return manager.add(handler);\n    };\n\n    lifecycles[\"notify\" + names[i]] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return manager.notify.apply(manager, tslib.__spreadArray([], tslib.__read(args)));\n    };\n  });\n  return lifecycles;\n}\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n  var _a;\n\n  for (var key in next) {\n    var nextValue = next[key];\n    var prevValue = prev[key];\n\n    if (isMotionValue(nextValue)) {\n      /**\n       * If this is a motion value found in props or style, we want to add it\n       * to our visual element's motion value map.\n       */\n      element.addValue(key, nextValue);\n    } else if (isMotionValue(prevValue)) {\n      /**\n       * If we're swapping to a new motion value, create a new motion value\n       * from that\n       */\n      element.addValue(key, motionValue(nextValue));\n    } else if (prevValue !== nextValue) {\n      /**\n       * If this is a flat value that has changed, update the motion value\n       * or create one if it doesn't exist. We only want to do this if we're\n       * not handling the value with our animation state.\n       */\n      if (element.hasValue(key)) {\n        var existingValue = element.getValue(key); // TODO: Only update values that aren't being animated or even looked at\n\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n      }\n    }\n  } // Handle removed values\n\n\n  for (var key in prev) {\n    if (next[key] === undefined) element.removeValue(key);\n  }\n\n  return next;\n}\n\nfunction updateLayoutDeltas(_a, _b, treePath, transformOrigin) {\n  var delta = _a.delta,\n      layout = _a.layout,\n      layoutCorrected = _a.layoutCorrected,\n      treeScale = _a.treeScale;\n  var target = _b.target;\n  /**\n   * Reset the corrected box with the latest values from box, as we're then going\n   * to perform mutative operations on it.\n   */\n\n  resetBox(layoutCorrected, layout);\n  /**\n   * Apply all the parent deltas to this box to produce the corrected box. This\n   * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n   */\n\n  applyTreeDeltas(layoutCorrected, treeScale, treePath);\n  /**\n   * Update the delta between the corrected box and the target box before user-set transforms were applied.\n   * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n   * for our layout reprojection, but still allow them to be scaled correctly by the user.\n   * It might be that to simplify this we may want to accept that user-set scale is also corrected\n   * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n   * to allow people to choose whether these styles are corrected based on just the\n   * layout reprojection or the final bounding box.\n   */\n\n  updateBoxDelta(delta, layoutCorrected, target, transformOrigin);\n}\n\nvar FlatTree =\n/** @class */\nfunction () {\n  function FlatTree() {\n    this.children = [];\n    this.isDirty = false;\n  }\n\n  FlatTree.prototype.add = function (child) {\n    addUniqueItem(this.children, child);\n    this.isDirty = true;\n  };\n\n  FlatTree.prototype.remove = function (child) {\n    removeItem(this.children, child);\n    this.isDirty = true;\n  };\n\n  FlatTree.prototype.forEach = function (callback) {\n    this.isDirty && this.children.sort(compareByDepth);\n    this.isDirty = false;\n    this.children.forEach(callback);\n  };\n\n  return FlatTree;\n}();\n\nfunction setCurrentViewportBox(visualElement) {\n  var projectionParent = visualElement.getProjectionParent();\n\n  if (!projectionParent) {\n    visualElement.rebaseProjectionTarget();\n    return;\n  }\n\n  var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n  eachAxis(function (axis) {\n    visualElement.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);\n  });\n}\n\nvar visualElement = function (_a) {\n  var _b = _a.treeType,\n      treeType = _b === void 0 ? \"\" : _b,\n      build = _a.build,\n      getBaseTarget = _a.getBaseTarget,\n      makeTargetAnimatable = _a.makeTargetAnimatable,\n      measureViewportBox = _a.measureViewportBox,\n      renderInstance = _a.render,\n      readValueFromInstance = _a.readValueFromInstance,\n      resetTransform = _a.resetTransform,\n      restoreTransform = _a.restoreTransform,\n      removeValueFromRenderState = _a.removeValueFromRenderState,\n      sortNodePosition = _a.sortNodePosition,\n      scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n  return function (_a, options) {\n    var parent = _a.parent,\n        props = _a.props,\n        presenceId = _a.presenceId,\n        blockInitialAnimation = _a.blockInitialAnimation,\n        visualState = _a.visualState;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var latestValues = visualState.latestValues,\n        renderState = visualState.renderState;\n    /**\n     * The instance of the render-specific node that will be hydrated by the\n     * exposed React ref. So for example, this visual element can host a\n     * HTMLElement, plain object, or Three.js object. The functions provided\n     * in VisualElementConfig allow us to interface with this instance.\n     */\n\n    var instance;\n    /**\n     * Manages the subscriptions for a visual element's lifecycle, for instance\n     * onRender and onViewportBoxUpdate.\n     */\n\n    var lifecycles = createLifecycles();\n    /**\n     *\n     */\n\n    var projection = createProjectionState();\n    /**\n     * A reference to the nearest projecting parent. This is either\n     * undefined if we haven't looked for the nearest projecting parent,\n     * false if there is no parent performing layout projection, or a reference\n     * to the projecting parent.\n     */\n\n    var projectionParent;\n    /**\n     * This is a reference to the visual state of the \"lead\" visual element.\n     * Usually, this will be this visual element. But if it shares a layoutId\n     * with other visual elements, only one of them will be designated lead by\n     * AnimateSharedLayout. All the other visual elements will take on the visual\n     * appearance of the lead while they crossfade to it.\n     */\n\n    var leadProjection = projection;\n    var leadLatestValues = latestValues;\n    var unsubscribeFromLeadVisualElement;\n    /**\n     * The latest layout measurements and calculated projections. This\n     * is seperate from the target projection data in visualState as\n     * many visual elements might point to the same piece of visualState as\n     * a target, whereas they might each have different layouts and thus\n     * projection calculations needed to project into the same viewport box.\n     */\n\n    var layoutState = createLayoutState();\n    /**\n     *\n     */\n\n    var crossfader;\n    /**\n     * Keep track of whether the viewport box has been updated since the\n     * last time the layout projection was re-calculated.\n     */\n\n    var hasViewportBoxUpdated = false;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n\n    var values = new Map();\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n\n    var valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n\n    var prevMotionValues = {};\n    /**\n     * x/y motion values that track the progress of initiated layout\n     * animations.\n     *\n     * TODO: Target for removal\n     */\n\n    var projectionTargetProgress;\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n\n    var baseTarget = tslib.__assign({}, latestValues); // Internal methods ========================\n\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n\n\n    var removeFromVariantTree;\n    /**\n     *\n     */\n\n    function render() {\n      if (!instance) return;\n\n      if (element.isProjectionReady()) {\n        /**\n         * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n         * This is the final box that we will then project into by calculating a transform delta and\n         * applying it to the corrected box.\n         */\n        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n        /**\n         * Update the delta between the corrected box and the final target box, after\n         * user-set transforms are applied to it. This will be used by the renderer to\n         * create a transform style that will reproject the element from its actual layout\n         * into the desired bounding box.\n         */\n\n        updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n      }\n\n      triggerBuild();\n      renderInstance(instance, renderState);\n    }\n\n    function triggerBuild() {\n      var valuesToRender = latestValues;\n\n      if (crossfader && crossfader.isActive()) {\n        var crossfadedValues = crossfader.getCrossfadeState(element);\n        if (crossfadedValues) valuesToRender = crossfadedValues;\n      }\n\n      build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n    }\n\n    function update() {\n      lifecycles.notifyUpdate(latestValues);\n    }\n\n    function updateLayoutProjection() {\n      if (!element.isProjectionReady()) return;\n      var delta = layoutState.delta,\n          treeScale = layoutState.treeScale;\n      var prevTreeScaleX = treeScale.x;\n      var prevTreeScaleY = treeScale.y;\n      var prevDeltaTransform = layoutState.deltaTransform;\n      updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n      hasViewportBoxUpdated && element.notifyViewportBoxUpdate(leadProjection.target, delta);\n      hasViewportBoxUpdated = false;\n      var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n\n      if (deltaTransform !== prevDeltaTransform || // Also compare calculated treeScale, for values that rely on this only for scale correction\n      prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {\n        element.scheduleRender();\n      }\n\n      layoutState.deltaTransform = deltaTransform;\n    }\n\n    function updateTreeLayoutProjection() {\n      element.layoutTree.forEach(fireUpdateLayoutProjection);\n    }\n    /**\n     *\n     */\n\n\n    function bindToMotionValue(key, value) {\n      var removeOnChange = value.onChange(function (latestValue) {\n        latestValues[key] = latestValue;\n        props.onUpdate && sync__default['default'].update(update, false, true);\n      });\n      var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n      valueSubscriptions.set(key, function () {\n        removeOnChange();\n        removeOnRenderRequest();\n      });\n    }\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\n     * more a reflection of the test.\n     */\n\n\n    var initialMotionValues = scrapeMotionValuesFromProps(props);\n\n    for (var key in initialMotionValues) {\n      var value = initialMotionValues[key];\n\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n      }\n    }\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n\n\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n\n    var element = tslib.__assign(tslib.__assign({\n      treeType: treeType,\n\n      /**\n       * This is a mirror of the internal instance prop, which keeps\n       * VisualElement type-compatible with React's RefObject.\n       */\n      current: null,\n\n      /**\n       * The depth of this visual element within the visual element tree.\n       */\n      depth: parent ? parent.depth + 1 : 0,\n      parent: parent,\n      children: new Set(),\n\n      /**\n       * An ancestor path back to the root visual element. This is used\n       * by layout projection to quickly recurse back up the tree.\n       */\n      path: parent ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(parent.path)), [parent]) : [],\n      layoutTree: parent ? parent.layoutTree : new FlatTree(),\n\n      /**\n       *\n       */\n      presenceId: presenceId,\n      projection: projection,\n\n      /**\n       * If this component is part of the variant tree, it should track\n       * any children that are also part of the tree. This is essentially\n       * a shadow tree to simplify logic around how to stagger over children.\n       */\n      variantChildren: isVariantNode ? new Set() : undefined,\n\n      /**\n       * Whether this instance is visible. This can be changed imperatively\n       * by AnimateSharedLayout, is analogous to CSS's visibility in that\n       * hidden elements should take up layout, and needs enacting by the configured\n       * render function.\n       */\n      isVisible: undefined,\n\n      /**\n       * Normally, if a component is controlled by a parent's variants, it can\n       * rely on that ancestor to trigger animations further down the tree.\n       * However, if a component is created after its parent is mounted, the parent\n       * won't trigger that mount animation so the child needs to.\n       *\n       * TODO: This might be better replaced with a method isParentMounted\n       */\n      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n\n      /**\n       * This can be set by AnimatePresence to force components that mount\n       * at the same time as it to mount as if they have initial={false} set.\n       */\n      blockInitialAnimation: blockInitialAnimation,\n\n      /**\n       * Determine whether this component has mounted yet. This is mostly used\n       * by variant children to determine whether they need to trigger their\n       * own animations on mount.\n       */\n      isMounted: function () {\n        return Boolean(instance);\n      },\n      mount: function (newInstance) {\n        instance = element.current = newInstance;\n        element.pointTo(element);\n\n        if (isVariantNode && parent && !isControllingVariants) {\n          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n        }\n\n        parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n      },\n\n      /**\n       *\n       */\n      unmount: function () {\n        sync.cancelSync.update(update);\n        sync.cancelSync.render(render);\n        sync.cancelSync.preRender(element.updateLayoutProjection);\n        valueSubscriptions.forEach(function (remove) {\n          return remove();\n        });\n        element.stopLayoutAnimation();\n        element.layoutTree.remove(element);\n        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        lifecycles.clearAllListeners();\n      },\n\n      /**\n       * Add a child visual element to our set of children.\n       */\n      addVariantChild: function (child) {\n        var _a;\n\n        var closestVariantNode = element.getClosestVariantNode();\n\n        if (closestVariantNode) {\n          (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n          return function () {\n            return closestVariantNode.variantChildren.delete(child);\n          };\n        }\n      },\n      sortNodePosition: function (other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!sortNodePosition || treeType !== other.treeType) return 0;\n        return sortNodePosition(element.getInstance(), other.getInstance());\n      },\n\n      /**\n       * Returns the closest variant node in the tree starting from\n       * this visual element.\n       */\n      getClosestVariantNode: function () {\n        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n      },\n\n      /**\n       * A method that schedules an update to layout projections throughout\n       * the tree. We inherit from the parent so there's only ever one\n       * job scheduled on the next frame - that of the root visual element.\n       */\n      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function () {\n        return sync__default['default'].preRender(element.updateTreeLayoutProjection, false, true);\n      },\n\n      /**\n       * Expose the latest layoutId prop.\n       */\n      getLayoutId: function () {\n        return props.layoutId;\n      },\n\n      /**\n       * Returns the current instance.\n       */\n      getInstance: function () {\n        return instance;\n      },\n\n      /**\n       * Get/set the latest static values.\n       */\n      getStaticValue: function (key) {\n        return latestValues[key];\n      },\n      setStaticValue: function (key, value) {\n        return latestValues[key] = value;\n      },\n\n      /**\n       * Returns the latest motion value state. Currently only used to take\n       * a snapshot of the visual element - perhaps this can return the whole\n       * visual state\n       */\n      getLatestValues: function () {\n        return latestValues;\n      },\n\n      /**\n       * Set the visiblity of the visual element. If it's changed, schedule\n       * a render to reflect these changes.\n       */\n      setVisibility: function (visibility) {\n        if (element.isVisible === visibility) return;\n        element.isVisible = visibility;\n        element.scheduleRender();\n      },\n\n      /**\n       * Make a target animatable by Popmotion. For instance, if we're\n       * trying to animate width from 100px to 100vw we need to measure 100vw\n       * in pixels to determine what we really need to animate to. This is also\n       * pluggable to support Framer's custom value types like Color,\n       * and CSS variables.\n       */\n      makeTargetAnimatable: function (target, canMutate) {\n        if (canMutate === void 0) {\n          canMutate = true;\n        }\n\n        return makeTargetAnimatable(element, target, props, canMutate);\n      },\n      // Motion values ========================\n\n      /**\n       * Add a motion value and bind it to this visual element.\n       */\n      addValue: function (key, value) {\n        // Remove existing value if it exists\n        if (element.hasValue(key)) element.removeValue(key);\n        values.set(key, value);\n        latestValues[key] = value.get();\n        bindToMotionValue(key, value);\n      },\n\n      /**\n       * Remove a motion value and unbind any active subscriptions.\n       */\n      removeValue: function (key) {\n        var _a;\n\n        values.delete(key);\n        (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n        valueSubscriptions.delete(key);\n        delete latestValues[key];\n        removeValueFromRenderState(key, renderState);\n      },\n\n      /**\n       * Check whether we have a motion value for this key\n       */\n      hasValue: function (key) {\n        return values.has(key);\n      },\n\n      /**\n       * Get a motion value for this key. If called with a default\n       * value, we'll create one if none exists.\n       */\n      getValue: function (key, defaultValue) {\n        var value = values.get(key);\n\n        if (value === undefined && defaultValue !== undefined) {\n          value = motionValue(defaultValue);\n          element.addValue(key, value);\n        }\n\n        return value;\n      },\n\n      /**\n       * Iterate over our motion values.\n       */\n      forEachValue: function (callback) {\n        return values.forEach(callback);\n      },\n\n      /**\n       * If we're trying to animate to a previously unencountered value,\n       * we need to check for it in our state and as a last resort read it\n       * directly from the instance (which might have performance implications).\n       */\n      readValue: function (key) {\n        var _a;\n\n        return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n      },\n\n      /**\n       * Set the base target to later animate back to. This is currently\n       * only hydrated on creation and when we first read a value.\n       */\n      setBaseTarget: function (key, value) {\n        baseTarget[key] = value;\n      },\n\n      /**\n       * Find the base target for a value thats been removed from all animation\n       * props.\n       */\n      getBaseTarget: function (key) {\n        if (getBaseTarget) {\n          var target = getBaseTarget(props, key);\n          if (target !== undefined && !isMotionValue(target)) return target;\n        }\n\n        return baseTarget[key];\n      }\n    }, lifecycles), {\n      /**\n       * Build the renderer state based on the latest visual state.\n       */\n      build: function () {\n        triggerBuild();\n        return renderState;\n      },\n\n      /**\n       * Schedule a render on the next animation frame.\n       */\n      scheduleRender: function () {\n        sync__default['default'].render(render, false, true);\n      },\n\n      /**\n       * Synchronously fire render. It's prefered that we batch renders but\n       * in many circumstances, like layout measurement, we need to run this\n       * synchronously. However in those instances other measures should be taken\n       * to batch reads/writes.\n       */\n      syncRender: render,\n\n      /**\n       * Update the provided props. Ensure any newly-added motion values are\n       * added to our map, old ones removed, and listeners updated.\n       */\n      setProps: function (newProps) {\n        props = newProps;\n        lifecycles.updatePropListeners(newProps);\n        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n      },\n      getProps: function () {\n        return props;\n      },\n      // Variants ==============================\n\n      /**\n       * Returns the variant definition with a given name.\n       */\n      getVariant: function (name) {\n        var _a;\n\n        return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];\n      },\n\n      /**\n       * Returns the defined default transition on this component.\n       */\n      getDefaultTransition: function () {\n        return props.transition;\n      },\n\n      /**\n       * Used by child variant nodes to get the closest ancestor variant props.\n       */\n      getVariantContext: function (startAtParent) {\n        if (startAtParent === void 0) {\n          startAtParent = false;\n        }\n\n        if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n\n        if (!isControllingVariants) {\n          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n\n          if (props.initial !== undefined) {\n            context_1.initial = props.initial;\n          }\n\n          return context_1;\n        }\n\n        var context = {};\n\n        for (var i = 0; i < numVariantProps; i++) {\n          var name_1 = variantProps[i];\n          var prop = props[name_1];\n\n          if (isVariantLabel(prop) || prop === false) {\n            context[name_1] = prop;\n          }\n        }\n\n        return context;\n      },\n      // Layout projection ==============================\n\n      /**\n       * Enable layout projection for this visual element. Won't actually\n       * occur until we also have hydrated layout measurements.\n       */\n      enableLayoutProjection: function () {\n        projection.isEnabled = true;\n        element.layoutTree.add(element);\n      },\n\n      /**\n       * Lock the projection target, for instance when dragging, so\n       * nothing else can try and animate it.\n       */\n      lockProjectionTarget: function () {\n        projection.isTargetLocked = true;\n      },\n      unlockProjectionTarget: function () {\n        element.stopLayoutAnimation();\n        projection.isTargetLocked = false;\n      },\n      getLayoutState: function () {\n        return layoutState;\n      },\n      setCrossfader: function (newCrossfader) {\n        crossfader = newCrossfader;\n      },\n      isProjectionReady: function () {\n        return projection.isEnabled && projection.isHydrated && layoutState.isHydrated;\n      },\n\n      /**\n       * Start a layout animation on a given axis.\n       */\n      startLayoutAnimation: function (axis, transition, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n\n        var progress = element.getProjectionAnimationProgress()[axis];\n\n        var _a = isRelative ? projection.relativeTarget[axis] : projection.target[axis],\n            min = _a.min,\n            max = _a.max;\n\n        var length = max - min;\n        progress.clearListeners();\n        progress.set(min);\n        progress.set(min); // Set twice to hard-reset velocity\n\n        progress.onChange(function (v) {\n          element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n        });\n        return element.animateMotionValue(axis, progress, 0, transition);\n      },\n\n      /**\n       * Stop layout animations.\n       */\n      stopLayoutAnimation: function () {\n        eachAxis(function (axis) {\n          return element.getProjectionAnimationProgress()[axis].stop();\n        });\n      },\n\n      /**\n       * Measure the current viewport box with or without transforms.\n       * Only measures axis-aligned boxes, rotate and skew must be manually\n       * removed with a re-render to work.\n       */\n      measureViewportBox: function (withTransform) {\n        if (withTransform === void 0) {\n          withTransform = true;\n        }\n\n        var viewportBox = measureViewportBox(instance, options);\n        if (!withTransform) removeBoxTransforms(viewportBox, latestValues);\n        return viewportBox;\n      },\n\n      /**\n       * Get the motion values tracking the layout animations on each\n       * axis. Lazy init if not already created.\n       */\n      getProjectionAnimationProgress: function () {\n        projectionTargetProgress || (projectionTargetProgress = {\n          x: motionValue(0),\n          y: motionValue(0)\n        });\n        return projectionTargetProgress;\n      },\n\n      /**\n       * Update the projection of a single axis. Schedule an update to\n       * the tree layout projection.\n       */\n      setProjectionTargetAxis: function (axis, min, max, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n\n        var target;\n\n        if (isRelative) {\n          if (!projection.relativeTarget) {\n            projection.relativeTarget = axisBox();\n          }\n\n          target = projection.relativeTarget[axis];\n        } else {\n          projection.relativeTarget = undefined;\n          target = projection.target[axis];\n        }\n\n        projection.isHydrated = true;\n        target.min = min;\n        target.max = max; // Flag that we want to fire the onViewportBoxUpdate event handler\n\n        hasViewportBoxUpdated = true;\n        lifecycles.notifySetAxisTarget();\n      },\n\n      /**\n       * Rebase the projection target on top of the provided viewport box\n       * or the measured layout. This ensures that non-animating elements\n       * don't fall out of sync differences in measurements vs projections\n       * after a page scroll or other relayout.\n       */\n      rebaseProjectionTarget: function (force, box) {\n        if (box === void 0) {\n          box = layoutState.layout;\n        }\n\n        var _a = element.getProjectionAnimationProgress(),\n            x = _a.x,\n            y = _a.y;\n\n        var shouldRebase = !projection.relativeTarget && !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();\n\n        if (force || shouldRebase) {\n          eachAxis(function (axis) {\n            var _a = box[axis],\n                min = _a.min,\n                max = _a.max;\n            element.setProjectionTargetAxis(axis, min, max);\n          });\n        }\n      },\n\n      /**\n       * Notify the visual element that its layout is up-to-date.\n       * Currently Animate.tsx uses this to check whether a layout animation\n       * needs to be performed.\n       */\n      notifyLayoutReady: function (config) {\n        setCurrentViewportBox(element);\n        element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n      },\n\n      /**\n       * Temporarily reset the transform of the instance.\n       */\n      resetTransform: function () {\n        return resetTransform(element, instance, props);\n      },\n      restoreTransform: function () {\n        return restoreTransform(instance, renderState);\n      },\n      updateLayoutProjection: updateLayoutProjection,\n      updateTreeLayoutProjection: function () {\n        element.layoutTree.forEach(fireResolveRelativeTargetBox);\n        /**\n         * Schedule the projection updates at the end of the current preRender\n         * step. This will ensure that all layout trees will first resolve\n         * relative projection boxes into viewport boxes, and *then*\n         * update projections.\n         */\n\n        sync__default['default'].preRender(updateTreeLayoutProjection, false, true); // sync.postRender(() => element.scheduleUpdateLayoutProjection())\n      },\n      getProjectionParent: function () {\n        if (projectionParent === undefined) {\n          var foundParent = false; // Search backwards through the tree path\n\n          for (var i = element.path.length - 1; i >= 0; i--) {\n            var ancestor = element.path[i];\n\n            if (ancestor.projection.isEnabled) {\n              foundParent = ancestor;\n              break;\n            }\n          }\n\n          projectionParent = foundParent;\n        }\n\n        return projectionParent;\n      },\n      resolveRelativeTargetBox: function () {\n        var relativeParent = element.getProjectionParent();\n        if (!projection.relativeTarget || !relativeParent) return;\n        calcRelativeBox(projection, relativeParent.projection);\n\n        if (isDraggable(relativeParent)) {\n          var target = projection.target;\n          applyBoxTransforms(target, target, relativeParent.getLatestValues());\n        }\n      },\n      shouldResetTransform: function () {\n        return Boolean(props._layoutResetTransform);\n      },\n\n      /**\n       *\n       */\n      pointTo: function (newLead) {\n        leadProjection = newLead.projection;\n        leadLatestValues = newLead.getLatestValues();\n        /**\n         * Subscribe to lead component's layout animations\n         */\n\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        unsubscribeFromLeadVisualElement = popmotion.pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n          var _a;\n\n          if (element.isPresent) {\n            element.presence = Presence.Present;\n          } else {\n            (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n          }\n        }));\n      },\n      // TODO: Clean this up\n      isPresent: true,\n      presence: Presence.Entering\n    });\n\n    return element;\n  };\n};\n\nfunction fireResolveRelativeTargetBox(child) {\n  child.resolveRelativeTargetBox();\n}\n\nfunction fireUpdateLayoutProjection(child) {\n  child.updateLayoutProjection();\n}\n\nvar variantProps = tslib.__spreadArray([\"initial\"], tslib.__read(variantPriorityOrder));\n\nvar numVariantProps = variantProps.length;\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\n\nvar isPositionalKey = function (key) {\n  return positionalKeys.has(key);\n};\n\nvar hasPositionalKey = function (target) {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nvar setAndResetVelocity = function (value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\n\nvar isNumOrPxType = function (v) {\n  return v === styleValueTypes.number || v === styleValueTypes.px;\n};\n\nvar BoundingBoxDimension;\n\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\n\nvar getPosFromMatrix = function (matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\n\nvar getTranslateFromMatrix = function (pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\n\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\n\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.syncRender();\n  return removedTransforms;\n}\n\nvar positionalValues = {\n  // Dimensions\n  width: function (_a) {\n    var x = _a.x;\n    return x.max - x.min;\n  },\n  height: function (_a) {\n    var y = _a.y;\n    return y.max - y.min;\n  },\n  top: function (_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function (_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function (_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function (_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n  var originBbox = visualElement.measureViewportBox();\n  var element = visualElement.getInstance();\n  var elementComputedStyle = getComputedStyle(element);\n  var display = elementComputedStyle.display,\n      top = elementComputedStyle.top,\n      left = elementComputedStyle.left,\n      bottom = elementComputedStyle.bottom,\n      right = elementComputedStyle.right,\n      transform = elementComputedStyle.transform;\n  var originComputedStyle = {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    transform: transform\n  }; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  } // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n\n  visualElement.syncRender();\n  var targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n\n  target = tslib.__assign({}, target);\n  transitionEnd = tslib.__assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var to = target[key];\n    var fromType = findDimensionValueType(from);\n    var toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n\n      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          heyListen.invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          heyListen.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === styleValueTypes.px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var _b = tslib.__read(_a, 2),\n            key = _b[0],\n            value = _b[1];\n\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.syncRender();\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\n\n\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n  var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\nfunction getComputedStyle$1(element) {\n  return window.getComputedStyle(element);\n}\n\nvar htmlConfig = {\n  treeType: \"dom\",\n  readValueFromInstance: function (domElement, key) {\n    if (isTransformProp(key)) {\n      var defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      var computedStyle = getComputedStyle$1(domElement);\n      return (isCSSVariable$1(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n    }\n  },\n  sortNodePosition: function (a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  },\n  getBaseTarget: function (props, key) {\n    var _a;\n\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  },\n  measureViewportBox: function (element, _a) {\n    var transformPagePoint = _a.transformPagePoint;\n    return getBoundingBox(element, transformPagePoint);\n  },\n\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n  resetTransform: function (element, domElement, props) {\n    var transformTemplate = props.transformTemplate;\n    domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\"; // Ensure that whatever happens next, we restore our transform on the next frame\n\n    element.scheduleRender();\n  },\n  restoreTransform: function (instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n  removeValueFromRenderState: function (key, _a) {\n    var vars = _a.vars,\n        style = _a.style;\n    delete vars[key];\n    delete style[key];\n  },\n\n  /**\n   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n   * can be animated by Motion.\n   */\n  makeTargetAnimatable: function (element, _a, _b, isMounted) {\n    var transformValues = _b.transformValues;\n\n    if (isMounted === void 0) {\n      isMounted = true;\n    }\n\n    var transition = _a.transition,\n        transitionEnd = _a.transitionEnd,\n        target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n\n    var origin = getOrigin(target, transition || {}, element);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      var parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n\n    return tslib.__assign({\n      transition: transition,\n      transitionEnd: transitionEnd\n    }, target);\n  },\n  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n  build: function (element, renderState, latestValues, projection, layoutState, options, props) {\n    if (element.isVisible !== undefined) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n    buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform ? buildLayoutProjectionTransformOrigin : undefined);\n  },\n  render: renderHTML\n};\nvar htmlVisualElement = visualElement(htmlConfig);\nvar svgVisualElement = visualElement(tslib.__assign(tslib.__assign({}, htmlConfig), {\n  getBaseTarget: function (props, key) {\n    return props[key];\n  },\n  readValueFromInstance: function (domElement, key) {\n    var _a;\n\n    if (isTransformProp(key)) {\n      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n    }\n\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return domElement.getAttribute(key);\n  },\n  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n  build: function (_element, renderState, latestValues, projection, layoutState, options, props) {\n    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n    buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform ? buildLayoutProjectionTransformOrigin : undefined);\n  },\n  render: renderSVG\n}));\n\nvar createDomVisualElement = function (Component, options) {\n  return isSVGComponent(Component) ? svgVisualElement(options, {\n    enableHardwareAcceleration: false\n  }) : htmlVisualElement(options, {\n    enableHardwareAcceleration: true\n  });\n};\n\nvar featureBundle = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, animations), gestureAnimations), drag), layoutAnimations);\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\n\n\nvar motion = /*@__PURE__*/createMotionProxy(function (Component, config) {\n  return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement);\n});\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don't\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from \"framer-motion\"\n *\n * const motion = {\n *   div: createDomMotionComponent('div')\n * }\n * ```\n *\n * @public\n */\n\nfunction createDomMotionComponent(key) {\n  return createMotionComponent(createDomMotionConfig(key, {\n    forwardMotionProps: false\n  }, featureBundle, createDomVisualElement));\n}\n/**\n * @public\n */\n\n\nvar m = createMotionProxy(createDomMotionConfig);\n\nfunction useForceUpdate() {\n  var unloadingRef = React.useRef(false);\n\n  var _a = tslib.__read(React.useState(0), 2),\n      forcedRenderCount = _a[0],\n      setForcedRenderCount = _a[1];\n\n  useUnmountEffect(function () {\n    return unloadingRef.current = true;\n  });\n  return React.useCallback(function () {\n    !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);\n  }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\n\nfunction getPresenceId() {\n  var id = presenceId;\n  presenceId++;\n  return id;\n}\n\nvar PresenceChild = function (_a) {\n  var children = _a.children,\n      initial = _a.initial,\n      isPresent = _a.isPresent,\n      onExitComplete = _a.onExitComplete,\n      custom = _a.custom,\n      presenceAffectsLayout = _a.presenceAffectsLayout;\n  var presenceChildren = useConstant(newChildrenMap);\n  var id = useConstant(getPresenceId);\n  var context = React.useMemo(function () {\n    return {\n      id: id,\n      initial: initial,\n      isPresent: isPresent,\n      custom: custom,\n      onExitComplete: function (childId) {\n        presenceChildren.set(childId, true);\n        var allComplete = true;\n        presenceChildren.forEach(function (isComplete) {\n          if (!isComplete) allComplete = false;\n        });\n        allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n      },\n      register: function (childId) {\n        presenceChildren.set(childId, false);\n        return function () {\n          return presenceChildren.delete(childId);\n        };\n      }\n    };\n  },\n  /**\n   * If the presence of a child affects the layout of the components around it,\n   * we want to make a new context value to ensure they get re-rendered\n   * so they can detect that layout change.\n   */\n  presenceAffectsLayout ? undefined : [isPresent]);\n  React.useMemo(function () {\n    presenceChildren.forEach(function (_, key) {\n      return presenceChildren.set(key, false);\n    });\n  }, [isPresent]);\n  /**\n   * If there's no `motion` components to fire exit animations, we want to remove this\n   * component immediately.\n   */\n\n  React__namespace.useEffect(function () {\n    !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n  }, [isPresent]);\n  return React__namespace.createElement(PresenceContext.Provider, {\n    value: context\n  }, children);\n};\n\nfunction newChildrenMap() {\n  return new Map();\n}\n\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\n\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n\n    if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n      if (seenChildren.has(key)) {\n        console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n      }\n\n      seenChildren.add(key);\n    }\n\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  React.Children.forEach(children, function (child) {\n    if (React.isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\n\n\nvar AnimatePresence = function (_a) {\n  var children = _a.children,\n      custom = _a.custom,\n      _b = _a.initial,\n      initial = _b === void 0 ? true : _b,\n      onExitComplete = _a.onExitComplete,\n      exitBeforeEnter = _a.exitBeforeEnter,\n      _c = _a.presenceAffectsLayout,\n      presenceAffectsLayout = _c === void 0 ? true : _c; // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  var forceRender = useForceUpdate();\n  var layoutContext = React.useContext(SharedLayoutContext);\n\n  if (isSharedLayout(layoutContext)) {\n    forceRender = layoutContext.forceUpdate;\n  }\n\n  var isInitialRender = React.useRef(true); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children); // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = React.useRef(filteredChildren); // A lookup table to quickly reference components by key\n\n  var allChildren = React.useRef(new Map()).current; // A living record of all currently exiting components.\n\n  var exiting = React.useRef(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren); // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return React__namespace.createElement(React__namespace.Fragment, null, filteredChildren.map(function (child) {\n      return React__namespace.createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false,\n        presenceAffectsLayout: presenceAffectsLayout\n      }, child);\n    }));\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  var childrenToRender = tslib.__spreadArray([], tslib.__read(filteredChildren)); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting.delete(key);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n\n    var onExit = function () {\n      allChildren.delete(key);\n      exiting.delete(key); // Remove this child from the present children\n\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1); // Defer re-rendering until all exiting children have indeed left\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n\n    childrenToRender.splice(insertionIndex, 0, React__namespace.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child));\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : React__namespace.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child);\n  });\n  presentChildren.current = childrenToRender;\n\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n\n  return React__namespace.createElement(React__namespace.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return React.cloneElement(child);\n  }));\n};\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\n\n\nfunction animate(from, to, transition) {\n  if (transition === void 0) {\n    transition = {};\n  }\n\n  var value = isMotionValue(from) ? from : motionValue(from);\n  startAnimation(\"\", value, to, transition);\n  return {\n    stop: function () {\n      return value.stop();\n    }\n  };\n}\n\nfunction createCrossfader() {\n  /**\n   * The current state of the crossfade as a value between 0 and 1\n   */\n  var progress = motionValue(1);\n  var options = {\n    lead: undefined,\n    follow: undefined,\n    crossfadeOpacity: false,\n    preserveFollowOpacity: false\n  };\n\n  var prevOptions = tslib.__assign({}, options);\n\n  var leadState = {};\n  var followState = {};\n  /**\n   *\n   */\n\n  var isActive = false;\n  /**\n   *\n   */\n\n  var finalCrossfadeFrame = null;\n  /**\n   * Framestamp of the last frame we updated values at.\n   */\n\n  var prevUpdate = 0;\n\n  function startCrossfadeAnimation(target, transition) {\n    var lead = options.lead,\n        follow = options.follow;\n    isActive = true;\n    finalCrossfadeFrame = null;\n    var hasUpdated = false;\n\n    var onUpdate = function () {\n      hasUpdated = true;\n      lead && lead.scheduleRender();\n      follow && follow.scheduleRender();\n    };\n\n    var onComplete = function () {\n      isActive = false;\n      /**\n       * If the crossfade animation is no longer active, flag a frame\n       * that we're still allowed to crossfade\n       */\n\n      finalCrossfadeFrame = sync.getFrameData().timestamp;\n    };\n\n    transition = transition && getValueTransition(transition, \"crossfade\");\n    return animate(progress, target, tslib.__assign(tslib.__assign({}, transition), {\n      onUpdate: onUpdate,\n      onComplete: function () {\n        if (!hasUpdated) {\n          progress.set(target);\n          /**\n           * If we never ran an update, for instance if this was an instant transition, fire a\n           * simulated final frame to ensure the crossfade gets applied correctly.\n           */\n\n          sync__default['default'].read(onComplete);\n        } else {\n          onComplete();\n        }\n\n        onUpdate();\n      }\n    }));\n  }\n\n  function updateCrossfade() {\n    var _a, _b;\n    /**\n     * We only want to compute the crossfade once per frame, so we\n     * compare the previous update framestamp with the current frame\n     * and early return if they're the same.\n     */\n\n\n    var timestamp = sync.getFrameData().timestamp;\n    var lead = options.lead,\n        follow = options.follow;\n    if (timestamp === prevUpdate || !lead) return;\n    prevUpdate = timestamp;\n    /**\n     * Merge each component's latest values into our crossfaded state\n     * before crossfading.\n     */\n\n    var latestLeadValues = lead.getLatestValues();\n    Object.assign(leadState, latestLeadValues);\n    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;\n    Object.assign(followState, latestFollowValues);\n    var p = progress.get();\n    /**\n     * Crossfade the opacity between the two components. This will result\n     * in a different opacity for each component.\n     */\n\n    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n\n    if (options.crossfadeOpacity && follow) {\n      leadState.opacity = popmotion.mix(\n      /**\n       * If the follow child has been completely hidden we animate\n       * this opacity from its previous opacity, but otherwise from completely transparent.\n       */\n      follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : popmotion.mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n    } else if (!follow) {\n      leadState.opacity = popmotion.mix(followTargetOpacity, leadTargetOpacity, p);\n    }\n\n    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n  }\n\n  return {\n    isActive: function () {\n      return leadState && (isActive || sync.getFrameData().timestamp === finalCrossfadeFrame);\n    },\n    fromLead: function (transition) {\n      return startCrossfadeAnimation(0, transition);\n    },\n    toLead: function (transition) {\n      var initialProgress = 0;\n\n      if (!options.prevValues && !options.follow) {\n        /**\n         * If we're not coming from anywhere, start at the end of the animation.\n         */\n        initialProgress = 1;\n      } else if (prevOptions.lead === options.follow && prevOptions.follow === options.lead) {\n        /**\n         * If we're swapping follow/lead we can reverse the progress\n         */\n        initialProgress = 1 - progress.get();\n      }\n\n      progress.set(initialProgress);\n      return startCrossfadeAnimation(1, transition);\n    },\n    reset: function () {\n      return progress.set(1);\n    },\n    stop: function () {\n      return progress.stop();\n    },\n    getCrossfadeState: function (element) {\n      updateCrossfade();\n\n      if (element === options.lead) {\n        return leadState;\n      } else if (element === options.follow) {\n        return followState;\n      }\n    },\n    setOptions: function (newOptions) {\n      prevOptions = options;\n      options = newOptions;\n      leadState = {};\n      followState = {};\n    },\n    getLatestValues: function () {\n      return leadState;\n    }\n  };\n}\n\nvar easeCrossfadeIn = compress(0, 0.5, popmotion.circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, popmotion.linear);\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(popmotion.progress(min, max, p));\n  };\n}\n\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\n\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n  /**\n   * Mix border radius\n   */\n  for (var i = 0; i < numBorders; i++) {\n    var borderLabel = \"border\" + borders[i] + \"Radius\";\n    var followRadius = getRadius(latestFollowValues, borderLabel);\n    var leadRadius = getRadius(latestLeadValues, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    /**\n     * Currently we're only crossfading between numerical border radius.\n     * It would be possible to crossfade between percentages for a little\n     * extra bundle size.\n     */\n\n    if (typeof followRadius === \"number\" && typeof leadRadius === \"number\") {\n      var radius = Math.max(popmotion.mix(followRadius, leadRadius, p), 0);\n      leadState[borderLabel] = followState[borderLabel] = radius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n\n\n  if (latestFollowValues.rotate || latestLeadValues.rotate) {\n    var rotate = popmotion.mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n    leadState.rotate = followState.rotate = rotate;\n  }\n  /**\n   * We only want to mix the background color if there's a follow element\n   * that we're not crossfading opacity between. For instance with switch\n   * AnimateSharedLayout animations, this helps the illusion of a continuous\n   * element being animated but also cuts down on the number of paints triggered\n   * for elements where opacity is doing that work for us.\n   */\n\n\n  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {\n    /**\n     * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n     * We could probably create a mixer that runs at the start of the animation but\n     * the idea behind the crossfader is that it runs dynamically between two potentially\n     * changing targets (ie opacity or borderRadius may be animating independently via variants)\n     */\n    leadState.backgroundColor = followState.backgroundColor = popmotion.mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n  }\n}\n\nfunction getRadius(values, radiusName) {\n  var _a;\n\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nfunction layoutStack() {\n  var stack = new Set();\n  var state = {\n    leadIsExiting: false\n  };\n\n  var prevState = tslib.__assign({}, state);\n\n  var prevValues;\n  var prevViewportBox;\n  var prevDragCursor;\n  var crossfader = createCrossfader();\n  var needsCrossfadeAnimation = false;\n\n  function getFollowViewportBox() {\n    return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n  }\n\n  function getFollowLayout() {\n    var _a;\n\n    return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n  }\n\n  return {\n    add: function (element) {\n      element.setCrossfader(crossfader);\n      stack.add(element);\n      /**\n       * Hydrate new element with previous drag position if we have one\n       */\n\n      if (prevDragCursor) element.prevDragCursor = prevDragCursor;\n      if (!state.lead) state.lead = element;\n    },\n    remove: function (element) {\n      stack.delete(element);\n    },\n    getLead: function () {\n      return state.lead;\n    },\n    updateSnapshot: function () {\n      if (!state.lead) return;\n      prevValues = crossfader.isActive() ? crossfader.getLatestValues() : state.lead.getLatestValues();\n      prevViewportBox = state.lead.prevViewportBox;\n      var dragControls = elementDragControls.get(state.lead);\n\n      if (dragControls && dragControls.isDragging) {\n        prevDragCursor = dragControls.cursorProgress;\n      }\n    },\n    clearSnapshot: function () {\n      prevDragCursor = prevViewportBox = undefined;\n    },\n    updateLeadAndFollow: function () {\n      var _a;\n\n      prevState = tslib.__assign({}, state);\n      var lead;\n      var follow;\n      var order = Array.from(stack);\n\n      for (var i = order.length; i--; i >= 0) {\n        var element = order[i];\n        if (lead) follow !== null && follow !== void 0 ? follow : follow = element;\n        lead !== null && lead !== void 0 ? lead : lead = element;\n        if (lead && follow) break;\n      }\n\n      state.lead = lead;\n      state.follow = follow;\n      state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n      crossfader.setOptions({\n        lead: lead,\n        follow: follow,\n        prevValues: prevValues,\n        crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot)\n      });\n\n      if ( // Don't crossfade if we've just animated back from lead and switched the\n      // old follow to the new lead.\n      state.lead !== prevState.follow && (prevState.lead !== state.lead || prevState.leadIsExiting !== state.leadIsExiting)) {\n        needsCrossfadeAnimation = true;\n      }\n    },\n    animate: function (child, shouldCrossfade) {\n      var _a;\n\n      if (shouldCrossfade === void 0) {\n        shouldCrossfade = false;\n      }\n\n      if (child === state.lead) {\n        if (shouldCrossfade) {\n          /**\n           * Point a lead to itself in case it was previously pointing\n           * to a different visual element\n           */\n          child.pointTo(state.lead);\n        } else {\n          child.setVisibility(true);\n        }\n\n        var config = {};\n        var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n\n        if (prevParent) {\n          /**\n           * We'll use this to determine if the element or its layoutId has been reparented.\n           */\n          config.prevParent = prevParent;\n        }\n\n        if (child.presence === Presence.Entering) {\n          config.originBox = getFollowViewportBox();\n        } else if (child.presence === Presence.Exiting) {\n          config.targetBox = getFollowLayout();\n        }\n\n        if (needsCrossfadeAnimation) {\n          needsCrossfadeAnimation = false;\n          var transition = child.getDefaultTransition();\n          child.presence === Presence.Entering ? crossfader.toLead(transition) : crossfader.fromLead(transition);\n        }\n\n        child.notifyLayoutReady(config);\n      } else {\n        if (shouldCrossfade) {\n          state.lead && child.pointTo(state.lead);\n        } else {\n          child.setVisibility(false);\n        }\n      }\n    }\n  };\n}\n\nfunction resetRotate(child) {\n  // If there's no detected rotation values, we can early return without a forced render.\n  var hasRotate = false; // Keep a record of all the values we've reset\n\n  var resetValues = {}; // Check the rotate value of all axes and reset to 0\n\n  for (var i = 0; i < transformAxes.length; i++) {\n    var axis = transformAxes[i];\n    var key = \"rotate\" + axis; // If this rotation doesn't exist as a motion value, then we don't\n    // need to reset it\n\n    if (!child.hasValue(key) || child.getStaticValue(key) === 0) continue;\n    hasRotate = true; // Record the rotation and then temporarily set it to 0\n\n    resetValues[key] = child.getStaticValue(key);\n    child.setStaticValue(key, 0);\n  } // If there's no rotation values, we don't need to do any more.\n\n\n  if (!hasRotate) return; // Force a render of this element to apply the transform with all rotations\n  // set to 0.\n\n  child.syncRender(); // Put back all the values we reset\n\n  for (var key in resetValues) {\n    child.setStaticValue(key, resetValues[key]);\n  } // Schedule a render for the next frame. This ensures we won't visually\n  // see the element with the reset rotate value applied.\n\n\n  child.scheduleRender();\n}\n/**\n * @public\n */\n\n\nvar AnimateSharedLayout =\n/** @class */\nfunction (_super) {\n  tslib.__extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A list of all the children in the shared layout\n     */\n\n\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n\n    _this.stacks = new Map();\n    /**\n     * Track whether the component has mounted. If it hasn't, the presence of added children\n     * are set to Present, whereas if it has they're considered Entering\n     */\n\n    _this.hasMounted = false;\n    /**\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n     * and schedule one.\n     */\n\n    _this.updateScheduled = false;\n    /**\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n     */\n\n    _this.renderScheduled = false;\n    /**\n     * The methods provided to all children in the shared layout tree.\n     */\n\n    _this.syncContext = tslib.__assign(tslib.__assign({}, createBatcher()), {\n      syncUpdate: function (force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function () {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = tslib.__assign({}, _this.syncContext);\n\n        _this.scheduleUpdate(true);\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      remove: function (child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\n     * Reset update and render scheduled status\n     */\n\n\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\n     * Update presence metadata based on the latest AnimatePresence status.\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n     */\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.updateStacks();\n    /**\n     * Create a handler which we can use to flush the children animations\n     */\n\n    var handler = {\n      layoutReady: function (child) {\n        if (child.getLayoutId() !== undefined) {\n          var stack = _this.getStack(child);\n\n          stack.animate(child, type === \"crossfade\");\n        } else {\n          child.notifyLayoutReady();\n        }\n      },\n      parent: this.context.visualElement\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.clearSnapshot();\n    });\n  };\n\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!(force || !this.updateScheduled)) return;\n    /**\n     * Flag we've scheduled an update\n     */\n\n    this.updateScheduled = true;\n    /**\n     * Write: Reset transforms so bounding boxes can be accurately measured.\n     */\n\n    this.children.forEach(function (child) {\n      resetRotate(child);\n      if (child.shouldResetTransform()) child.resetTransform();\n    });\n    /**\n     * Read: Snapshot children\n     */\n\n    this.children.forEach(snapshotViewportBox);\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     *\n     * TODO: What would be better here is doing a single loop where we\n     * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\n     * Force a rerender by setting state if we aren't already going to render.\n     */\n\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (child) {\n    var id = child.getLayoutId();\n    if (id === undefined) return; // Create stack if it doesn't already exist\n\n    !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n    return this.stacks.get(id);\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return React__namespace.createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n\n  AnimateSharedLayout.contextType = MotionContext;\n  return AnimateSharedLayout;\n}(React__namespace.Component);\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */\n\n\nfunction MotionConfig(_a) {\n  var children = _a.children,\n      config = tslib.__rest(_a, [\"children\"]);\n  /**\n   * Inherit props from any parent MotionConfig components\n   */\n\n\n  config = tslib.__assign(tslib.__assign({}, React.useContext(MotionConfigContext)), config);\n  /**\n   * Don't allow isStatic to change between renders as it affects how many hooks\n   * motion components fire.\n   */\n\n  config.isStatic = useConstant(function () {\n    return config.isStatic;\n  });\n  /**\n   * Creating a new config context object will re-render every `motion` component\n   * every time it renders. So we only want to create a new one sparingly.\n   */\n\n  var transitionDependency = typeof config.transition === \"object\" ? config.transition.toString() : \"\";\n  var context = React.useMemo(function () {\n    return config;\n  }, [transitionDependency, config.transformPagePoint]);\n  return React__namespace.createElement(MotionConfigContext.Provider, {\n    value: context\n  }, children);\n}\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimations } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimations}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimations')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\n\n\nfunction LazyMotion(_a) {\n  var children = _a.children,\n      features = _a.features,\n      _b = _a.strict,\n      strict = _b === void 0 ? false : _b;\n\n  var _c = tslib.__read(React.useState(!isLazyBundle(features)), 2),\n      setIsLoaded = _c[1];\n\n  var loadedRenderer = React.useRef(undefined);\n  /**\n   * If this is a synchronous load, load features immediately\n   */\n\n  if (!isLazyBundle(features)) {\n    var renderer = features.renderer,\n        loadedFeatures = tslib.__rest(features, [\"renderer\"]);\n\n    loadedRenderer.current = renderer;\n    loadFeatures(loadedFeatures);\n  }\n\n  React.useEffect(function () {\n    if (isLazyBundle(features)) {\n      features().then(function (_a) {\n        var renderer = _a.renderer,\n            loadedFeatures = tslib.__rest(_a, [\"renderer\"]);\n\n        loadFeatures(loadedFeatures);\n        loadedRenderer.current = renderer;\n        setIsLoaded(true);\n      });\n    }\n  }, []);\n  return React__namespace.createElement(LazyContext.Provider, {\n    value: {\n      renderer: loadedRenderer.current,\n      strict: strict\n    }\n  }, children);\n}\n\nfunction isLazyBundle(features) {\n  return typeof features === \"function\";\n}\n/**\n * @public\n */\n\n\nvar domAnimation = tslib.__assign(tslib.__assign({\n  renderer: createDomVisualElement\n}, animations), gestureAnimations);\n/**\n * @public\n */\n\n\nvar domMax = tslib.__assign(tslib.__assign(tslib.__assign({}, domAnimation), drag), layoutAnimations);\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\n\n\nfunction useMotionValue(initial) {\n  var value = useConstant(function () {\n    return motionValue(initial);\n  });\n  /**\n   * If this motion value is being used in static mode, like on\n   * the Framer canvas, force components to rerender when the motion\n   * value is updated.\n   */\n\n  var isStatic = React.useContext(MotionConfigContext).isStatic;\n\n  if (isStatic) {\n    var _a = tslib.__read(React.useState(initial), 2),\n        setLatest_1 = _a[1];\n\n    React.useEffect(function () {\n      return value.onChange(setLatest_1);\n    }, []);\n  }\n\n  return value;\n}\n\nfunction useOnChange(value, callback) {\n  React.useEffect(function () {\n    if (isMotionValue(value)) return value.onChange(callback);\n  }, [callback]);\n}\n\nfunction useMultiOnChange(values, handler) {\n  React.useEffect(function () {\n    var subscriptions = values.map(function (value) {\n      return value.onChange(handler);\n    });\n    return function () {\n      return subscriptions.forEach(function (unsubscribe) {\n        return unsubscribe();\n      });\n    };\n  });\n}\n\nfunction useCombineMotionValues(values, combineValues) {\n  /**\n   * Initialise the returned motion value. This remains the same between renders.\n   */\n  var value = useMotionValue(combineValues());\n  /**\n   * Create a function that will update the template motion value with the latest values.\n   * This is pre-bound so whenever a motion value updates it can schedule its\n   * execution in Framesync. If it's already been scheduled it won't be fired twice\n   * in a single frame.\n   */\n\n  var updateValue = function () {\n    return value.set(combineValues());\n  };\n  /**\n   * Synchronously update the motion value with the latest values during the render.\n   * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n   */\n\n\n  updateValue();\n  /**\n   * Subscribe to all motion values found within the template. Whenever any of them change,\n   * schedule an update.\n   */\n\n  useMultiOnChange(values, function () {\n    return sync__default['default'].update(updateValue, false, true);\n  });\n  return value;\n}\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useMotionTemplate(fragments) {\n  var values = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    values[_i - 1] = arguments[_i];\n  }\n  /**\n   * Create a function that will build a string from the latest motion values.\n   */\n\n\n  var numFragments = fragments.length;\n\n  function buildValue() {\n    var output = \"\";\n\n    for (var i = 0; i < numFragments; i++) {\n      output += fragments[i];\n      var value = values[i];\n      if (value) output += values[i].get();\n    }\n\n    return output;\n  }\n\n  return useCombineMotionValues(values, buildValue);\n}\n\nvar isCustomValueType = function (v) {\n  return typeof v === \"object\" && v.mix;\n};\n\nvar getMixer = function (v) {\n  return isCustomValueType(v) ? v.mix : undefined;\n};\n\nfunction transform() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var useImmediate = !Array.isArray(args[0]);\n  var argOffset = useImmediate ? 0 : -1;\n  var inputValue = args[0 + argOffset];\n  var inputRange = args[1 + argOffset];\n  var outputRange = args[2 + argOffset];\n  var options = args[3 + argOffset];\n  var interpolator = popmotion.interpolate(inputRange, outputRange, tslib.__assign({\n    mixer: getMixer(outputRange[0])\n  }, options));\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n  var transformer = typeof inputRangeOrTransformer === \"function\" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);\n  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], function (_a) {\n    var _b = tslib.__read(_a, 1),\n        latest = _b[0];\n\n    return transformer(latest);\n  });\n}\n\nfunction useListTransform(values, transformer) {\n  var latest = useConstant(function () {\n    return [];\n  });\n  return useCombineMotionValues(values, function () {\n    latest.length = 0;\n    var numValues = values.length;\n\n    for (var i = 0; i < numValues; i++) {\n      latest[i] = values[i].get();\n    }\n\n    return transformer(latest);\n  });\n}\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\n\n\nfunction useSpring(source, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var isStatic = React.useContext(MotionConfigContext).isStatic;\n  var activeSpringAnimation = React.useRef(null);\n  var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  React.useMemo(function () {\n    return value.attach(function (v, set) {\n      /**\n       * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n       * at that level, but this will work for now\n       */\n      if (isStatic) return set(v);\n\n      if (activeSpringAnimation.current) {\n        activeSpringAnimation.current.stop();\n      }\n\n      activeSpringAnimation.current = popmotion.animate(tslib.__assign(tslib.__assign({\n        from: value.get(),\n        to: v,\n        velocity: value.getVelocity()\n      }, config), {\n        onUpdate: set\n      }));\n      return value.get();\n    });\n  }, Object.values(config));\n  useOnChange(source, function (v) {\n    return value.set(parseFloat(v));\n  });\n  return value;\n}\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */\n\n\nfunction useVelocity(value) {\n  var velocity = useMotionValue(value.getVelocity());\n  React.useEffect(function () {\n    return value.velocityUpdateSubscribers.add(function (newVelocity) {\n      velocity.set(newVelocity);\n    });\n  }, [value]);\n  return velocity;\n}\n\nfunction createScrollMotionValues() {\n  return {\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0)\n  };\n}\n\nfunction setProgress(offset, maxOffset, value) {\n  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\n\nfunction createScrollUpdater(values, getOffsets) {\n  var update = function () {\n    var _a = getOffsets(),\n        xOffset = _a.xOffset,\n        yOffset = _a.yOffset,\n        xMaxOffset = _a.xMaxOffset,\n        yMaxOffset = _a.yMaxOffset; // Set absolute positions\n\n\n    values.scrollX.set(xOffset);\n    values.scrollY.set(yOffset); // Set 0-1 progress\n\n    setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n    setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n  };\n\n  update();\n  return update;\n}\n\nvar getElementScrollOffsets = function (element) {\n  return function () {\n    return {\n      xOffset: element.scrollLeft,\n      yOffset: element.scrollTop,\n      xMaxOffset: element.scrollWidth - element.offsetWidth,\n      yMaxOffset: element.scrollHeight - element.offsetHeight\n    };\n  };\n};\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * This element must be set to `overflow: scroll` on either or both axes to report scroll offset.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useElementScroll(ref) {\n  var values = useConstant(createScrollMotionValues);\n  useIsomorphicLayoutEffect(function () {\n    var element = ref.current;\n    heyListen.invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n    if (!element) return;\n    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n    var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, {\n      passive: true\n    });\n    var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n    return function () {\n      scrollListener && scrollListener();\n      resizeListener && resizeListener();\n    };\n  }, []);\n  return values;\n}\n\nvar viewportScrollValues;\n\nfunction getViewportScrollOffsets() {\n  return {\n    xOffset: window.pageXOffset,\n    yOffset: window.pageYOffset,\n    xMaxOffset: document.body.clientWidth - window.innerWidth,\n    yMaxOffset: document.body.clientHeight - window.innerHeight\n  };\n}\n\nvar hasListeners = false;\n\nfunction addEventListeners() {\n  hasListeners = true;\n  if (typeof window === \"undefined\") return;\n  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n  addDomEvent(window, \"scroll\", updateScrollValues, {\n    passive: true\n  });\n  addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * **Warning:** Setting `body` or `html` to `height: 100%` or similar will break the `Progress`\n * values as this breaks the browser's capability to accurately measure the page length.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useViewportScroll() {\n  /**\n   * Lazy-initialise the viewport scroll values\n   */\n  if (!viewportScrollValues) {\n    viewportScrollValues = createScrollMotionValues();\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    !hasListeners && addEventListeners();\n  }, []);\n  return viewportScrollValues;\n} // Does this device prefer reduced motion? Returns `null` server-side.\n\n\nvar prefersReducedMotion;\n\nfunction initPrefersReducedMotion() {\n  prefersReducedMotion = motionValue(null);\n  if (typeof window === \"undefined\") return;\n\n  if (window.matchMedia) {\n    var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n\n    var setReducedMotionPreferences = function () {\n      return prefersReducedMotion.set(motionMediaQuery_1.matches);\n    };\n\n    motionMediaQuery_1.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.set(false);\n  }\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\n\n\nfunction useReducedMotion() {\n  /**\n   * Lazy initialisation of prefersReducedMotion\n   */\n  !prefersReducedMotion && initPrefersReducedMotion();\n\n  var _a = tslib.__read(React.useState(prefersReducedMotion.get()), 2),\n      shouldReduceMotion = _a[0],\n      setShouldReduceMotion = _a[1];\n\n  useOnChange(prefersReducedMotion, setShouldReduceMotion);\n  return shouldReduceMotion;\n}\n/**\n * @public\n */\n\n\nfunction animationControls() {\n  /**\n   * Track whether the host component has mounted.\n   */\n  var hasMounted = false;\n  /**\n   * Pending animations that are started before a component is mounted.\n   * TODO: Remove this as animations should only run in effects\n   */\n\n  var pendingAnimations = [];\n  /**\n   * A collection of linked component animation controls.\n   */\n\n  var subscribers = new Set();\n  var controls = {\n    subscribe: function (visualElement) {\n      subscribers.add(visualElement);\n      return function () {\n        return void subscribers.delete(visualElement);\n      };\n    },\n    start: function (definition, transitionOverride) {\n      /**\n       * TODO: We only perform this hasMounted check because in Framer we used to\n       * encourage the ability to start an animation within the render phase. This\n       * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n       * we can ditch this.\n       */\n      if (hasMounted) {\n        var animations_1 = [];\n        subscribers.forEach(function (visualElement) {\n          animations_1.push(animateVisualElement(visualElement, definition, {\n            transitionOverride: transitionOverride\n          }));\n        });\n        return Promise.all(animations_1);\n      } else {\n        return new Promise(function (resolve) {\n          pendingAnimations.push({\n            animation: [definition, transitionOverride],\n            resolve: resolve\n          });\n        });\n      }\n    },\n    set: function (definition) {\n      heyListen.invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(function (visualElement) {\n        setValues(visualElement, definition);\n      });\n    },\n    stop: function () {\n      subscribers.forEach(function (visualElement) {\n        stopAnimation(visualElement);\n      });\n    },\n    mount: function () {\n      hasMounted = true;\n      pendingAnimations.forEach(function (_a) {\n        var animation = _a.animation,\n            resolve = _a.resolve;\n        controls.start.apply(controls, tslib.__spreadArray([], tslib.__read(animation))).then(resolve);\n      });\n      return function () {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\n\n\nfunction useAnimation() {\n  var controls = useConstant(animationControls);\n  React.useEffect(controls.mount, []);\n  return controls;\n}\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\n\n\nfunction useCycle() {\n  var items = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    items[_i] = arguments[_i];\n  }\n\n  var index = React.useRef(0);\n\n  var _a = tslib.__read(React.useState(items[index.current]), 2),\n      item = _a[0],\n      setItem = _a[1];\n\n  return [item, function (next) {\n    index.current = typeof next !== \"number\" ? popmotion.wrap(0, items.length, index.current + 1) : next;\n    setItem(items[index.current]);\n  }];\n}\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nvar DragControls =\n/** @class */\nfunction () {\n  function DragControls() {\n    this.componentControls = new Set();\n  }\n  /**\n   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n   *\n   * @internal\n   */\n\n\n  DragControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\n   * Start a drag gesture on every `motion` component that has this set of drag controls\n   * passed into it via the `dragControls` prop.\n   *\n   * ```jsx\n   * dragControls.start(e, {\n   *   snapToCursor: true\n   * })\n   * ```\n   *\n   * @param event - PointerEvent\n   * @param options - Options\n   *\n   * @public\n   */\n\n\n  DragControls.prototype.start = function (event, options) {\n    this.componentControls.forEach(function (controls) {\n      controls.start(event.nativeEvent || event, options);\n    });\n  };\n\n  DragControls.prototype.updateConstraints = function (flush) {\n    if (flush === void 0) {\n      flush = true;\n    }\n\n    this.componentControls.forEach(function (controls) {\n      controls.updateConstraints();\n    });\n    flush && flushLayout();\n  };\n\n  return DragControls;\n}();\n\nvar createDragControls = function () {\n  return new DragControls();\n};\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nfunction useDragControls() {\n  return useConstant(createDragControls);\n}\n\nvar createObject = function () {\n  return {};\n};\n\nvar stateVisualElement = visualElement({\n  build: function () {},\n  measureViewportBox: axisBox,\n  resetTransform: function () {},\n  restoreTransform: function () {},\n  removeValueFromRenderState: function () {},\n  render: function () {},\n  scrapeMotionValuesFromProps: createObject,\n  readValueFromInstance: function (_state, key, options) {\n    return options.initialState[key] || 0;\n  },\n  makeTargetAnimatable: function (element, _a) {\n    var transition = _a.transition,\n        transitionEnd = _a.transitionEnd,\n        target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n\n    var origin = getOrigin(target, transition || {}, element);\n    checkTargetForNewValues(element, target, origin);\n    return tslib.__assign({\n      transition: transition,\n      transitionEnd: transitionEnd\n    }, target);\n  }\n});\nvar useVisualState = makeUseVisualState({\n  scrapeMotionValuesFromProps: createObject,\n  createRenderState: createObject\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\n\nfunction useAnimatedState(initialState) {\n  var _a = tslib.__read(React.useState(initialState), 2),\n      animationState = _a[0],\n      setAnimationState = _a[1];\n\n  var visualState = useVisualState({}, false);\n  var element = useConstant(function () {\n    return stateVisualElement({\n      props: {},\n      visualState: visualState\n    }, {\n      initialState: initialState\n    });\n  });\n  React.useEffect(function () {\n    element.mount({});\n    return element.unmount();\n  }, []);\n  React.useEffect(function () {\n    element.setProps({\n      onUpdate: function (v) {\n        return setAnimationState(tslib.__assign({}, v));\n      }\n    });\n  });\n  var startAnimation = useConstant(function () {\n    return function (animationDefinition) {\n      return animateVisualElement(element, animationDefinition);\n    };\n  });\n  return [animationState, startAnimation];\n} // Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\n\n\nvar maxScale = 100000;\n\nvar invertScale = function (scale) {\n  return scale > 0.001 ? 1 / scale : maxScale;\n};\n\nvar hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @deprecated\n * @internal\n */\n\nfunction useInvertedScale(scale) {\n  var parentScaleX = useMotionValue(1);\n  var parentScaleY = useMotionValue(1);\n  var visualElement = useVisualElementContext();\n  heyListen.invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n  heyListen.warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n  hasWarned = true;\n\n  if (scale) {\n    parentScaleX = scale.scaleX || parentScaleX;\n    parentScaleY = scale.scaleY || parentScaleY;\n  } else if (visualElement) {\n    parentScaleX = visualElement.getValue(\"scaleX\", 1);\n    parentScaleY = visualElement.getValue(\"scaleY\", 1);\n  }\n\n  var scaleX = useTransform(parentScaleX, invertScale);\n  var scaleY = useTransform(parentScaleY, invertScale);\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\n\nexports.AnimatePresence = AnimatePresence;\nexports.AnimateSharedLayout = AnimateSharedLayout;\nexports.DragControls = DragControls;\nexports.FlatTree = FlatTree;\nexports.FramerTreeLayoutContext = FramerTreeLayoutContext;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyMotion = LazyMotion;\nexports.MotionConfig = MotionConfig;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.SharedLayoutContext = SharedLayoutContext;\nexports.addScaleCorrection = addScaleCorrection;\nexports.animate = animate;\nexports.animateVisualElement = animateVisualElement;\nexports.animationControls = animationControls;\nexports.batchLayout = batchLayout;\nexports.createBatcher = createBatcher;\nexports.createCrossfader = createCrossfader;\nexports.createDomMotionComponent = createDomMotionComponent;\nexports.createMotionComponent = createMotionComponent;\nexports.domAnimation = domAnimation;\nexports.domMax = domMax;\nexports.flushLayout = flushLayout;\nexports.isValidMotionProp = isValidMotionProp;\nexports.m = m;\nexports.motion = motion;\nexports.motionValue = motionValue;\nexports.resolveMotionValue = resolveMotionValue;\nexports.snapshotViewportBox = snapshotViewportBox;\nexports.transform = transform;\nexports.useAnimation = useAnimation;\nexports.useCycle = useCycle;\nexports.useDeprecatedAnimatedState = useAnimatedState;\nexports.useDeprecatedInvertedScale = useInvertedScale;\nexports.useDomEvent = useDomEvent;\nexports.useDragControls = useDragControls;\nexports.useElementScroll = useElementScroll;\nexports.useIsPresent = useIsPresent;\nexports.useMotionTemplate = useMotionTemplate;\nexports.useMotionValue = useMotionValue;\nexports.usePresence = usePresence;\nexports.useReducedMotion = useReducedMotion;\nexports.useSpring = useSpring;\nexports.useTransform = useTransform;\nexports.useVelocity = useVelocity;\nexports.useViewportScroll = useViewportScroll;\nexports.visualElement = visualElement;","map":{"version":3,"sources":["C:/Users/nivin/Desktop/Projects/React/WITblog/MERNstackProj/client/node_modules/framer-motion/dist/framer-motion.cjs.js"],"names":["Object","defineProperty","exports","value","tslib","require","React","heyListen","styleValueTypes","popmotion","sync","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","React__namespace","React__default","sync__default","createDefinition","propNames","isEnabled","props","some","name","featureDefinitions","measureLayout","animation","exit","drag","focus","hover","tap","pan","layoutAnimation","loadFeatures","features","key","Component","LazyContext","createContext","strict","featureNames","numFeatures","length","useFeatures","visualElement","preloadedFeatures","lazyContext","useContext","process","env","NODE_ENV","invariant","i","name_1","_a","push","createElement","__assign","MotionConfigContext","transformPagePoint","p","isStatic","MotionContext","useVisualElementContext","PresenceContext","useConstant","init","ref","useRef","current","usePresence","context","isPresent","onExitComplete","register","id","useUniqueId","useEffect","safeToRemove","useIsPresent","counter","incrementId","LayoutGroupContext","isBrowser","window","useIsomorphicLayoutEffect","useLayoutEffect","useLayoutId","layoutId","layoutGroupId","undefined","useVisualElement","visualState","createVisualElement","config","parent","presenceContext","visualElementRef","renderer","presenceId","blockInitialAnimation","initial","setProps","isPresenceRoot","syncRender","animationState","animateChanges","notifyUnmount","isRefObject","prototype","hasOwnProperty","call","useMotionRef","externalRef","useCallback","instance","mount","unmount","isVariantLabels","v","Array","isArray","isVariantLabel","getCurrent","forEachValue","getVelocity$1","velocity","getVelocity","resolveVariantFromProps","definition","custom","currentValues","currentVelocity","variants","resolveVariant","getProps","checkIfControllingVariants","animate","start","whileHover","whileDrag","whileTap","whileFocus","checkIfVariantNode","Boolean","getCurrentTreeVariants","inherit","useCreateMotionContext","useMemo","variantLabelsAsDependency","prop","join","createMotionComponent","useRender","useVisualState","MotionComponent","Fragment","Provider","forwardRef","createMotionProxy","createConfig","customMotionComponentConfig","componentCache","Map","Proxy","_target","has","set","lowercaseSVGElements","isSVGComponent","includes","indexOf","test","valueScaleCorrection","addScaleCorrection","correctors","transformAxes","order","transformProps","operationKey","axesKey","sortTransformProps","a","b","transformPropSet","Set","isTransformProp","transformOriginProps","isTransformOriginProp","isForcedMotionValue","layout","isMotionValue","translateAlias","x","y","z","transformPerspective","buildTransform","_b","transformIsDefault","transformTemplate","transform","transformKeys","_c","enableHardwareAcceleration","_d","allowTransformNone","transformString","sort","transformHasZ","numTransformKeys","trim","buildTransformOrigin","originX","originY","originZ","isCSSVariable$1","startsWith","getValueAsType","type","int","number","Math","round","numberValueTypes","borderWidth","px","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","top","right","bottom","left","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","degrees","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","distance","translateX","translateY","translateZ","perspective","opacity","alpha","progressPercentage","zIndex","fillOpacity","strokeOpacity","numOctaves","buildHTMLStyles","state","latestValues","projection","layoutState","options","buildProjectionTransform","buildProjectionTransformOrigin","style","vars","transformOrigin","hasTransform","hasTransformOrigin","transformIsNone","valueType","valueAsType","default","isHydrated","correctedValue","applyTo","num","deltaFinal","treeScale","createHtmlRenderState","copyRawValuesOnly","target","source","useInitialMotionValues","useStyle","styleProp","assign","transformValues","useHTMLProps","htmlProps","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","validMotionProps","isValidMotionProp","shouldForward","emotionIsPropValid_1","filterProps","isDom","forwardMotionProps","filteredProps","calcOrigin$1","origin","offset","calcSVGTransformOrigin","dimensions","pxOriginX","pxOriginY","progressToPixels","progress","dashKeys","array","camelKeys","buildSVGPath","attrs","totalLength","spacing","useDashCase","pathLength","pathSpacing","buildSVGAttrs","attrX","attrY","pathOffset","latest","__rest","totalPathLength","createSvgRenderState","useSVGProps","visualProps","rawStyles","createUseRender","useVisualProps","elementProps","CAMEL_CASE_PATTERN","REPLACE_TEMPLATE","camelToDash","str","replace","toLowerCase","renderHTML","element","setProperty","camelCaseAttributes","renderSVG","renderState","setAttribute","scrapeMotionValuesFromProps$1","newValues","scrapeMotionValuesFromProps","targetKey","toUpperCase","isAnimationControls","isKeyframesTarget","isCustomValue","mix","toValue","resolveFinalValueInKeyframes","resolveMotionValue","unwrappedValue","makeState","createRenderState","onMount","makeLatestValues","makeUseVisualState","scrapeMotionValues","values","motionValues","isControllingVariants","isVariantNode","variantToSet","list","resolved","transitionEnd","transition","svgMotionConfig","getBBox","getBoundingClientRect","isPath","getTotalLength","tagName","htmlMotionConfig","createDomMotionConfig","baseConfig","AnimationType","addDomEvent","eventName","handler","addEventListener","removeEventListener","useDomEvent","useFocusGesture","onFocus","setActive","Focus","onBlur","isMouseEvent","event","PointerEvent","pointerType","MouseEvent","isTouchEvent","hasTouches","touches","filterPrimaryPointer","eventHandler","isPrimaryPointer","button","defaultPagePoint","pageX","pageY","pointFromTouch","pointType","primaryTouch","changedTouches","point","pointFromMouse","extractEventInfo","getViewportPointFromEvent","wrapHandler","shouldFilterPrimaryPointer","listener","supportsPointerEvents","onpointerdown","supportsTouchEvents","ontouchstart","supportsMouseEvents","onmousedown","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","addPointerEvent","usePointerEvent","createLock","lock","openLock","globalHorizontalLock","globalVerticalLock","getGlobalLock","openHorizontal_1","openVertical_1","isDragActive","openGestureLock","createHoverEvent","isActive","callback","info","Hover","useHoverGesture","onHoverStart","onHoverEnd","isNodeOrChild","child","parentElement","useUnmountEffect","useTapGesture","onTap","onTapStart","onTapCancel","hasPressListeners","isPressing","cancelPointerEndListeners","removePointerEndListener","checkPointerEnd","Tap","onPointerUp","getInstance","onPointerCancel","onPointerDown","pipe","makeRenderlessComponent","hook","gestureAnimations","shallowCompare","next","prev","prevLength","secondsToMilliseconds","seconds","easingLookup","linear","easeIn","easeInOut","easeOut","circIn","circInOut","circOut","backIn","backInOut","backOut","anticipate","bounceIn","bounceInOut","bounceOut","easingDefinitionToFunction","__read","x1","y1","x2","y2","cubicBezier","isEasingArray","ease","isAnimatable","complex","underDampedSpring","stiffness","damping","restDelta","restSpeed","criticallyDampedSpring","to","sqrt","linearTween","duration","keyframes","defaultTransitions","backgroundColor","color","getDefaultTransition","valueKey","transitionFactory","defaultValueTypes","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","filter","WebkitFilter","getDefaultValueType","getAnimatableNone","defaultValueType","isTransitionDefined","when","delay","delayChildren","staggerChildren","staggerDirection","repeat","repeatType","repeatDelay","from","legacyRepeatWarning","convertTransitionToAnimationOptions","times","yoyo","flip","loop","map","warning","getDelayFromTransition","valueTransition","getValueTransition","hydrateKeyframes","__spreadArray","getPopmotionAnimationOptions","getAnimation","onComplete","isTargetAnimatable","isZero","getZeroUnit","isOriginAnimatable","onUpdate","inertia","stop","parseFloat","potentialUnitType","startAnimation","delayTimer","controls","setTimeout","clearTimeout","isNumericalString","addUniqueItem","arr","item","removeItem","index","splice","SubscriptionManager","subscriptions","add","_this","notify","c","numSubscriptions","getSize","clear","isFloat","isNaN","MotionValue","timeDelta","lastUpdated","updateSubscribers","velocityUpdateSubscribers","renderSubscribers","canTrackVelocity","updateAndNotify","render","getFrameData","delta","timestamp","postRender","scheduleVelocityCheck","velocityCheck","hasAnimated","onChange","subscription","clearListeners","onRenderRequest","attach","passiveEffect","getPrevious","velocityPerSecond","Promise","resolve","stopAnimation","then","clearAnimation","isAnimating","destroy","motionValue","testValueType","auto","parse","dimensionValueTypes","percent","vw","vh","findDimensionValueType","find","valueTypes","findValueType","setMotionValue","hasValue","getValue","addValue","setTarget","makeTargetAnimatable","setVariants","variantLabels","reversedLabels","reverse","variant","getVariant","variantChildren","setValues","checkTargetForNewValues","newValueKeys","numNewValues","targetValue","readValue","setBaseTarget","getOriginFromTransition","getOrigin","animateVisualElement","notifyAnimationStart","animations","animateVariant","all","resolvedDefinition","animateTarget","notifyAnimationComplete","transitionOverride","getChildAnimations","forwardDelay","animateChildren","first","last","_e","_f","animationTypeState","getState","valueTarget","shouldBlockAnimation","maxStaggerDuration","generateStaggerDuration","sortByTreeOrder","sortNodePosition","protectedKeys","needsAnimating","shouldBlock","variantPriorityOrder","Animate","Drag","Exit","reversePriorityOrder","numAnimationTypes","animateList","createAnimationState","createState","allAnimatedKeys","isInitialRender","buildResolvedTypeValues","acc","isAnimated","setAnimateFunction","makeAnimator","changedActiveType","getVariantContext","removedKeys","encounteredKeys","removedVariantIndex","Infinity","_loop_1","typeState","propIsVariant","activeDelta","isInherited","manuallyAnimateOnMount","prevProp","shouldAnimateType","variantsHaveChanged","definitionList","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","delete","apply","fallbackAnimation_1","fallbackTarget","getBaseTarget","shouldAnimate","createTypeState","subscribe","PanSession","handlers","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","getPanInfo","history","isPanStarted","isDistancePastThreshold","onStart","onMove","handlePointerMove","transformPoint","buttons","handlePointerUp","update","end","onEnd","onSessionEnd","panInfo","initialInfo","onSessionStart","removeListeners","updateHandlers","cancelSync","subtractPoint","lastDevicePoint","startDevicePoint","timestampedPoint","lastPoint","time","noop","any","convertBoundingBoxToAxisBox","min","max","convertAxisBoxToBoundingBox","transformBoundingBox","topLeft","bottomRight","axisBox","copyAxisBox","box","zeroDelta","translate","originPoint","eachAxis","clampProgress","clamp","isNear","maxDistance","calcLength","axis","calcOrigin","sourceLength","targetLength","updateAxisDelta","updateBoxDelta","defaultOrigin","calcRelativeAxis","relative","calcRelativeBox","parentProjection","relativeTarget","applyConstraints","elastic","calcConstrainedMinPoint","constraints","calcRelativeAxisConstraints","calcRelativeConstraints","layoutBox","calcViewportAxisConstraints","layoutAxis","constraintsAxis","calcViewportConstraints","constraintsBox","calcPositionFromProgress","axisLength","rebaseAxisConstraints","relativeConstraints","defaultElastic","resolveDragElastic","dragElastic","resolveAxisElastic","minLabel","maxLabel","resolvePointElastic","label","getBoundingBox","compareByDepth","depth","isProjecting","shouldResetTransform","collectProjectingAncestors","ancestors","collectProjectingChildren","children","addChild","updateLayoutMeasurement","getLayoutState","notifyBeforeLayoutMeasure","measureViewportBox","layoutCorrected","notifyLayoutMeasure","prevViewportBox","rebaseProjectionTarget","snapshotViewportBox","tweenAxis","calcRelativeOffsetAxis","calcRelativeOffset","checkIfParentHasChanged","prevId","getLayoutId","nextId","isDraggable","_dragX","resetAxis","originAxis","resetBox","originBox","scalePoint","distanceFromOrigin","scaled","applyPointDelta","boxScale","applyAxisDelta","applyBoxDelta","applyAxisTransforms","final","transforms","scaleKey","originKey","axisOrigin","xKeys","yKeys","applyBoxTransforms","finalBox","removePointDelta","removeAxisDelta","removeAxisTransforms","removeBoxTransforms","applyTreeDeltas","treePath","treeLength","node","getLatestValues","convertToRelativeProjection","isLayoutDrag","projectionParent","getProjectionParent","setProjectionTargetAxis","unresolvedJobs","pushJob","stack","job","pointer","batchLayout","flushLayout","reads","writes","setRead","setWrite","numStacks","executeJob","elementDragControls","WeakMap","lastPointerEvent","VisualElementDragControls","isDragging","currentDirection","hasMutatedConstraints","cursorProgress","openGlobalLock","panSession","enableLayoutProjection","originEvent","snapToCursor","stopMotion","initialPoint","cancelLayout","read","write","tree","hasManuallySetCursorOrigin","lockProjectionTarget","resetTransform","restoreTransform","isRelativeDrag","getAxisMotionValue","isExternalDrag","scheduleUpdateLayoutProjection","axisValue","flushSync","preRender","resolveDragConstraints","dragPropagation","onDragStart","dragDirectionLock","getCurrentDirection","onDirectionLock","updateAxis","onDrag","dragConstraints","resolveRefConstraints","onMeasureDragConstraints","constraintsElement","measuredConstraints","userConstraints","cancelDrag","unlockProjectionTarget","animateDragEnd","onDragEnd","shouldDrag","length_1","center","updateAxisMotionValue","updateVisualElementAxis","nextValue","axisLayout","axisProgress","_g","dragMomentum","remainingProps","dragKey","_dragY","dragTransition","isRelative","relativeConstraints_1","targetFinal","momentumAnimations","bounceStiffness","bounceDamping","timeConstant","startAxisValueAnimation","startLayoutAnimation","onDragTransitionEnd","stopLayoutAnimation","currentValue","boxProgress","updateConstraints","onReady","stopPointerListener","dragListener","stopResizeListener","stopLayoutUpdateListener","onLayoutUpdate","prevDragCursor","direction","lockThreshold","abs","useDrag","groupDragControls","dragControls","usePanGesture","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","Presence","VisibilityAction","isCSSVariable","cssVariableRegex","parseCSSVariable","match","exec","token","fallback","maxDepth","getVariableValue","getComputedStyle","getPropertyValue","resolveCSSVariables","HTMLElement","pixelsToPercent","pixels","correctBorderRadius","_layoutState","varToken","correctBoxShadow","original","containsCSSVariables","cssVariables","shadow","template","createTransformer","xScale","yScale","averageScale","output","i_1","cssVariable","borderCorrectionDefinition","defaultScaleCorrectors","boxShadow","progressTarget","_super","__extends","arguments","frameTarget","currentAnimationTarget","stopAxisAnimation","isAnimatingTree","targetBox","visibilityAction","shouldStackAnimate","prevParent","prevParentViewportBox","parentLayout","isProvidedCorrectDataForRelativeSharedLayout","boxHasMoved","hasMoved","isTargetLocked","setVisibility","Show","animateAxis","notifyLayoutAnimationComplete","componentDidMount","animateMotionValue","unsubLayoutReady","layoutSafeToRemove","componentWillUnmount","axisIsEqual","layoutProgress","getProjectionAnimationProgress","frame","unsubscribeProgress","layoutTransition","defaultLayoutTransition","AnimateLayoutContextProvider","isZeroBox","zeroAxis","defaultHandler","layoutReady","notifyLayoutReady","createBatcher","queue","flush","allElements","presence","Present","assignProjectionToSnapshot","SharedLayoutContext","FramerTreeLayoutContext","isSharedLayout","forceUpdate","Measure","syncLayout","framerSyncLayout","onUnmount","remove","getSnapshotBeforeUpdate","syncUpdate","componentDidUpdate","MeasureContextProvider","layoutAnimations","createProjectionState","createLayoutState","deltaTransform","zeroLayout","buildLayoutProjectionTransform","latestTransform","xTranslate","yTranslate","identityProjection","buildLayoutProjectionTransformOrigin","names","createLifecycles","managers","propSubscriptions","lifecycles","clearAllListeners","manager","updatePropListeners","on","propListener","args","_i","updateMotionValuesFromProps","prevValue","existingValue","getStaticValue","removeValue","updateLayoutDeltas","FlatTree","isDirty","setCurrentViewportBox","relativeOffset","treeType","build","renderInstance","readValueFromInstance","removeValueFromRenderState","leadProjection","leadLatestValues","unsubscribeFromLeadVisualElement","crossfader","hasViewportBoxUpdated","valueSubscriptions","prevMotionValues","projectionTargetProgress","baseTarget","removeFromVariantTree","isProjectionReady","triggerBuild","valuesToRender","crossfadedValues","getCrossfadeState","notifyUpdate","updateLayoutProjection","prevTreeScaleX","prevTreeScaleY","prevDeltaTransform","path","notifyViewportBoxUpdate","scheduleRender","updateTreeLayoutProjection","layoutTree","fireUpdateLayoutProjection","bindToMotionValue","removeOnChange","latestValue","removeOnRenderRequest","initialMotionValues","isVisible","isMounted","newInstance","pointTo","addVariantChild","closestVariantNode","getClosestVariantNode","other","setStaticValue","visibility","canMutate","defaultValue","newProps","startAtParent","context_1","numVariantProps","variantProps","setCrossfader","newCrossfader","withTransform","viewportBox","notifySetAxisTarget","force","shouldRebase","notifyLayoutUpdate","fireResolveRelativeTargetBox","foundParent","ancestor","resolveRelativeTargetBox","relativeParent","_layoutResetTransform","newLead","onSetAxisTarget","onLayoutAnimationComplete","Entering","positionalKeys","isPositionalKey","hasPositionalKey","setAndResetVelocity","isNumOrPxType","BoundingBoxDimension","getPosFromMatrix","matrix","pos","split","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","nonTranslationalTransformKeys","removeNonTranslationalTransform","removedTransforms","positionalValues","convertChangedValueTypes","changedKeys","originBbox","elementComputedStyle","display","originComputedStyle","targetBbox","checkAndConvertChangedValueTypes","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","fromType","toType","numKeyframes","convertedTarget","unitConversion","parseDomVariant","getComputedStyle$1","htmlConfig","domElement","defaultType","computedStyle","compareDocumentPosition","mutableState","parsed","isProjectionTranform","htmlVisualElement","svgVisualElement","getAttribute","_element","createDomVisualElement","featureBundle","motion","createDomMotionComponent","m","useForceUpdate","unloadingRef","useState","forcedRenderCount","setForcedRenderCount","getPresenceId","PresenceChild","presenceAffectsLayout","presenceChildren","newChildrenMap","childId","allComplete","isComplete","_","getChildKey","updateChildLookup","allChildren","seenChildren","console","warn","onlyElements","filtered","Children","isValidElement","AnimatePresence","exitBeforeEnter","forceRender","layoutContext","filteredChildren","presentChildren","exiting","childrenToRender","presentKeys","targetKeys","numPresent","insertionIndex","onExit","removeIndex","findIndex","presentChild","cloneElement","createCrossfader","lead","follow","crossfadeOpacity","preserveFollowOpacity","prevOptions","leadState","followState","finalCrossfadeFrame","prevUpdate","startCrossfadeAnimation","hasUpdated","updateCrossfade","latestLeadValues","latestFollowValues","prevValues","leadTargetOpacity","followTargetOpacity","easeCrossfadeIn","easeCrossfadeOut","mixValues","fromLead","toLead","initialProgress","reset","setOptions","newOptions","compress","easing","borders","numBorders","hasFollowElement","borderLabel","followRadius","getRadius","leadRadius","mixColor","radiusName","layoutStack","leadIsExiting","prevState","needsCrossfadeAnimation","getFollowViewportBox","getFollowLayout","getLead","updateSnapshot","clearSnapshot","updateLeadAndFollow","Exiting","shouldCrossfade","resetRotate","hasRotate","resetValues","AnimateSharedLayout","stacks","hasMounted","updateScheduled","renderScheduled","syncContext","scheduleUpdate","removeChild","shouldComponentUpdate","updateStacks","getStack","addToStack","removeFromStack","contextType","MotionConfig","transitionDependency","toString","LazyMotion","isLazyBundle","setIsLoaded","loadedRenderer","loadedFeatures","domAnimation","domMax","useMotionValue","setLatest_1","useOnChange","useMultiOnChange","unsubscribe","useCombineMotionValues","combineValues","updateValue","useMotionTemplate","fragments","numFragments","buildValue","isCustomValueType","getMixer","useImmediate","argOffset","inputValue","inputRange","outputRange","interpolator","interpolate","mixer","useTransform","input","inputRangeOrTransformer","transformer","useListTransform","numValues","useSpring","activeSpringAnimation","useVelocity","newVelocity","createScrollMotionValues","scrollX","scrollY","scrollXProgress","scrollYProgress","setProgress","maxOffset","createScrollUpdater","getOffsets","xOffset","yOffset","xMaxOffset","yMaxOffset","getElementScrollOffsets","scrollLeft","scrollTop","scrollWidth","offsetWidth","scrollHeight","offsetHeight","useElementScroll","updateScrollValues","scrollListener","passive","resizeListener","viewportScrollValues","getViewportScrollOffsets","pageXOffset","pageYOffset","document","body","clientWidth","innerWidth","clientHeight","innerHeight","hasListeners","addEventListeners","useViewportScroll","prefersReducedMotion","initPrefersReducedMotion","matchMedia","motionMediaQuery_1","setReducedMotionPreferences","matches","addListener","useReducedMotion","shouldReduceMotion","setShouldReduceMotion","animationControls","pendingAnimations","subscribers","animations_1","useAnimation","useCycle","items","setItem","wrap","DragControls","componentControls","nativeEvent","createDragControls","useDragControls","createObject","stateVisualElement","_state","initialState","useAnimatedState","setAnimationState","animationDefinition","maxScale","invertScale","hasWarned","useInvertedScale","parentScaleX","parentScaleY","useDeprecatedAnimatedState","useDeprecatedInvertedScale"],"mappings":"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f,SAAb,CAAxB,CAA/B,EAAiFsnB,IAAjF,CAAsFF,OAAtF;AACH,OAHD;AAIA,aAAO,YAAY;AACfmtB,QAAAA,UAAU,GAAG,KAAb;AACAjwB,QAAAA,QAAQ,CAACL,IAAT;AACH,OAHD;AAIH;AAnDU,GAAf;AAqDA,SAAOK,QAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS22B,YAAT,GAAwB;AACpB,MAAI32B,QAAQ,GAAG9hB,WAAW,CAACq4C,iBAAD,CAA1B;AACA38C,EAAAA,KAAK,CAACkF,SAAN,CAAgBkhB,QAAQ,CAAC3e,KAAzB,EAAgC,EAAhC;AACA,SAAO2e,QAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS42B,QAAT,GAAoB;AAChB,MAAIC,KAAK,GAAG,EAAZ;;AACA,OAAK,IAAIrV,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG/E,SAAS,CAAC9/B,MAAhC,EAAwC6kC,EAAE,EAA1C,EAA8C;AAC1CqV,IAAAA,KAAK,CAACrV,EAAD,CAAL,GAAY/E,SAAS,CAAC+E,EAAD,CAArB;AACH;;AACD,MAAIhhB,KAAK,GAAG5mB,KAAK,CAACyE,MAAN,CAAa,CAAb,CAAZ;;AACA,MAAId,EAAE,GAAG7D,KAAK,CAACwhB,MAAN,CAAathB,KAAK,CAACuwC,QAAN,CAAe0M,KAAK,CAACr2B,KAAK,CAA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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar React = require('react');\nvar heyListen = require('hey-listen');\nvar styleValueTypes = require('style-value-types');\nvar popmotion = require('popmotion');\nvar sync = require('framesync');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n['default'] = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\n\nvar createDefinition = function (propNames) { return ({\n    isEnabled: function (props) { return propNames.some(function (name) { return !!props[name]; }); },\n}); };\nvar featureDefinitions = {\n    measureLayout: createDefinition([\n        \"layout\",\n        \"layoutId\",\n        \"drag\",\n        \"_layoutResetTransform\",\n    ]),\n    animation: createDefinition([\n        \"animate\",\n        \"exit\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ]),\n    exit: createDefinition([\"exit\"]),\n    drag: createDefinition([\"drag\", \"dragControls\"]),\n    focus: createDefinition([\"whileFocus\"]),\n    hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n    tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n    pan: createDefinition([\n        \"onPan\",\n        \"onPanStart\",\n        \"onPanSessionStart\",\n        \"onPanEnd\",\n    ]),\n    layoutAnimation: createDefinition([\"layout\", \"layoutId\"]),\n};\nfunction loadFeatures(features) {\n    for (var key in features) {\n        var Component = features[key];\n        if (Component !== null)\n            featureDefinitions[key].Component = Component;\n    }\n}\n\nvar LazyContext = React.createContext({ strict: false });\n\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */\nfunction useFeatures(props, visualElement, preloadedFeatures) {\n    var features = [];\n    var lazyContext = React.useContext(LazyContext);\n    if (!visualElement)\n        return null;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        lazyContext.strict) {\n        heyListen.invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    }\n    for (var i = 0; i < numFeatures; i++) {\n        var name_1 = featureNames[i];\n        var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component = _a.Component;\n        /**\n         * It might be possible in the future to use this moment to\n         * dynamically request functionality. In initial tests this\n         * was producing a lot of duplication amongst bundles.\n         */\n        if (isEnabled(props) && Component) {\n            features.push(React__namespace.createElement(Component, tslib.__assign({ key: name_1 }, props, { visualElement: visualElement })));\n        }\n    }\n    return features;\n}\n\n/**\n * @public\n */\nvar MotionConfigContext = React.createContext({\n    transformPagePoint: function (p) { return p; },\n    isStatic: false,\n});\n\nvar MotionContext = React.createContext({});\nfunction useVisualElementContext() {\n    return React.useContext(MotionContext).visualElement;\n}\n\n/**\n * @public\n */\nvar PresenceContext = React.createContext(null);\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    var ref = React.useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence() {\n    var context = React.useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    // Replace with useOpaqueId when released in React\n    var id = useUniqueId();\n    React.useEffect(function () { return register(id); }, []);\n    var safeToRemove = function () { return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id); };\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(React.useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\nvar counter = 0;\nvar incrementId = function () { return counter++; };\nvar useUniqueId = function () { return useConstant(incrementId); };\n\n/**\n * @internal\n */\nvar LayoutGroupContext = React.createContext(null);\n\nvar isBrowser = typeof window !== \"undefined\";\n\nvar useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n\nfunction useLayoutId(_a) {\n    var layoutId = _a.layoutId;\n    var layoutGroupId = React.useContext(LayoutGroupContext);\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n    var config = React.useContext(MotionConfigContext);\n    var lazyContext = React.useContext(LazyContext);\n    var parent = useVisualElementContext();\n    var presenceContext = React.useContext(PresenceContext);\n    var layoutId = useLayoutId(props);\n    var visualElementRef = React.useRef(undefined);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    if (!createVisualElement)\n        createVisualElement = lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState: visualState,\n            parent: parent,\n            props: tslib.__assign(tslib.__assign({}, props), { layoutId: layoutId }),\n            presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n            blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,\n        });\n    }\n    var visualElement = visualElementRef.current;\n    useIsomorphicLayoutEffect(function () {\n        if (!visualElement)\n            return;\n        visualElement.setProps(tslib.__assign(tslib.__assign(tslib.__assign({}, config), props), { layoutId: layoutId }));\n        visualElement.isPresent = isPresent(presenceContext);\n        visualElement.isPresenceRoot =\n            !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);\n        /**\n         * Fire a render to ensure the latest state is reflected on-screen.\n         */\n        visualElement.syncRender();\n    });\n    React.useEffect(function () {\n        var _a;\n        if (!visualElement)\n            return;\n        /**\n         * In a future refactor we can replace the features-as-components and\n         * have this loop through them all firing \"effect\" listeners\n         */\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n    });\n    useIsomorphicLayoutEffect(function () { return function () { return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount(); }; }, []);\n    return visualElement;\n}\n\nfunction isRefObject(ref) {\n    return (typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return React.useCallback(function (instance) {\n        var _a;\n        instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n        if (visualElement) {\n            instance\n                ? visualElement.mount(instance)\n                : visualElement.unmount();\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\n/**\n * Decides if the supplied variable is an array of variant labels\n */\nfunction isVariantLabels(v) {\n    return Array.isArray(v);\n}\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || isVariantLabels(v);\n}\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\nfunction getCurrent(visualElement) {\n    var current = {};\n    visualElement.forEachValue(function (value, key) { return (current[key] = value.get()); });\n    return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\nfunction getVelocity$1(visualElement) {\n    var velocity = {};\n    visualElement.forEachValue(function (value, key) { return (velocity[key] = value.getVelocity()); });\n    return velocity;\n}\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n    var _a;\n    if (currentValues === void 0) { currentValues = {}; }\n    if (currentVelocity === void 0) { currentVelocity = {}; }\n    if (typeof definition === \"string\") {\n        definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n    }\n    return typeof definition === \"function\"\n        ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity)\n        : definition;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    var props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));\n}\nfunction checkIfControllingVariants(props) {\n    var _a;\n    return (typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \"function\" ||\n        isVariantLabel(props.initial) ||\n        isVariantLabel(props.animate) ||\n        isVariantLabel(props.whileHover) ||\n        isVariantLabel(props.whileDrag) ||\n        isVariantLabel(props.whileTap) ||\n        isVariantLabel(props.whileFocus) ||\n        isVariantLabel(props.exit));\n}\nfunction checkIfVariantNode(props) {\n    return Boolean(checkIfControllingVariants(props) || props.variants);\n}\n\nfunction getCurrentTreeVariants(props, context) {\n    if (checkIfControllingVariants(props)) {\n        var initial = props.initial, animate = props.animate;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\nfunction useCreateMotionContext(props, isStatic) {\n    var _a = getCurrentTreeVariants(props, React.useContext(MotionContext)), initial = _a.initial, animate = _a.animate;\n    return React.useMemo(function () { return ({ initial: initial, animate: animate }); }, \n    /**\n     * Only break memoisation in static mode\n     */\n    isStatic\n        ? [\n            variantLabelsAsDependency(initial),\n            variantLabelsAsDependency(animate),\n        ]\n        : []);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\nfunction createMotionComponent(_a) {\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we're rendering in a static environment, we only visually update the component\n         * as a result of a React-rerender rather than interactions or animations. This\n         * means we don't need to load additional memory structures like VisualElement,\n         * or any gesture/animation features.\n         */\n        var isStatic = React.useContext(MotionConfigContext).isStatic;\n        var features = null;\n        /**\n         * Create the tree context. This is memoized and will only trigger renders\n         * when the current tree variant changes in static mode.\n         */\n        var context = useCreateMotionContext(props, isStatic);\n        /**\n         *\n         */\n        var visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             *\n             * TODO: The intention is to move these away from a React-centric to a\n             * VisualElement-centric lifecycle scheme.\n             */\n            features = useFeatures(props, context.visualElement, preloadedFeatures);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (React__namespace.createElement(React__namespace.Fragment, null,\n            React__namespace.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)),\n            features));\n    }\n    return React.forwardRef(MotionComponent);\n}\n\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion(Component)\n * ```\n *\n * @public\n */\nfunction createMotionProxy(createConfig) {\n    function custom(Component, customMotionComponentConfig) {\n        if (customMotionComponentConfig === void 0) { customMotionComponentConfig = {}; }\n        return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    var componentCache = new Map();\n    return new Proxy(custom, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: function (_target, key) {\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, custom(key));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\n/**\n * We keep these listed seperately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nvar lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== \"string\" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes(\"-\")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it's an SVG component\n         */\n        /[A-Z]/.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\nvar valueScaleCorrection = {};\n/**\n * @internal\n */\nfunction addScaleCorrection(correctors) {\n    for (var key in correctors) {\n        valueScaleCorrection[key] = correctors[key];\n    }\n}\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\n/**\n * Generate a list of every possible transform key.\n */\nvar transformProps = [\"transformPerspective\", \"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n    return transformAxes.forEach(function (axesKey) {\n        return transformProps.push(operationKey + axesKey);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nfunction sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\nvar transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n    return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\n\nfunction isForcedMotionValue(key, _a) {\n    var layout = _a.layout, layoutId = _a.layoutId;\n    return (isTransformProp(key) ||\n        isTransformOriginProp(key) ||\n        ((layout || layoutId !== undefined) &&\n            (!!valueScaleCorrection[key] || key === \"opacity\")));\n}\n\nvar isMotionValue = function (value) {\n    return value !== null && typeof value === \"object\" && value.getVelocity;\n};\n\nvar translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n    var transform = _a.transform, transformKeys = _a.transformKeys;\n    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;\n    // The transform string we're going to build into.\n    var transformString = \"\";\n    // Transform keys into their default order - this will determine the output order.\n    transformKeys.sort(sortTransformProps);\n    // Track whether the defined transform has a defined z so we don't add a\n    // second to enable hardware acceleration\n    var transformHasZ = false;\n    // Loop over each transform and build them into transformString\n    var numTransformKeys = transformKeys.length;\n    for (var i = 0; i < numTransformKeys; i++) {\n        var key = transformKeys[i];\n        transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n        if (key === \"z\")\n            transformHasZ = true;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += \"translateZ(0)\";\n    }\n    else {\n        transformString = transformString.trim();\n    }\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n/**\n * Build a transformOrigin style. Uses the same defaults as the browser for\n * undefined origins.\n */\nfunction buildTransformOrigin(_a) {\n    var _b = _a.originX, originX = _b === void 0 ? \"50%\" : _b, _c = _a.originY, originY = _c === void 0 ? \"50%\" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;\n    return originX + \" \" + originY + \" \" + originZ;\n}\n\n/**\n * Returns true if the provided key is a CSS variable\n */\nfunction isCSSVariable$1(key) {\n    return key.startsWith(\"--\");\n}\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nvar getValueAsType = function (value, type) {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nvar int = tslib.__assign(tslib.__assign({}, styleValueTypes.number), { transform: Math.round });\n\nvar numberValueTypes = {\n    // Border props\n    borderWidth: styleValueTypes.px,\n    borderTopWidth: styleValueTypes.px,\n    borderRightWidth: styleValueTypes.px,\n    borderBottomWidth: styleValueTypes.px,\n    borderLeftWidth: styleValueTypes.px,\n    borderRadius: styleValueTypes.px,\n    radius: styleValueTypes.px,\n    borderTopLeftRadius: styleValueTypes.px,\n    borderTopRightRadius: styleValueTypes.px,\n    borderBottomRightRadius: styleValueTypes.px,\n    borderBottomLeftRadius: styleValueTypes.px,\n    // Positioning props\n    width: styleValueTypes.px,\n    maxWidth: styleValueTypes.px,\n    height: styleValueTypes.px,\n    maxHeight: styleValueTypes.px,\n    size: styleValueTypes.px,\n    top: styleValueTypes.px,\n    right: styleValueTypes.px,\n    bottom: styleValueTypes.px,\n    left: styleValueTypes.px,\n    // Spacing props\n    padding: styleValueTypes.px,\n    paddingTop: styleValueTypes.px,\n    paddingRight: styleValueTypes.px,\n    paddingBottom: styleValueTypes.px,\n    paddingLeft: styleValueTypes.px,\n    margin: styleValueTypes.px,\n    marginTop: styleValueTypes.px,\n    marginRight: styleValueTypes.px,\n    marginBottom: styleValueTypes.px,\n    marginLeft: styleValueTypes.px,\n    // Transform props\n    rotate: styleValueTypes.degrees,\n    rotateX: styleValueTypes.degrees,\n    rotateY: styleValueTypes.degrees,\n    rotateZ: styleValueTypes.degrees,\n    scale: styleValueTypes.scale,\n    scaleX: styleValueTypes.scale,\n    scaleY: styleValueTypes.scale,\n    scaleZ: styleValueTypes.scale,\n    skew: styleValueTypes.degrees,\n    skewX: styleValueTypes.degrees,\n    skewY: styleValueTypes.degrees,\n    distance: styleValueTypes.px,\n    translateX: styleValueTypes.px,\n    translateY: styleValueTypes.px,\n    translateZ: styleValueTypes.px,\n    x: styleValueTypes.px,\n    y: styleValueTypes.px,\n    z: styleValueTypes.px,\n    perspective: styleValueTypes.px,\n    transformPerspective: styleValueTypes.px,\n    opacity: styleValueTypes.alpha,\n    originX: styleValueTypes.progressPercentage,\n    originY: styleValueTypes.progressPercentage,\n    originZ: styleValueTypes.px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: styleValueTypes.alpha,\n    strokeOpacity: styleValueTypes.alpha,\n    numOctaves: int,\n};\n\nfunction buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n    var _a;\n    var style = state.style, vars = state.vars, transform = state.transform, transformKeys = state.transformKeys, transformOrigin = state.transformOrigin;\n    // Empty the transformKeys array. As we're throwing out refs to its items\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\n    // with a manual incrementation would be better.\n    transformKeys.length = 0;\n    // Track whether we encounter any transform or transformOrigin values.\n    var hasTransform = false;\n    var hasTransformOrigin = false;\n    // Does the calculated transform essentially equal \"none\"?\n    var transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept seperately for further processing.\n     */\n    for (var key in latestValues) {\n        var value = latestValues[key];\n        /**\n         * If this is a CSS variable we don't do any further processing.\n         */\n        if (isCSSVariable$1(key)) {\n            vars[key] = value;\n            continue;\n        }\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        var valueType = numberValueTypes[key];\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            // If we already know we have a non-default transform, early return\n            if (!transformIsNone)\n                continue;\n            // Otherwise check to see if this is a default transform\n            if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))\n                transformIsNone = false;\n        }\n        else if (isTransformOriginProp(key)) {\n            transformOrigin[key] = valueAsType;\n            // If this is a transform origin, flag and enable further transform-origin processing\n            hasTransformOrigin = true;\n        }\n        else {\n            /**\n             * If layout projection is on, and we need to perform scale correction for this\n             * value type, perform it.\n             */\n            if ((projection === null || projection === void 0 ? void 0 : projection.isHydrated) &&\n                (layoutState === null || layoutState === void 0 ? void 0 : layoutState.isHydrated) &&\n                valueScaleCorrection[key]) {\n                var correctedValue = valueScaleCorrection[key].process(value, layoutState, projection);\n                /**\n                 * Scale-correctable values can define a number of other values to break\n                 * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n                 */\n                var applyTo = valueScaleCorrection[key].applyTo;\n                if (applyTo) {\n                    var num = applyTo.length;\n                    for (var i = 0; i < num; i++) {\n                        style[applyTo[i]] = correctedValue;\n                    }\n                }\n                else {\n                    style[key] = correctedValue;\n                }\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (layoutState &&\n        projection &&\n        buildProjectionTransform &&\n        buildProjectionTransformOrigin) {\n        style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform : undefined);\n        if (transformTemplate) {\n            style.transform = transformTemplate(transform, style.transform);\n        }\n        style.transformOrigin = buildProjectionTransformOrigin(layoutState);\n    }\n    else {\n        if (hasTransform) {\n            style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n        }\n        if (hasTransformOrigin) {\n            style.transformOrigin = buildTransformOrigin(transformOrigin);\n        }\n    }\n}\n\nvar createHtmlRenderState = function () { return ({\n    style: {},\n    transform: {},\n    transformKeys: [],\n    transformOrigin: {},\n    vars: {},\n}); };\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (var key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n    var transformTemplate = _a.transformTemplate;\n    return React.useMemo(function () {\n        var state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, undefined, undefined, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n        var vars = state.vars, style = state.style;\n        return tslib.__assign(tslib.__assign({}, vars), style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n    var styleProp = props.style || {};\n    var style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n    if (props.transformValues) {\n        style = props.transformValues(style);\n    }\n    return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    var htmlProps = {};\n    var style = useStyle(props, visualState, isStatic);\n    if (Boolean(props.drag)) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout =\n            \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : \"pan-\" + (props.drag === \"x\" ? \"y\" : \"x\");\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nvar validMotionProps = new Set([\n    \"initial\",\n    \"animate\",\n    \"exit\",\n    \"style\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"transformValues\",\n    \"custom\",\n    \"inherit\",\n    \"layout\",\n    \"layoutId\",\n    \"_layoutResetTransform\",\n    \"onLayoutAnimationComplete\",\n    \"onViewportBoxUpdate\",\n    \"onLayoutMeasure\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"drag\",\n    \"dragControls\",\n    \"dragListener\",\n    \"dragConstraints\",\n    \"dragDirectionLock\",\n    \"_dragX\",\n    \"_dragY\",\n    \"dragElastic\",\n    \"dragMomentum\",\n    \"dragPropagation\",\n    \"dragTransition\",\n    \"whileDrag\",\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanEnd\",\n    \"onPanSessionStart\",\n    \"onTap\",\n    \"onTapStart\",\n    \"onTapCancel\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"whileFocus\",\n    \"whileTap\",\n    \"whileHover\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return validMotionProps.has(key);\n}\n\nvar shouldForward = function (key) { return !isValidMotionProp(key); };\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n    shouldForward = function (key) {\n        // Handle events explicitly as Emotion validates them all as true\n        if (key.startsWith(\"on\")) {\n            return !isValidMotionProp(key);\n        }\n        else {\n            return emotionIsPropValid_1(key);\n        }\n    };\n}\ncatch (_a) {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    var filteredProps = {};\n    for (var key in props) {\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key))) {\n            filteredProps[key] = props[key];\n        }\n    }\n    return filteredProps;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : styleValueTypes.px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n    var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n    return pxOriginX + \" \" + pxOriginY;\n}\n\n// Convert a progress 0-1 to a pixels value based on the provided length\nvar progressToPixels = function (progress, length) {\n    return styleValueTypes.px.transform(progress * length);\n};\nvar dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nvar camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n    if (spacing === void 0) { spacing = 1; }\n    if (offset === void 0) { offset = 0; }\n    if (useDashCase === void 0) { useDashCase = true; }\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    var keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = progressToPixels(-offset, totalLength);\n    // Build the dash array\n    var pathLength = progressToPixels(length, totalLength);\n    var pathSpacing = progressToPixels(spacing, totalLength);\n    attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, \n    // This is object creation, which we try to avoid per-frame.\n    latest = tslib.__rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n    buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);\n    state.attrs = state.style;\n    state.style = {};\n    var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Treat x/y not as shortcuts but as actual attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    // Build SVG path if one has been measured\n    if (totalPathLength !== undefined && pathLength !== undefined) {\n        buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nvar createSvgRenderState = function () { return (tslib.__assign(tslib.__assign({}, createHtmlRenderState()), { attrs: {} })); };\n\nfunction useSVGProps(props, visualState) {\n    var visualProps = React.useMemo(function () {\n        var state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);\n        return tslib.__assign(tslib.__assign({}, state.attrs), { style: tslib.__assign({}, state.style) });\n    }, [visualState]);\n    if (props.style) {\n        var rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = tslib.__assign(tslib.__assign({}, rawStyles), visualProps.style);\n    }\n    return visualProps;\n}\n\nfunction createUseRender(forwardMotionProps) {\n    if (forwardMotionProps === void 0) { forwardMotionProps = false; }\n    var useRender = function (Component, props, ref, _a, isStatic) {\n        var latestValues = _a.latestValues;\n        var useVisualProps = isSVGComponent(Component)\n            ? useSVGProps\n            : useHTMLProps;\n        var visualProps = useVisualProps(props, latestValues, isStatic);\n        var filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n        var elementProps = tslib.__assign(tslib.__assign(tslib.__assign({}, filteredProps), visualProps), { ref: ref });\n        return React.createElement(Component, elementProps);\n    };\n    return useRender;\n}\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\nvar camelToDash = function (str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\nfunction renderHTML(element, _a) {\n    var style = _a.style, vars = _a.vars;\n    // Directly assign style into the Element's style prop. In tests Object.assign is the\n    // fastest way to assign styles.\n    Object.assign(element.style, style);\n    // Loop over any CSS variables and assign those.\n    for (var key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nvar camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n]);\n\nfunction renderSVG(element, renderState) {\n    renderHTML(element, renderState);\n    for (var key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nfunction scrapeMotionValuesFromProps$1(props) {\n    var style = props.style;\n    var newValues = {};\n    for (var key in style) {\n        if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props) {\n    var newValues = scrapeMotionValuesFromProps$1(props);\n    for (var key in props) {\n        if (isMotionValue(props[key])) {\n            var targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nfunction isAnimationControls(v) {\n    return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\nvar isKeyframesTarget = function (v) {\n    return Array.isArray(v);\n};\n\nvar isCustomValue = function (v) {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function (v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\nfunction resolveMotionValue(value) {\n    var unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue)\n        ? unwrappedValue.toValue()\n        : unwrappedValue;\n}\n\nfunction makeState(_a, props, context, presenceContext) {\n    var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;\n    var state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onMount) {\n        state.mount = function (instance) { return onMount(props, instance, state); };\n    }\n    return state;\n}\nvar makeUseVisualState = function (config) { return function (props, isStatic) {\n    var context = React.useContext(MotionContext);\n    var presenceContext = React.useContext(PresenceContext);\n    return isStatic\n        ? makeState(config, props, context, presenceContext)\n        : useConstant(function () { return makeState(config, props, context, presenceContext); });\n}; };\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    var values = {};\n    var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n    var motionValues = scrapeMotionValues(props);\n    for (var key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    var initial = props.initial, animate = props.animate;\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    if (context &&\n        isVariantNode &&\n        !isControllingVariants &&\n        props.inherit !== false) {\n        initial !== null && initial !== void 0 ? initial : (initial = context.initial);\n        animate !== null && animate !== void 0 ? animate : (animate = context.animate);\n    }\n    var variantToSet = blockInitialAnimation || initial === false ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        list.forEach(function (definition) {\n            var resolved = resolveVariantFromProps(props, definition);\n            if (!resolved)\n                return;\n            var transitionEnd = resolved.transitionEnd; resolved.transition; var target = tslib.__rest(resolved, [\"transitionEnd\", \"transition\"]);\n            for (var key in target)\n                values[key] = target[key];\n            for (var key in transitionEnd)\n                values[key] = transitionEnd[key];\n        });\n    }\n    return values;\n}\n\nvar svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onMount: function (props, instance, _a) {\n            var renderState = _a.renderState, latestValues = _a.latestValues;\n            try {\n                renderState.dimensions =\n                    typeof instance.getBBox ===\n                        \"function\"\n                        ? instance.getBBox()\n                        : instance.getBoundingClientRect();\n            }\n            catch (e) {\n                // Most likely trying to measure an unrendered element under Firefox\n                renderState.dimensions = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0,\n                };\n            }\n            if (isPath(instance)) {\n                renderState.totalPathLength = instance.getTotalLength();\n            }\n            buildSVGAttrs(renderState, latestValues, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);\n            // TODO: Replace with direct assignment\n            renderSVG(instance, renderState);\n        },\n    }),\n};\nfunction isPath(element) {\n    return element.tagName === \"path\";\n}\n\nvar htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement) {\n    var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;\n    var baseConfig = isSVGComponent(Component)\n        ? svgMotionConfig\n        : htmlMotionConfig;\n    return tslib.__assign(tslib.__assign({}, baseConfig), { preloadedFeatures: preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement: createVisualElement,\n        Component: Component });\n}\n\nvar AnimationType;\n(function (AnimationType) {\n    AnimationType[\"Animate\"] = \"animate\";\n    AnimationType[\"Hover\"] = \"whileHover\";\n    AnimationType[\"Tap\"] = \"whileTap\";\n    AnimationType[\"Drag\"] = \"whileDrag\";\n    AnimationType[\"Focus\"] = \"whileFocus\";\n    AnimationType[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\nfunction addDomEvent(target, eventName, handler, options) {\n    target.addEventListener(eventName, handler, options);\n    return function () { return target.removeEventListener(eventName, handler, options); };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\nfunction useDomEvent(ref, eventName, handler, options) {\n    React.useEffect(function () {\n        var element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [ref, eventName, handler, options]);\n}\n\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\nfunction useFocusGesture(_a) {\n    var whileFocus = _a.whileFocus, visualElement = _a.visualElement;\n    var onFocus = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, true);\n    };\n    var onBlur = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, false);\n    };\n    useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : undefined);\n    useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : undefined);\n}\n\nfunction isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n        return !!(event.pointerType === \"mouse\");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\nfunction filterPrimaryPointer(eventHandler) {\n    return function (event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent ||\n            (isMouseEvent && event.button === 0);\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var point = primaryTouch || defaultPagePoint;\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction pointFromMouse(point, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction extractEventInfo(event, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        point: isTouchEvent(event)\n            ? pointFromTouch(event, pointType)\n            : pointFromMouse(event, pointType),\n    };\n}\nfunction getViewportPointFromEvent(event) {\n    return extractEventInfo(event, \"client\");\n}\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\n    var listener = function (event) {\n        return handler(event, extractEventInfo(event));\n    };\n    return shouldFilterPrimaryPointer\n        ? filterPrimaryPointer(listener)\n        : listener;\n};\n\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function () {\n    return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function () {\n    return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function () {\n    return isBrowser && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointercancel: \"mousecancel\",\n    pointerover: \"mouseover\",\n    pointerout: \"mouseout\",\n    pointerenter: \"mouseenter\",\n    pointerleave: \"mouseleave\",\n};\nvar touchEventNames = {\n    pointerdown: \"touchstart\",\n    pointermove: \"touchmove\",\n    pointerup: \"touchend\",\n    pointercancel: \"touchcancel\",\n};\nfunction getPointerEventName(name) {\n    if (supportsPointerEvents()) {\n        return name;\n    }\n    else if (supportsTouchEvents()) {\n        return touchEventNames[name];\n    }\n    else if (supportsMouseEvents()) {\n        return mouseEventNames[name];\n    }\n    return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n    return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction createLock(name) {\n    var lock = null;\n    return function () {\n        var openLock = function () {\n            lock = null;\n        };\n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === \"y\") {\n        lock = globalVerticalLock();\n    }\n    else if (drag === \"x\") {\n        lock = globalHorizontalLock();\n    }\n    else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function () {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        }\n        else {\n            // Release the locks because we don't use them\n            if (openHorizontal_1)\n                openHorizontal_1();\n            if (openVertical_1)\n                openVertical_1();\n        }\n    }\n    return lock;\n}\nfunction isDragActive() {\n    // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock)\n        return true;\n    openGestureLock();\n    return false;\n}\n\nfunction createHoverEvent(visualElement, isActive, callback) {\n    return function (event, info) {\n        var _a;\n        if (!isMouseEvent(event) || isDragActive())\n            return;\n        callback === null || callback === void 0 ? void 0 : callback(event, info);\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\n    };\n}\nfunction useHoverGesture(_a) {\n    var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement = _a.visualElement;\n    usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover\n        ? createHoverEvent(visualElement, true, onHoverStart)\n        : undefined);\n    usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover\n        ? createHoverEvent(visualElement, false, onHoverEnd)\n        : undefined);\n}\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nvar isNodeOrChild = function (parent, child) {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nfunction useUnmountEffect(callback) {\n    return React.useEffect(function () { return function () { return callback(); }; }, []);\n}\n\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_a) {\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement = _a.visualElement;\n    var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    var isPressing = React.useRef(false);\n    var cancelPointerEndListeners = React.useRef(null);\n    function removePointerEndListener() {\n        var _a;\n        (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        var _a;\n        removePointerEndListener();\n        isPressing.current = false;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        if (!checkPointerEnd())\n            return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */\n        !isNodeOrChild(visualElement.getInstance(), event.target)\n            ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info)\n            : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n    }\n    function onPointerCancel(event, info) {\n        if (!checkPointerEnd())\n            return;\n        onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n    }\n    function onPointerDown(event, info) {\n        var _a;\n        removePointerEndListener();\n        if (isPressing.current)\n            return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = popmotion.pipe(addPointerEvent(window, \"pointerup\", onPointerUp), addPointerEvent(window, \"pointercancel\", onPointerCancel));\n        onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined);\n    useUnmountEffect(removePointerEndListener);\n}\n\nvar makeRenderlessComponent = function (hook) { return function (props) {\n    hook(props);\n    return null;\n}; };\n\nvar gestureAnimations = {\n    tap: makeRenderlessComponent(useTapGesture),\n    focus: makeRenderlessComponent(useFocusGesture),\n    hover: makeRenderlessComponent(useHoverGesture),\n};\n\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    var prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (var i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\nvar easingLookup = {\n    linear: popmotion.linear,\n    easeIn: popmotion.easeIn,\n    easeInOut: popmotion.easeInOut,\n    easeOut: popmotion.easeOut,\n    circIn: popmotion.circIn,\n    circInOut: popmotion.circInOut,\n    circOut: popmotion.circOut,\n    backIn: popmotion.backIn,\n    backInOut: popmotion.backInOut,\n    backOut: popmotion.backOut,\n    anticipate: popmotion.anticipate,\n    bounceIn: popmotion.bounceIn,\n    bounceInOut: popmotion.bounceInOut,\n    bounceOut: popmotion.bounceOut,\n};\nvar easingDefinitionToFunction = function (definition) {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        heyListen.invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n        var _a = tslib.__read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\n        return popmotion.cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        heyListen.invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n        return easingLookup[definition];\n    }\n    return definition;\n};\nvar isEasingArray = function (ease) {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nvar isAnimatable = function (key, value) {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        styleValueTypes.complex.test(value) && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\nvar underDampedSpring = function () { return ({\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10,\n}); };\nvar criticallyDampedSpring = function (to) { return ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n    restDelta: 0.01,\n    restSpeed: 10,\n}); };\nvar linearTween = function () { return ({\n    type: \"keyframes\",\n    ease: \"linear\",\n    duration: 0.3,\n}); };\nvar keyframes = function (values) { return ({\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values,\n}); };\nvar defaultTransitions = {\n    x: underDampedSpring,\n    y: underDampedSpring,\n    z: underDampedSpring,\n    rotate: underDampedSpring,\n    rotateX: underDampedSpring,\n    rotateY: underDampedSpring,\n    rotateZ: underDampedSpring,\n    scaleX: criticallyDampedSpring,\n    scaleY: criticallyDampedSpring,\n    scale: criticallyDampedSpring,\n    opacity: linearTween,\n    backgroundColor: linearTween,\n    color: linearTween,\n    default: criticallyDampedSpring,\n};\nvar getDefaultTransition = function (valueKey, to) {\n    var transitionFactory;\n    if (isKeyframesTarget(to)) {\n        transitionFactory = keyframes;\n    }\n    else {\n        transitionFactory =\n            defaultTransitions[valueKey] || defaultTransitions.default;\n    }\n    return tslib.__assign({ to: to }, transitionFactory(to));\n};\n\n/**\n * A map of default value types for common values\n */\nvar defaultValueTypes = tslib.__assign(tslib.__assign({}, numberValueTypes), { \n    // Color props\n    color: styleValueTypes.color, backgroundColor: styleValueTypes.color, outlineColor: styleValueTypes.color, fill: styleValueTypes.color, stroke: styleValueTypes.color, \n    // Border props\n    borderColor: styleValueTypes.color, borderTopColor: styleValueTypes.color, borderRightColor: styleValueTypes.color, borderBottomColor: styleValueTypes.color, borderLeftColor: styleValueTypes.color, filter: styleValueTypes.filter, WebkitFilter: styleValueTypes.filter });\n/**\n * Gets the default ValueType for the provided value key\n */\nvar getDefaultValueType = function (key) { return defaultValueTypes[key]; };\n\nfunction getAnimatableNone(key, value) {\n    var _a;\n    var defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== styleValueTypes.filter)\n        defaultValueType = styleValueTypes.complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined(_a) {\n    _a.when; _a.delay; _a.delayChildren; _a.staggerChildren; _a.staggerDirection; _a.repeat; _a.repeatType; _a.repeatDelay; _a.from; var transition = tslib.__rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n    return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\nfunction convertTransitionToAnimationOptions(_a) {\n    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = tslib.__rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n    var options = tslib.__assign({}, transition);\n    if (times)\n        options[\"offset\"] = times;\n    /**\n     * Convert any existing durations from seconds to milliseconds\n     */\n    if (transition.duration)\n        options[\"duration\"] = secondsToMilliseconds(transition.duration);\n    if (transition.repeatDelay)\n        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n    /**\n     * Map easing names to Popmotion's easing functions\n     */\n    if (ease) {\n        options[\"ease\"] = isEasingArray(ease)\n            ? ease.map(easingDefinitionToFunction)\n            : easingDefinitionToFunction(ease);\n    }\n    /**\n     * Support legacy transition API\n     */\n    if (transition.type === \"tween\")\n        options.type = \"keyframes\";\n    /**\n     * TODO: These options are officially removed from the API.\n     */\n    if (yoyo || loop || flip) {\n        heyListen.warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n        legacyRepeatWarning = true;\n        if (yoyo) {\n            options.repeatType = \"reverse\";\n        }\n        else if (loop) {\n            options.repeatType = \"loop\";\n        }\n        else if (flip) {\n            options.repeatType = \"mirror\";\n        }\n        options.repeat = loop || yoyo || flip || transition.repeat;\n    }\n    /**\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n     * It'd be good to introduce a similar thing here.\n     */\n    if (transition.type !== \"spring\")\n        options.type = \"keyframes\";\n    return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\nfunction getDelayFromTransition(transition, key) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key) || {};\n    return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;\n}\nfunction hydrateKeyframes(options) {\n    if (Array.isArray(options.to) && options.to[0] === null) {\n        options.to = tslib.__spreadArray([], tslib.__read(options.to));\n        options.to[0] = options.from;\n    }\n    return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n    var _a;\n    if (Array.isArray(options.to)) {\n        (_a = transition.duration) !== null && _a !== void 0 ? _a : (transition.duration = 0.8);\n    }\n    hydrateKeyframes(options);\n    /**\n     * Get a default transition if none is determined to be defined.\n     */\n    if (!isTransitionDefined(transition)) {\n        transition = tslib.__assign(tslib.__assign({}, transition), getDefaultTransition(key, options.to));\n    }\n    return tslib.__assign(tslib.__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key);\n    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n    var isTargetAnimatable = isAnimatable(key, target);\n    if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n        /**\n         * If we're trying to animate from \"none\", try and get an animatable version\n         * of the target. This could be improved to work both ways.\n         */\n        origin = getAnimatableNone(key, target);\n    }\n    else if (isZero(origin) && typeof target === \"string\") {\n        origin = getZeroUnit(target);\n    }\n    else if (!Array.isArray(target) &&\n        isZero(target) &&\n        typeof origin === \"string\") {\n        target = getZeroUnit(origin);\n    }\n    var isOriginAnimatable = isAnimatable(key, origin);\n    heyListen.warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n    function start() {\n        var options = {\n            from: origin,\n            to: target,\n            velocity: value.getVelocity(),\n            onComplete: onComplete,\n            onUpdate: function (v) { return value.set(v); },\n        };\n        return valueTransition.type === \"inertia\" ||\n            valueTransition.type === \"decay\"\n            ? popmotion.inertia(tslib.__assign(tslib.__assign({}, options), valueTransition))\n            : popmotion.animate(tslib.__assign(tslib.__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function (v) {\n                    var _a;\n                    options.onUpdate(v);\n                    (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n                }, onComplete: function () {\n                    var _a;\n                    options.onComplete();\n                    (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n                } }));\n    }\n    function set() {\n        var _a;\n        value.set(target);\n        onComplete();\n        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n        return { stop: function () { } };\n    }\n    return !isOriginAnimatable ||\n        !isTargetAnimatable ||\n        valueTransition.type === false\n        ? set\n        : start;\n}\nfunction isZero(value) {\n    return (value === 0 ||\n        (typeof value === \"string\" &&\n            parseFloat(value) === 0 &&\n            value.indexOf(\" \") === -1));\n}\nfunction getZeroUnit(potentialUnitType) {\n    return typeof potentialUnitType === \"number\"\n        ? 0\n        : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n *\n * @internal\n */\nfunction startAnimation(key, value, target, transition) {\n    if (transition === void 0) { transition = {}; }\n    return value.start(function (onComplete) {\n        var delayTimer;\n        var controls;\n        var animation = getAnimation(key, value, target, transition, onComplete);\n        var delay = getDelayFromTransition(transition, key);\n        var start = function () { return (controls = animation()); };\n        if (delay) {\n            delayTimer = setTimeout(start, secondsToMilliseconds(delay));\n        }\n        else {\n            start();\n        }\n        return function () {\n            clearTimeout(delayTimer);\n            controls === null || controls === void 0 ? void 0 : controls.stop();\n        };\n    });\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nvar isNumericalString = function (v) { return /^\\-?\\d*\\.?\\d+$/.test(v); };\n\nfunction addUniqueItem(arr, item) {\n    arr.indexOf(item) === -1 && arr.push(item);\n}\nfunction removeItem(arr, item) {\n    var index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nvar SubscriptionManager = /** @class */ (function () {\n    function SubscriptionManager() {\n        this.subscriptions = [];\n    }\n    SubscriptionManager.prototype.add = function (handler) {\n        var _this = this;\n        addUniqueItem(this.subscriptions, handler);\n        return function () { return removeItem(_this.subscriptions, handler); };\n    };\n    SubscriptionManager.prototype.notify = function (a, b, c) {\n        var numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (var i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                var handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    };\n    SubscriptionManager.prototype.getSize = function () {\n        return this.subscriptions.length;\n    };\n    SubscriptionManager.prototype.clear = function () {\n        this.subscriptions.length = 0;\n    };\n    return SubscriptionManager;\n}());\n\nvar isFloat = function (value) {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nvar MotionValue = /** @class */ (function () {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    function MotionValue(init) {\n        var _this = this;\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Functions to notify when the `MotionValue` updates.\n         *\n         * @internal\n         */\n        this.updateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the velocity updates.\n         *\n         * @internal\n         */\n        this.velocityUpdateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n         *\n         * @internal\n         */\n        this.renderSubscribers = new SubscriptionManager();\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        this.updateAndNotify = function (v, render) {\n            if (render === void 0) { render = true; }\n            _this.prev = _this.current;\n            _this.current = v;\n            // Update timestamp\n            var _a = sync.getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\n            if (_this.lastUpdated !== timestamp) {\n                _this.timeDelta = delta;\n                _this.lastUpdated = timestamp;\n                sync__default['default'].postRender(_this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (_this.prev !== _this.current) {\n                _this.updateSubscribers.notify(_this.current);\n            }\n            // Update velocity subscribers\n            if (_this.velocityUpdateSubscribers.getSize()) {\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n            // Update render subscribers\n            if (render) {\n                _this.renderSubscribers.notify(_this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = function () { return sync__default['default'].postRender(_this.velocityCheck); };\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = function (_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * @library\n     *\n     * ```jsx\n     * function MyComponent() {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <Frame x={x} />\n     * }\n     * ```\n     *\n     * @motion\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @internalremarks\n     *\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n     *\n     * ```jsx\n     * useOnChange(x, () => {})\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @public\n     */\n    MotionValue.prototype.onChange = function (subscription) {\n        return this.updateSubscribers.add(subscription);\n    };\n    MotionValue.prototype.clearListeners = function () {\n        this.updateSubscribers.clear();\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` requests a render.\n     *\n     * @param subscriber - A function that's provided the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @internal\n     */\n    MotionValue.prototype.onRenderRequest = function (subscription) {\n        // Render immediately\n        subscription(this.get());\n        return this.renderSubscribers.add(subscription);\n    };\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    MotionValue.prototype.attach = function (passiveEffect) {\n        this.passiveEffect = passiveEffect;\n    };\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    MotionValue.prototype.set = function (v, render) {\n        if (render === void 0) { render = true; }\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    };\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    MotionValue.prototype.get = function () {\n        return this.current;\n    };\n    /**\n     * @public\n     */\n    MotionValue.prototype.getPrevious = function () {\n        return this.prev;\n    };\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    MotionValue.prototype.getVelocity = function () {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                popmotion.velocityPerSecond(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    };\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    MotionValue.prototype.start = function (animation) {\n        var _this = this;\n        this.stop();\n        return new Promise(function (resolve) {\n            _this.hasAnimated = true;\n            _this.stopAnimation = animation(resolve);\n        }).then(function () { return _this.clearAnimation(); });\n    };\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    MotionValue.prototype.stop = function () {\n        if (this.stopAnimation)\n            this.stopAnimation();\n        this.clearAnimation();\n    };\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    MotionValue.prototype.isAnimating = function () {\n        return !!this.stopAnimation;\n    };\n    MotionValue.prototype.clearAnimation = function () {\n        this.stopAnimation = null;\n    };\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    MotionValue.prototype.destroy = function () {\n        this.updateSubscribers.clear();\n        this.renderSubscribers.clear();\n        this.stop();\n    };\n    return MotionValue;\n}());\n/**\n * @internal\n */\nfunction motionValue(init) {\n    return new MotionValue(init);\n}\n\n/**\n * Tests a provided value against a ValueType\n */\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\n\n/**\n * ValueType for \"auto\"\n */\nvar auto = {\n    test: function (v) { return v === \"auto\"; },\n    parse: function (v) { return v; },\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\nvar dimensionValueTypes = [styleValueTypes.number, styleValueTypes.px, styleValueTypes.percent, styleValueTypes.degrees, styleValueTypes.vw, styleValueTypes.vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nvar findDimensionValueType = function (v) {\n    return dimensionValueTypes.find(testValueType(v));\n};\n\n/**\n * A list of all ValueTypes\n */\nvar valueTypes = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(dimensionValueTypes)), [styleValueTypes.color, styleValueTypes.complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\nvar findValueType = function (v) { return valueTypes.find(testValueType(v)); };\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n    var _a = resolved\n        ? visualElement.makeTargetAnimatable(resolved, false)\n        : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b; _a.transition; var target = tslib.__rest(_a, [\"transitionEnd\", \"transition\"]);\n    target = tslib.__assign(tslib.__assign({}, target), transitionEnd);\n    for (var key in target) {\n        var value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    var reversedLabels = tslib.__spreadArray([], tslib.__read(variantLabels)).reverse();\n    reversedLabels.forEach(function (key) {\n        var _a;\n        var variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            setVariants(child, variantLabels);\n        });\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b, _c;\n    var _d;\n    var newValueKeys = Object.keys(target).filter(function (key) { return !visualElement.hasValue(key); });\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (var i = 0; i < numNewValues; i++) {\n        var key = newValueKeys[i];\n        var targetValue = target[key];\n        var value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === \"string\" && isNumericalString(value)) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && styleValueTypes.complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value));\n        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : (_d[key] = value);\n        visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    var _a, _b;\n    var origin = {};\n    for (var key in target) {\n        origin[key] =\n            (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n    }\n    return origin;\n}\n\n/**\n * @internal\n */\nfunction animateVisualElement(visualElement, definition, options) {\n    if (options === void 0) { options = {}; }\n    visualElement.notifyAnimationStart();\n    var animation;\n    if (Array.isArray(definition)) {\n        var animations = definition.map(function (variant) {\n            return animateVariant(visualElement, variant, options);\n        });\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        var resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(function () {\n        return visualElement.notifyAnimationComplete(definition);\n    });\n}\nfunction animateVariant(visualElement, variant, options) {\n    var _a;\n    if (options === void 0) { options = {}; }\n    var resolved = resolveVariant(visualElement, variant, options.custom);\n    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getAnimation = resolved\n        ? function () { return animateTarget(visualElement, resolved, options); }\n        : function () { return Promise.resolve(); };\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\n        ? function (forwardDelay) {\n            if (forwardDelay === void 0) { forwardDelay = 0; }\n            var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : function () { return Promise.resolve(); };\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    var when = transition.when;\n    if (when) {\n        var _c = tslib.__read(when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation], 2), first = _c[0], last = _c[1];\n        return first().then(last);\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\n    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = tslib.__rest(_e, [\"transition\", \"transitionEnd\"]);\n    if (transitionOverride)\n        transition = transitionOverride;\n    var animations = [];\n    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n    for (var key in target) {\n        var value = visualElement.getValue(key);\n        var valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        var animation = startAnimation(key, value, valueTarget, tslib.__assign({ delay: delay }, transition));\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(function () {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n    if (delayChildren === void 0) { delayChildren = 0; }\n    if (staggerChildren === void 0) { staggerChildren = 0; }\n    if (staggerDirection === void 0) { staggerDirection = 1; }\n    var animations = [];\n    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1\n        ? function (i) {\n            if (i === void 0) { i = 0; }\n            return i * staggerChildren;\n        }\n        : function (i) {\n            if (i === void 0) { i = 0; }\n            return maxStaggerDuration - i * staggerChildren;\n        };\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach(function (child, i) {\n        animations.push(animateVariant(child, variant, tslib.__assign(tslib.__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function () { return child.notifyAnimationComplete(variant); }));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.forEachValue(function (value) { return value.stop(); });\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(_a, key) {\n    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\n    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\n\nvar variantPriorityOrder = [\n    AnimationType.Animate,\n    AnimationType.Hover,\n    AnimationType.Tap,\n    AnimationType.Drag,\n    AnimationType.Focus,\n    AnimationType.Exit,\n];\nvar reversePriorityOrder = tslib.__spreadArray([], tslib.__read(variantPriorityOrder)).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return function (animations) {\n        return Promise.all(animations.map(function (_a) {\n            var animation = _a.animation, options = _a.options;\n            return animateVisualElement(visualElement, animation, options);\n        }));\n    };\n}\nfunction createAnimationState(visualElement) {\n    var animate = animateList(visualElement);\n    var state = createState();\n    var allAnimatedKeys = {};\n    var isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    var buildResolvedTypeValues = function (acc, definition) {\n        var resolved = resolveVariant(visualElement, definition);\n        if (resolved) {\n            resolved.transition; var transitionEnd = resolved.transitionEnd, target = tslib.__rest(resolved, [\"transition\", \"transitionEnd\"]);\n            acc = tslib.__assign(tslib.__assign(tslib.__assign({}, acc), target), transitionEnd);\n        }\n        return acc;\n    };\n    function isAnimated(key) {\n        return allAnimatedKeys[key] !== undefined;\n    }\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(options, changedActiveType) {\n        var _a;\n        var props = visualElement.getProps();\n        var context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        var animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        var removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        var encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        var removedVariantIndex = Infinity;\n        var _loop_1 = function (i) {\n            var type = reversePriorityOrder[i];\n            var typeState = state[type];\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n            var propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            var activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = tslib.__assign({}, encounteredKeys);\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                return \"continue\";\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            var definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\n            var allKeys = tslib.__assign(tslib.__assign({}, prevResolvedValues), resolvedValues);\n            var markToAnimate = function (key) {\n                shouldAnimateType = true;\n                removedKeys.delete(key);\n                typeState.needsAnimating[key] = true;\n            };\n            for (var key in allKeys) {\n                var next = resolvedValues[key];\n                var prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                if (next !== prev) {\n                    /**\n                     * If both values are keyframes, we need to shallow compare them to\n                     * detect whether any value has changed. If it has, we animate it.\n                     */\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                        if (!shallowCompare(next, prev)) {\n                            markToAnimate(key);\n                        }\n                        else {\n                            /**\n                             * If it hasn't changed, we want to ensure it doesn't animate by\n                             * adding it to the list of protected keys.\n                             */\n                            typeState.protectedKeys[key] = true;\n                        }\n                    }\n                    else if (next !== undefined) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = tslib.__assign(tslib.__assign({}, encounteredKeys), resolvedValues);\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             * TODO: Test as this should probably still handle animations triggered\n             * by removed values?\n             */\n            if (shouldAnimateType && !isInherited) {\n                animations.push.apply(animations, tslib.__spreadArray([], tslib.__read(definitionList.map(function (animation) { return ({\n                    animation: animation,\n                    options: tslib.__assign({ type: type }, options),\n                }); }))));\n            }\n        };\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (var i = 0; i < numAnimationTypes; i++) {\n            _loop_1(i);\n        }\n        allAnimatedKeys = tslib.__assign({}, encounteredKeys);\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            var fallbackAnimation_1 = {};\n            removedKeys.forEach(function (key) {\n                var fallbackTarget = visualElement.getBaseTarget(key);\n                if (fallbackTarget !== undefined) {\n                    fallbackAnimation_1[key] = fallbackTarget;\n                }\n            });\n            animations.push({ animation: fallbackAnimation_1 });\n        }\n        var shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            props.initial === false &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive, options) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        return animateChanges(options, type);\n    }\n    return {\n        isAnimated: isAnimated,\n        animateChanges: animateChanges,\n        setActive: setActive,\n        setAnimateFunction: setAnimateFunction,\n        getState: function () { return state; },\n    };\n}\nfunction variantsHaveChanged(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (isVariantLabels(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive) {\n    if (isActive === void 0) { isActive = false; }\n    return {\n        isActive: isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    var _a;\n    return _a = {},\n        _a[AnimationType.Animate] = createTypeState(true),\n        _a[AnimationType.Hover] = createTypeState(),\n        _a[AnimationType.Tap] = createTypeState(),\n        _a[AnimationType.Drag] = createTypeState(),\n        _a[AnimationType.Focus] = createTypeState(),\n        _a[AnimationType.Exit] = createTypeState(),\n        _a;\n}\n\nvar animations = {\n    animation: makeRenderlessComponent(function (_a) {\n        var visualElement = _a.visualElement, animate = _a.animate;\n        /**\n         * We dynamically generate the AnimationState manager as it contains a reference\n         * to the underlying animation library. We only want to load that if we load this,\n         * so people can optionally code split it out using the `m` component.\n         */\n        visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n        /**\n         * Subscribe any provided AnimationControls to the component's VisualElement\n         */\n        if (isAnimationControls(animate)) {\n            React.useEffect(function () { return animate.subscribe(visualElement); }, [animate]);\n        }\n    }),\n    exit: makeRenderlessComponent(function (props) {\n        var custom = props.custom, visualElement = props.visualElement;\n        var _a = tslib.__read(usePresence(), 2), isPresent = _a[0], onExitComplete = _a[1];\n        var presenceContext = React.useContext(PresenceContext);\n        React.useEffect(function () {\n            var _a, _b;\n            var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });\n            !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(onExitComplete));\n        }, [isPresent]);\n    }),\n};\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = popmotion.distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = sync.getFrameData().timestamp;\n            _this.history.push(tslib.__assign(tslib.__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function (event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync__default['default'].update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function (event, info) {\n            _this.end();\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            if (_this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = sync.getFrameData().timestamp;\n        this.history = [tslib.__assign(tslib.__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = popmotion.pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        sync.cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nfunction noop(any) {\n    return any;\n}\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToAxisBox(_a) {\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertAxisBoxToBoundingBox(_a) {\n    var x = _a.x, y = _a.y;\n    return {\n        top: y.min,\n        bottom: y.max,\n        left: x.min,\n        right: x.max,\n    };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoundingBox(_a, transformPoint) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    if (transformPoint === void 0) { transformPoint = noop; }\n    var topLeft = transformPoint({ x: left, y: top });\n    var bottomRight = transformPoint({ x: right, y: bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n/**\n * Create an empty axis box of zero size\n */\nfunction axisBox() {\n    return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };\n}\nfunction copyAxisBox(box) {\n    return {\n        x: tslib.__assign({}, box.x),\n        y: tslib.__assign({}, box.y),\n    };\n}\n/**\n * Create an empty box delta\n */\nvar zeroDelta = {\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n};\nfunction delta() {\n    return {\n        x: tslib.__assign({}, zeroDelta),\n        y: tslib.__assign({}, zeroDelta),\n    };\n}\n\n// Call a handler once for each axis\nfunction eachAxis(handler) {\n    return [handler(\"x\"), handler(\"y\")];\n}\n\nvar clampProgress = function (v) { return popmotion.clamp(0, 1, v); };\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) { target = 0; }\n    if (maxDistance === void 0) { maxDistance = 0.01; }\n    return popmotion.distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = calcLength(source);\n    var targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = popmotion.progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = popmotion.progress(source.min, source.max - targetLength, target.min);\n    }\n    return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n    if (origin === void 0) { origin = 0.5; }\n    delta.origin = origin;\n    delta.originPoint = popmotion.mix(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    if (isNear(delta.scale, 1, 0.0001))\n        delta.scale = 1;\n    delta.translate =\n        popmotion.mix(target.min, target.max, delta.origin) - delta.originPoint;\n    if (isNear(delta.translate))\n        delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\nfunction defaultOrigin(origin) {\n    return typeof origin === \"number\" ? origin : 0.5;\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(projection, parentProjection) {\n    calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n    calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _a, elastic) {\n    var min = _a.min, max = _a.max;\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(min, point, elastic.min) : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n    // Calculate a min point for this axis and apply it to the current pointer\n    var min = point - length * progress;\n    return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _a) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    var _a;\n    var min = constraintsAxis.min - layoutAxis.min;\n    var max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        _a = tslib.__read([max, min], 2), min = _a[0], max = _a[1];\n    }\n    return {\n        min: layoutAxis.min + min,\n        max: layoutAxis.min + max,\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\nfunction calcPositionFromProgress(axis, constraints, progress) {\n    var axisLength = axis.max - axis.min;\n    var min = popmotion.mix(constraints.min, constraints.max - axisLength, progress);\n    return { min: min, max: min + axisLength };\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    var relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    var _a;\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\nfunction getBoundingBox(element, transformPagePoint) {\n    var box = element.getBoundingClientRect();\n    return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n\nvar compareByDepth = function (a, b) {\n    return a.depth - b.depth;\n};\n\nfunction isProjecting(visualElement) {\n    var isEnabled = visualElement.projection.isEnabled;\n    return isEnabled || visualElement.shouldResetTransform();\n}\nfunction collectProjectingAncestors(visualElement, ancestors) {\n    if (ancestors === void 0) { ancestors = []; }\n    var parent = visualElement.parent;\n    if (parent)\n        collectProjectingAncestors(parent, ancestors);\n    if (isProjecting(visualElement))\n        ancestors.push(visualElement);\n    return ancestors;\n}\nfunction collectProjectingChildren(visualElement) {\n    var children = [];\n    var addChild = function (child) {\n        if (isProjecting(child))\n            children.push(child);\n        child.children.forEach(addChild);\n    };\n    visualElement.children.forEach(addChild);\n    return children.sort(compareByDepth);\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    var layoutState = visualElement.getLayoutState();\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n    layoutState.isHydrated = true;\n    layoutState.layout = visualElement.measureViewportBox();\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n    sync__default['default'].update(function () { return visualElement.rebaseProjectionTarget(); });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nfunction tweenAxis(target, prev, next, p) {\n    target.min = popmotion.mix(prev.min, next.min, p);\n    target.max = popmotion.mix(prev.max, next.max, p);\n}\nfunction calcRelativeOffsetAxis(parent, child) {\n    return {\n        min: child.min - parent.min,\n        max: child.max - parent.min,\n    };\n}\nfunction calcRelativeOffset(parent, child) {\n    return {\n        x: calcRelativeOffsetAxis(parent.x, child.x),\n        y: calcRelativeOffsetAxis(parent.y, child.y),\n    };\n}\nfunction checkIfParentHasChanged(prev, next) {\n    var prevId = prev.getLayoutId();\n    var nextId = next.getLayoutId();\n    return prevId !== nextId || (nextId === undefined && prev !== next);\n}\n\nfunction isDraggable(visualElement) {\n    var _a = visualElement.getProps(), drag = _a.drag, _dragX = _a._dragX;\n    return drag && !_dragX;\n}\n\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetAxis(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetBox(box, originBox) {\n    resetAxis(box.x, originBox.x);\n    resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, _a) {\n    var x = _a.x, y = _a.y;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    // Copy the current axis to the final axis before mutation\n    final.min = axis.min;\n    final.max = axis.max;\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    var originPoint = popmotion.mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction applyBoxTransforms(finalBox, box, transforms) {\n    applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n    applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    if (origin === void 0) { origin = 0.5; }\n    var originPoint = popmotion.mix(axis.min, axis.max, origin) - translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, _a) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms) {\n    removeAxisTransforms(box.x, transforms, xKeys);\n    removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath) {\n    var treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    var node;\n    var delta;\n    for (var i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.getLayoutState().delta;\n        // Incoporate each ancestor's scale into a culmulative treeScale for this component\n        treeScale.x *= delta.x.scale;\n        treeScale.y *= delta.y.scale;\n        // Apply each ancestor's calculated delta into this component's recorded layout box\n        applyBoxDelta(box, delta);\n        // If this is a draggable ancestor, also incorporate the node's transform to the layout box\n        if (isDraggable(node)) {\n            applyBoxTransforms(box, box, node.getLatestValues());\n        }\n    }\n}\n\n/**\n * Returns a boolean stating whether or not we converted the projection\n * to relative projection.\n */\nfunction convertToRelativeProjection(visualElement, isLayoutDrag) {\n    if (isLayoutDrag === void 0) { isLayoutDrag = true; }\n    var projectionParent = visualElement.getProjectionParent();\n    if (!projectionParent)\n        return false;\n    var offset;\n    if (isLayoutDrag) {\n        offset = calcRelativeOffset(projectionParent.projection.target, visualElement.projection.target);\n        removeBoxTransforms(offset, projectionParent.getLatestValues());\n    }\n    else {\n        offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n    }\n    eachAxis(function (axis) {\n        return visualElement.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);\n    });\n    return true;\n}\n\nvar unresolvedJobs = new Set();\nfunction pushJob(stack, job, pointer) {\n    if (!stack[pointer])\n        stack[pointer] = [];\n    stack[pointer].push(job);\n}\nfunction batchLayout(callback) {\n    unresolvedJobs.add(callback);\n    return function () { return unresolvedJobs.delete(callback); };\n}\nfunction flushLayout() {\n    if (!unresolvedJobs.size)\n        return;\n    var pointer = 0;\n    var reads = [[]];\n    var writes = [];\n    var setRead = function (job) { return pushJob(reads, job, pointer); };\n    var setWrite = function (job) {\n        pushJob(writes, job, pointer);\n        pointer++;\n    };\n    /**\n     * Resolve jobs into their array stacks\n     */\n    unresolvedJobs.forEach(function (callback) {\n        callback(setRead, setWrite);\n        pointer = 0;\n    });\n    unresolvedJobs.clear();\n    /**\n     * Execute jobs\n     */\n    var numStacks = writes.length;\n    for (var i = 0; i <= numStacks; i++) {\n        reads[i] && reads[i].forEach(executeJob);\n        writes[i] && writes[i].forEach(executeJob);\n    }\n}\nvar executeJob = function (job) { return job(); };\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\nvar lastPointerEvent;\nvar VisualElementDragControls = /** @class */ (function () {\n    function VisualElementDragControls(_a) {\n        var visualElement = _a.visualElement;\n        /**\n         * Track whether we're currently dragging.\n         *\n         * @internal\n         */\n        this.isDragging = false;\n        /**\n         * The current direction of drag, or `null` if both.\n         *\n         * @internal\n         */\n        this.currentDirection = null;\n        /**\n         * The permitted boundaries of travel, in pixels.\n         *\n         * @internal\n         */\n        this.constraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         *\n         * @internal\n         */\n        this.elastic = axisBox();\n        /**\n         * A reference to the host component's latest props.\n         *\n         * @internal\n         */\n        this.props = {};\n        /**\n         * @internal\n         */\n        this.hasMutatedConstraints = false;\n        /**\n         * Track the initial position of the cursor relative to the dragging element\n         * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n         * an ideal bounding box for the VisualElement renderer to project into every frame.\n         *\n         * @internal\n         */\n        this.cursorProgress = {\n            x: 0.5,\n            y: 0.5,\n        };\n        // When updating _dragX, or _dragY instead of the VisualElement,\n        // persist their values between drag gestures.\n        this.originPoint = {};\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        /**\n         * @internal\n         */\n        this.panSession = null;\n        this.visualElement = visualElement;\n        this.visualElement.enableLayoutProjection();\n        elementDragControls.set(visualElement, this);\n    }\n    /**\n     * Instantiate a PanSession for the drag gesture\n     *\n     * @public\n     */\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;\n        var onSessionStart = function (event) {\n            var _a;\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopMotion();\n            /**\n             * Save the initial point. We'll use this to calculate the pointer's position rather\n             * than the one we receive when the gesture actually starts. By then, the pointer will\n             * have already moved, and the perception will be of the pointer \"slipping\" across the element\n             */\n            var initialPoint = getViewportPointFromEvent(event).point;\n            (_a = _this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(_this);\n            _this.cancelLayout = batchLayout(function (read, write) {\n                var ancestors = collectProjectingAncestors(_this.visualElement);\n                var children = collectProjectingChildren(_this.visualElement);\n                var tree = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(children));\n                var hasManuallySetCursorOrigin = false;\n                /**\n                 * Apply a simple lock to the projection target. This ensures no animations\n                 * can run on the projection box while this lock is active.\n                 */\n                _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();\n                write(function () {\n                    tree.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    updateLayoutMeasurement(_this.visualElement);\n                    children.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    tree.forEach(function (element) { return element.restoreTransform(); });\n                    if (snapToCursor) {\n                        hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);\n                    }\n                });\n                read(function () {\n                    var isRelativeDrag = Boolean(_this.getAxisMotionValue(\"x\") && !_this.isExternalDrag());\n                    if (!isRelativeDrag) {\n                        _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));\n                    }\n                    _this.visualElement.scheduleUpdateLayoutProjection();\n                    /**\n                     * When dragging starts, we want to find where the cursor is relative to the bounding box\n                     * of the element. Every frame, we calculate a new bounding box using this relative position\n                     * and let the visualElement renderer figure out how to reproject the element into this bounding\n                     * box.\n                     *\n                     * By doing it this way, rather than applying an x/y transform directly to the element,\n                     * we can ensure the component always visually sticks to the cursor as we'd expect, even\n                     * if the DOM element itself changes layout as a result of React updates the user might\n                     * make based on the drag position.\n                     */\n                    var projection = _this.visualElement.projection;\n                    eachAxis(function (axis) {\n                        if (!hasManuallySetCursorOrigin) {\n                            var _a = projection.target[axis], min = _a.min, max = _a.max;\n                            _this.cursorProgress[axis] = cursorProgress\n                                ? cursorProgress[axis]\n                                : popmotion.progress(min, max, initialPoint[axis]);\n                        }\n                        /**\n                         * If we have external drag MotionValues, record their origin point. On pointermove\n                         * we'll apply the pan gesture offset directly to this value.\n                         */\n                        var axisValue = _this.getAxisMotionValue(axis);\n                        if (axisValue) {\n                            _this.originPoint[axis] = axisValue.get();\n                        }\n                    });\n                });\n                write(function () {\n                    sync.flushSync.update();\n                    sync.flushSync.preRender();\n                    sync.flushSync.render();\n                    sync.flushSync.postRender();\n                });\n                read(function () { return _this.resolveDragConstraints(); });\n            });\n        };\n        var onStart = function (event, info) {\n            var _a, _b, _c;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _d = _this.props, drag = _d.drag, dragPropagation = _d.dragPropagation;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock)\n                    _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!_this.openGlobalLock)\n                    return;\n            }\n            flushLayout();\n            // Set current drag status\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            // Fire onDragStart event\n            (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n            (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);\n        };\n        var onMove = function (event, info) {\n            var _a, _b, _c, _d;\n            var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock)\n                return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis(\"x\", info.point, offset);\n            _this.updateAxis(\"y\", info.point, offset);\n            // Fire onDrag event\n            (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n            // Update the last pointer event\n            lastPointerEvent = event;\n        };\n        var onSessionEnd = function (event, info) {\n            return _this.stop(event, info);\n        };\n        var transformPagePoint = this.props.transformPagePoint;\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onSessionEnd: onSessionEnd,\n        }, { transformPagePoint: transformPagePoint });\n    };\n    VisualElementDragControls.prototype.resolveDragConstraints = function () {\n        var _this = this;\n        var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n        var layout = this.visualElement.getLayoutState().layoutCorrected;\n        if (dragConstraints) {\n            this.constraints = isRefObject(dragConstraints)\n                ? this.resolveRefConstraints(layout, dragConstraints)\n                : calcRelativeConstraints(layout, dragConstraints);\n        }\n        else {\n            this.constraints = false;\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (this.constraints && !this.hasMutatedConstraints) {\n            eachAxis(function (axis) {\n                if (_this.getAxisMotionValue(axis)) {\n                    _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);\n                }\n            });\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n        var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\n        var constraintsElement = constraints.current;\n        heyListen.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n        var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.cancelDrag = function () {\n        var _a, _b;\n        this.visualElement.unlockProjectionTarget();\n        (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);\n        this.isDragging = false;\n        this.panSession && this.panSession.end();\n        this.panSession = null;\n        if (!this.props.dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n    };\n    VisualElementDragControls.prototype.stop = function (event, info) {\n        var _a, _b, _c;\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = null;\n        var isDragging = this.isDragging;\n        this.cancelDrag();\n        if (!isDragging)\n            return;\n        var velocity = info.velocity;\n        this.animateDragEnd(velocity);\n        (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function (point) {\n        var _this = this;\n        return eachAxis(function (axis) {\n            var drag = _this.props.drag;\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, _this.currentDirection))\n                return;\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n                var box = _this.visualElement.getLayoutState().layout;\n                var length_1 = box[axis].max - box[axis].min;\n                var center = box[axis].min + length_1 / 2;\n                var offset = point[axis] - center;\n                _this.originPoint[axis] = point[axis];\n                axisValue.set(offset);\n            }\n            else {\n                _this.cursorProgress[axis] = 0.5;\n                return true;\n            }\n        }).includes(true);\n    };\n    /**\n     * Update the specified axis with the latest pointer information.\n     */\n    VisualElementDragControls.prototype.updateAxis = function (axis, point, offset) {\n        var drag = this.props.drag;\n        // If we're not dragging this axis, do an early return.\n        if (!shouldDrag(axis, drag, this.currentDirection))\n            return;\n        return this.getAxisMotionValue(axis)\n            ? this.updateAxisMotionValue(axis, offset)\n            : this.updateVisualElementAxis(axis, point);\n    };\n    VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!offset || !axisValue)\n            return;\n        var nextValue = this.originPoint[axis] + offset[axis];\n        var update = this.constraints\n            ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis])\n            : nextValue;\n        axisValue.set(update);\n    };\n    VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, point) {\n        var _a;\n        // Get the actual layout bounding box of the element\n        var axisLayout = this.visualElement.getLayoutState().layout[axis];\n        // Calculate its current length. In the future we might want to lerp this to animate\n        // between lengths if the layout changes as we change the DOM\n        var axisLength = axisLayout.max - axisLayout.min;\n        // Get the initial progress that the pointer sat on this axis on gesture start.\n        var axisProgress = this.cursorProgress[axis];\n        // Calculate a new min point based on the latest pointer position, constraints and elastic\n        var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);\n        // Update the axis viewport target with this new min and the length\n        this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\n    };\n    VisualElementDragControls.prototype.setProps = function (_a) {\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = tslib.__rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n        this.props = tslib.__assign({ drag: drag,\n            dragDirectionLock: dragDirectionLock,\n            dragPropagation: dragPropagation,\n            dragConstraints: dragConstraints,\n            dragElastic: dragElastic,\n            dragMomentum: dragMomentum }, remainingProps);\n    };\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - If the component will perform layout animations, we output the gesture to the component's\n     *      visual bounding box\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n        var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;\n        var dragKey = \"_drag\" + axis.toUpperCase();\n        if (this.props[dragKey]) {\n            return this.props[dragKey];\n        }\n        else if (!layout && layoutId === undefined) {\n            return this.visualElement.getValue(axis, 0);\n        }\n    };\n    VisualElementDragControls.prototype.isLayoutDrag = function () {\n        return !this.getAxisMotionValue(\"x\");\n    };\n    VisualElementDragControls.prototype.isExternalDrag = function () {\n        var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;\n        return _dragX || _dragY;\n    };\n    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;\n        /**\n         * Everything beyond the drag gesture should be performed with\n         * relative projection so children stay in sync with their parent element.\n         */\n        var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());\n        /**\n         * If we had previously resolved constraints relative to the viewport,\n         * we need to also convert those to a relative coordinate space for the animation\n         */\n        var constraints = this.constraints || {};\n        if (isRelative &&\n            Object.keys(constraints).length &&\n            this.isLayoutDrag()) {\n            var projectionParent = this.visualElement.getProjectionParent();\n            if (projectionParent) {\n                var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);\n                eachAxis(function (axis) {\n                    var _a = relativeConstraints_1[axis], min = _a.min, max = _a.max;\n                    constraints[axis] = {\n                        min: isNaN(min) ? undefined : min,\n                        max: isNaN(max) ? undefined : max,\n                    };\n                });\n            }\n        }\n        var momentumAnimations = eachAxis(function (axis) {\n            var _a;\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = tslib.__assign(tslib.__assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.getAxisMotionValue(axis)\n                ? _this.startAxisValueAnimation(axis, inertia)\n                : _this.visualElement.startLayoutAnimation(axis, inertia, isRelative);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(function () {\n            var _a, _b;\n            (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n    };\n    VisualElementDragControls.prototype.stopMotion = function () {\n        var _this = this;\n        eachAxis(function (axis) {\n            var axisValue = _this.getAxisMotionValue(axis);\n            axisValue\n                ? axisValue.stop()\n                : _this.visualElement.stopLayoutAnimation();\n        });\n    };\n    VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!axisValue)\n            return;\n        var currentValue = axisValue.get();\n        axisValue.set(currentValue);\n        axisValue.set(currentValue); // Set twice to hard-reset velocity\n        return startAnimation(axis, axisValue, 0, transition);\n    };\n    VisualElementDragControls.prototype.scalePoint = function () {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;\n        if (!isRefObject(dragConstraints) || !this.constraintsBox)\n            return;\n        // Stop any current animations as there can be some visual glitching if we resize mid animation\n        this.stopMotion();\n        // Record the relative progress of the targetBox relative to the constraintsBox\n        var boxProgress = { x: 0, y: 0 };\n        eachAxis(function (axis) {\n            boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\n        });\n        /**\n         * For each axis, calculate the current progress of the layout axis within the constraints.\n         * Then, using the latest layout and constraints measurements, reposition the new layout axis\n         * proportionally within the constraints.\n         */\n        this.updateConstraints(function () {\n            eachAxis(function (axis) {\n                if (!shouldDrag(axis, drag, null))\n                    return;\n                // Calculate the position of the targetBox relative to the constraintsBox using the\n                // previously calculated progress\n                var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a.min, max = _a.max;\n                _this.visualElement.setProjectionTargetAxis(axis, min, max);\n            });\n        });\n        /**\n         * If any other draggable components are queuing the same tasks synchronously\n         * this will wait until they've all been scheduled before flushing.\n         */\n        setTimeout(flushLayout, 1);\n    };\n    VisualElementDragControls.prototype.updateConstraints = function (onReady) {\n        var _this = this;\n        this.cancelLayout = batchLayout(function (read, write) {\n            var ancestors = collectProjectingAncestors(_this.visualElement);\n            write(function () {\n                return ancestors.forEach(function (element) { return element.resetTransform(); });\n            });\n            read(function () { return updateLayoutMeasurement(_this.visualElement); });\n            write(function () {\n                return ancestors.forEach(function (element) { return element.restoreTransform(); });\n            });\n            read(function () {\n                _this.resolveDragConstraints();\n            });\n            if (onReady)\n                write(onReady);\n        });\n    };\n    VisualElementDragControls.prototype.mount = function (visualElement) {\n        var _this = this;\n        var element = visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\n            _this.scalePoint();\n        });\n        /**\n         * Ensure drag constraints are resolved correctly relative to the dragging element\n         * whenever its layout changes.\n         */\n        var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n            if (_this.isDragging) {\n                _this.resolveDragConstraints();\n            }\n        });\n        /**\n         * If the previous component with this same layoutId was dragging at the time\n         * it was unmounted, we want to continue the same gesture on this component.\n         */\n        var prevDragCursor = visualElement.prevDragCursor;\n        if (prevDragCursor) {\n            this.start(lastPointerEvent, { cursorProgress: prevDragCursor });\n        }\n        /**\n         * Return a function that will teardown the drag gesture\n         */\n        return function () {\n            stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n            stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n            stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n            _this.cancelDrag();\n        };\n    };\n    return VisualElementDragControls;\n}());\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) { lockThreshold = 10; }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\nfunction useDrag(props) {\n    var groupDragControls = props.dragControls, visualElement = props.visualElement;\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n    var dragControls = useConstant(function () {\n        return new VisualElementDragControls({\n            visualElement: visualElement,\n        });\n    });\n    dragControls.setProps(tslib.__assign(tslib.__assign({}, props), { transformPagePoint: transformPagePoint }));\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    React.useEffect(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\n    // Mount the drag controls with the visualElement\n    React.useEffect(function () { return dragControls.mount(visualElement); }, []);\n}\n\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\nfunction usePanGesture(_a) {\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement = _a.visualElement;\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n    var panSession = React.useRef(null);\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n    var handlers = {\n        onSessionStart: onPanSessionStart,\n        onStart: onPanStart,\n        onMove: onPan,\n        onEnd: function (event, info) {\n            panSession.current = null;\n            onPanEnd && onPanEnd(event, info);\n        },\n    };\n    React.useEffect(function () {\n        if (panSession.current !== null) {\n            panSession.current.updateHandlers(handlers);\n        }\n    });\n    function onPointerDown(event) {\n        panSession.current = new PanSession(event, handlers, {\n            transformPagePoint: transformPagePoint,\n        });\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\n}\n\nvar drag = {\n    pan: makeRenderlessComponent(usePanGesture),\n    drag: makeRenderlessComponent(useDrag),\n};\n\n/**\n * @public\n */\nvar Presence;\n(function (Presence) {\n    Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n    Presence[Presence[\"Present\"] = 1] = \"Present\";\n    Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n/**\n * @public\n */\nexports.VisibilityAction = void 0;\n(function (VisibilityAction) {\n    VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n    VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(exports.VisibilityAction || (exports.VisibilityAction = {}));\n\nfunction isCSSVariable(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    var _a = tslib.__read(match, 3), token = _a[1], fallback = _a[2];\n    return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) { depth = 1; }\n    heyListen.invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n    var _a = tslib.__read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    }\n    else if (isCSSVariable(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var _b;\n    var target = tslib.__rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof HTMLElement))\n        return { target: target, transitionEnd: transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = tslib.__assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function (value) {\n        var current = value.get();\n        if (!isCSSVariable(current))\n            return;\n        var resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (var key in target) {\n        var current = target[key];\n        if (!isCSSVariable(current))\n            continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd)\n            (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : (transitionEnd[key] = current);\n    }\n    return { target: target, transitionEnd: transitionEnd };\n}\n\nfunction pixelsToPercent(pixels, axis) {\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nfunction correctBorderRadius(latest, _layoutState, _a) {\n    var target = _a.target;\n    /**\n     * If latest is a string, if it's a percentage we can return immediately as it's\n     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n     */\n    if (typeof latest === \"string\") {\n        if (styleValueTypes.px.test(latest)) {\n            latest = parseFloat(latest);\n        }\n        else {\n            return latest;\n        }\n    }\n    /**\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n     * pixel value as a percentage of each axis\n     */\n    var x = pixelsToPercent(latest, target.x);\n    var y = pixelsToPercent(latest, target.y);\n    return x + \"% \" + y + \"%\";\n}\nvar varToken = \"_$css\";\nfunction correctBoxShadow(latest, _a) {\n    var delta = _a.delta, treeScale = _a.treeScale;\n    var original = latest;\n    /**\n     * We need to first strip and store CSS variables from the string.\n     */\n    var containsCSSVariables = latest.includes(\"var(\");\n    var cssVariables = [];\n    if (containsCSSVariables) {\n        latest = latest.replace(cssVariableRegex, function (match) {\n            cssVariables.push(match);\n            return varToken;\n        });\n    }\n    var shadow = styleValueTypes.complex.parse(latest);\n    // TODO: Doesn't support multiple shadows\n    if (shadow.length > 5)\n        return original;\n    var template = styleValueTypes.complex.createTransformer(latest);\n    var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    // Calculate the overall context scale\n    var xScale = delta.x.scale * treeScale.x;\n    var yScale = delta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n    var averageScale = popmotion.mix(xScale, yScale, 0.5);\n    // Blur\n    if (typeof shadow[2 + offset] === \"number\")\n        shadow[2 + offset] /= averageScale;\n    // Spread\n    if (typeof shadow[3 + offset] === \"number\")\n        shadow[3 + offset] /= averageScale;\n    var output = template(shadow);\n    if (containsCSSVariables) {\n        var i_1 = 0;\n        output = output.replace(varToken, function () {\n            var cssVariable = cssVariables[i_1];\n            i_1++;\n            return cssVariable;\n        });\n    }\n    return output;\n}\nvar borderCorrectionDefinition = {\n    process: correctBorderRadius,\n};\nvar defaultScaleCorrectors = {\n    borderRadius: tslib.__assign(tslib.__assign({}, borderCorrectionDefinition), { applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ] }),\n    borderTopLeftRadius: borderCorrectionDefinition,\n    borderTopRightRadius: borderCorrectionDefinition,\n    borderBottomLeftRadius: borderCorrectionDefinition,\n    borderBottomRightRadius: borderCorrectionDefinition,\n    boxShadow: {\n        process: correctBoxShadow,\n    },\n};\n\nvar progressTarget = 1000;\nvar Animate = /** @class */ (function (_super) {\n    tslib.__extends(Animate, _super);\n    function Animate() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A mutable object that tracks the target viewport box\n         * for the current animation frame.\n         */\n        _this.frameTarget = axisBox();\n        /**\n         * The current animation target, we use this to check whether to start\n         * a new animation or continue the existing one.\n         */\n        _this.currentAnimationTarget = axisBox();\n        /**\n         * Track whether we're animating this axis.\n         */\n        _this.isAnimating = {\n            x: false,\n            y: false,\n        };\n        _this.stopAxisAnimation = {\n            x: undefined,\n            y: undefined,\n        };\n        _this.isAnimatingTree = false;\n        _this.animate = function (target, origin, _a) {\n            if (_a === void 0) { _a = {}; }\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, prevParent = _a.prevParent, config = tslib.__rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\", \"prevParent\"]);\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\n            /**\n             * Early return if we've been instructed not to animate this render.\n             */\n            if (shouldStackAnimate === false) {\n                _this.isAnimatingTree = false;\n                return _this.safeToRemove();\n            }\n            /**\n             * Prioritise tree animations\n             */\n            if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n                return;\n            }\n            else if (shouldStackAnimate) {\n                _this.isAnimatingTree = true;\n            }\n            /**\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\n             * overridden by the provided config.\n             */\n            origin = originBox || origin;\n            target = targetBox || target;\n            /**\n             * If this element has a projecting parent, there's an opportunity to animate\n             * it relatively to that parent rather than relatively to the viewport. This\n             * allows us to add orchestrated animations.\n             */\n            var isRelative = false;\n            var projectionParent = visualElement.getProjectionParent();\n            if (projectionParent) {\n                var prevParentViewportBox = projectionParent.prevViewportBox;\n                var parentLayout = projectionParent.getLayoutState().layout;\n                /**\n                 * If we're being provided a previous parent VisualElement by AnimateSharedLayout\n                 */\n                if (prevParent) {\n                    /**\n                     * If we've been provided an explicit target box it means we're animating back\n                     * to this previous parent. So we can make a relative box by comparing to the previous\n                     * parent's layout\n                     */\n                    if (targetBox) {\n                        parentLayout = prevParent.getLayoutState().layout;\n                    }\n                    /**\n                     * Likewise if we've been provided an explicit origin box it means we're\n                     * animating out from a different element. So we should figure out where that was\n                     * on screen relative to the new parent element.\n                     */\n                    if (originBox &&\n                        !checkIfParentHasChanged(prevParent, projectionParent) &&\n                        prevParent.prevViewportBox) {\n                        prevParentViewportBox = prevParent.prevViewportBox;\n                    }\n                }\n                if (prevParentViewportBox &&\n                    isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\n                    isRelative = true;\n                    origin = calcRelativeOffset(prevParentViewportBox, origin);\n                    target = calcRelativeOffset(parentLayout, target);\n                }\n            }\n            var boxHasMoved = hasMoved(origin, target);\n            var animations = eachAxis(function (axis) {\n                var _a, _b;\n                /**\n                 * If layout is set to \"position\", we can resize the origin box based on the target\n                 * box and only animate its position.\n                 */\n                if (layout === \"position\") {\n                    var targetLength = target[axis].max - target[axis].min;\n                    origin[axis].max = origin[axis].min + targetLength;\n                }\n                if (visualElement.projection.isTargetLocked) {\n                    return;\n                }\n                else if (visibilityAction !== undefined) {\n                    visualElement.setVisibility(visibilityAction === exports.VisibilityAction.Show);\n                }\n                else if (boxHasMoved) {\n                    // If the box has moved, animate between it's current visual state and its\n                    // final state\n                    return _this.animateAxis(axis, target[axis], origin[axis], tslib.__assign(tslib.__assign({}, config), { isRelative: isRelative }));\n                }\n                else {\n                    (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    // If the box has remained in the same place, immediately set the axis target\n                    // to the final desired state\n                    return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\n                }\n            });\n            // Force a render to ensure there's no flash of uncorrected bounding box.\n            visualElement.syncRender();\n            /**\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n             * have successfully finished.\n             */\n            return Promise.all(animations).then(function () {\n                _this.isAnimatingTree = false;\n                onComplete && onComplete();\n                visualElement.notifyLayoutAnimationComplete();\n            });\n        };\n        return _this;\n    }\n    Animate.prototype.componentDidMount = function () {\n        var _this = this;\n        var visualElement = this.props.visualElement;\n        visualElement.animateMotionValue = startAnimation;\n        visualElement.enableLayoutProjection();\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n        visualElement.layoutSafeToRemove = function () { return _this.safeToRemove(); };\n        addScaleCorrection(defaultScaleCorrectors);\n    };\n    Animate.prototype.componentWillUnmount = function () {\n        var _this = this;\n        this.unsubLayoutReady();\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\n    };\n    /**\n     * TODO: This manually performs animations on the visualElement's layout progress\n     * values. It'd be preferable to amend the startLayoutAxisAnimation\n     * API to accept more custom animations like this.\n     */\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n        var _this = this;\n        var _b, _c;\n        var _d = _a === void 0 ? {} : _a, transition = _d.transition, isRelative = _d.isRelative;\n        /**\n         * If we're not animating to a new target, don't run this animation\n         */\n        if (this.isAnimating[axis] &&\n            axisIsEqual(target, this.currentAnimationTarget[axis])) {\n            return;\n        }\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n        this.isAnimating[axis] = true;\n        var visualElement = this.props.visualElement;\n        var frameTarget = this.frameTarget[axis];\n        var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n        /**\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n         * be re-incoporated into a subsequent spring animation.\n         */\n        layoutProgress.clearListeners();\n        layoutProgress.set(0);\n        layoutProgress.set(0);\n        /**\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\n         * origin to target using the latest progress value.\n         */\n        var frame = function () {\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n            var p = layoutProgress.get() / progressTarget;\n            // Tween the axis and update the visualElement with the latest values\n            tweenAxis(frameTarget, origin, target, p);\n            visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\n        };\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n        frame();\n        // Create a function to stop animation on this specific axis\n        var unsubscribeProgress = layoutProgress.onChange(frame);\n        this.stopAxisAnimation[axis] = function () {\n            _this.isAnimating[axis] = false;\n            layoutProgress.stop();\n            unsubscribeProgress();\n        };\n        this.currentAnimationTarget[axis] = target;\n        var layoutTransition = transition ||\n            visualElement.getDefaultTransition() ||\n            defaultLayoutTransition;\n        // Start the animation on this axis\n        var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \"layout\")).then(this.stopAxisAnimation[axis]);\n        return animation;\n    };\n    Animate.prototype.safeToRemove = function () {\n        var _a, _b;\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    Animate.prototype.render = function () {\n        return null;\n    };\n    return Animate;\n}(React__namespace.Component));\nfunction AnimateLayoutContextProvider(props) {\n    var _a = tslib.__read(usePresence(), 2), safeToRemove = _a[1];\n    return React__namespace.createElement(Animate, tslib.__assign({}, props, { safeToRemove: safeToRemove }));\n}\nfunction hasMoved(a, b) {\n    return (!isZeroBox(a) &&\n        !isZeroBox(b) &&\n        (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y)));\n}\nvar zeroAxis = { min: 0, max: 0 };\nfunction isZeroBox(a) {\n    return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\nfunction axisIsEqual(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nvar defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\n    return prevParent || (!prevParent && !(originBox || targetBox));\n}\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n    layoutReady: function (child) { return child.notifyLayoutReady(); },\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n    var queue = new Set();\n    return {\n        add: function (child) { return queue.add(child); },\n        flush: function (_a) {\n            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;\n            batchLayout(function (read, write) {\n                var order = Array.from(queue).sort(compareByDepth);\n                var ancestors = parent\n                    ? collectProjectingAncestors(parent)\n                    : [];\n                write(function () {\n                    var allElements = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(order));\n                    allElements.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    order.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    ancestors.forEach(function (element) { return element.restoreTransform(); });\n                    order.forEach(layoutReady);\n                });\n                read(function () {\n                    /**\n                     * After all children have started animating, ensure any Entering components are set to Present.\n                     * If we add deferred animations (set up all animations and then start them in two loops) this\n                     * could be moved to the start loop. But it needs to happen after all the animations configs\n                     * are generated in AnimateSharedLayout as this relies on presence data\n                     */\n                    order.forEach(function (child) {\n                        if (child.isPresent)\n                            child.presence = Presence.Present;\n                    });\n                });\n                write(function () {\n                    /**\n                     * Starting these animations will have queued jobs on the frame loop. In some situations,\n                     * like when removing an element, these will be processed too late after the DOM is manipulated,\n                     * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n                     * we ensure there's no flash.\n                     */\n                    sync.flushSync.preRender();\n                    sync.flushSync.render();\n                });\n                read(function () {\n                    /**\n                     * Schedule a callback at the end of the following frame to assign the latest projection\n                     * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n                     * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n                     * child attempts to calculate its previous relative position against a prevViewportBox\n                     * it will be against its latest projection box instead, as the snapshot is useless beyond this\n                     * render.\n                     */\n                    sync__default['default'].postRender(function () {\n                        return order.forEach(assignProjectionToSnapshot);\n                    });\n                    queue.clear();\n                });\n            });\n            // TODO: Need to find a layout-synchronous way of flushing this\n            flushLayout();\n        },\n    };\n}\nfunction assignProjectionToSnapshot(child) {\n    child.prevViewportBox = child.projection.target;\n}\n\nvar SharedLayoutContext = React.createContext(createBatcher());\n/**\n * @internal\n */\nvar FramerTreeLayoutContext = React.createContext(createBatcher());\nfunction isSharedLayout(context) {\n    return !!context.forceUpdate;\n}\n\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\nvar Measure = /** @class */ (function (_super) {\n    tslib.__extends(Measure, _super);\n    function Measure() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * If this is a child of a SyncContext, register the VisualElement with it on mount.\n     */\n    Measure.prototype.componentDidMount = function () {\n        var _a = this.props, syncLayout = _a.syncLayout, framerSyncLayout = _a.framerSyncLayout, visualElement = _a.visualElement;\n        isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n        isSharedLayout(framerSyncLayout) &&\n            framerSyncLayout.register(visualElement);\n        visualElement.onUnmount(function () {\n            if (isSharedLayout(syncLayout)) {\n                syncLayout.remove(visualElement);\n            }\n            if (isSharedLayout(framerSyncLayout)) {\n                framerSyncLayout.remove(visualElement);\n            }\n        });\n    };\n    /**\n     * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n     * handle the snapshotting.\n     *\n     * If it is stand-alone component, add it to the batcher.\n     */\n    Measure.prototype.getSnapshotBeforeUpdate = function () {\n        var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;\n        if (isSharedLayout(syncLayout)) {\n            syncLayout.syncUpdate();\n        }\n        else {\n            snapshotViewportBox(visualElement);\n            syncLayout.add(visualElement);\n        }\n        return null;\n    };\n    Measure.prototype.componentDidUpdate = function () {\n        var syncLayout = this.props.syncLayout;\n        if (!isSharedLayout(syncLayout))\n            syncLayout.flush();\n    };\n    Measure.prototype.render = function () {\n        return null;\n    };\n    return Measure;\n}(React__default['default'].Component));\nfunction MeasureContextProvider(props) {\n    var syncLayout = React.useContext(SharedLayoutContext);\n    var framerSyncLayout = React.useContext(FramerTreeLayoutContext);\n    return (React__default['default'].createElement(Measure, tslib.__assign({}, props, { syncLayout: syncLayout, framerSyncLayout: framerSyncLayout })));\n}\n\nvar layoutAnimations = {\n    measureLayout: MeasureContextProvider,\n    layoutAnimation: AnimateLayoutContextProvider,\n};\n\nvar createProjectionState = function () { return ({\n    isEnabled: false,\n    isHydrated: false,\n    isTargetLocked: false,\n    target: axisBox(),\n    targetFinal: axisBox(),\n}); };\nfunction createLayoutState() {\n    return {\n        isHydrated: false,\n        layout: axisBox(),\n        layoutCorrected: axisBox(),\n        treeScale: { x: 1, y: 1 },\n        delta: delta(),\n        deltaFinal: delta(),\n        deltaTransform: \"\",\n    };\n}\nvar zeroLayout = createLayoutState();\n\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n    var x = _a.x, y = _a.y;\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    var xTranslate = x.translate / treeScale.x;\n    var yTranslate = y.translate / treeScale.y;\n    var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate)\n            transform += \"rotate(\" + rotate + \") \";\n        if (rotateX)\n            transform += \"rotateX(\" + rotateX + \") \";\n        if (rotateY)\n            transform += \"rotateY(\" + rotateY + \") \";\n    }\n    transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n    return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\nfunction buildLayoutProjectionTransformOrigin(_a) {\n    var deltaFinal = _a.deltaFinal;\n    return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\n\nvar names = [\n    \"LayoutMeasure\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutUpdate\",\n    \"ViewportBoxUpdate\",\n    \"Update\",\n    \"Render\",\n    \"AnimationComplete\",\n    \"LayoutAnimationComplete\",\n    \"AnimationStart\",\n    \"SetAxisTarget\",\n    \"Unmount\",\n];\nfunction createLifecycles() {\n    var managers = names.map(function () { return new SubscriptionManager(); });\n    var propSubscriptions = {};\n    var lifecycles = {\n        clearAllListeners: function () { return managers.forEach(function (manager) { return manager.clear(); }); },\n        updatePropListeners: function (props) {\n            return names.forEach(function (name) {\n                var _a;\n                (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n                var on = \"on\" + name;\n                var propListener = props[on];\n                if (propListener) {\n                    propSubscriptions[name] = lifecycles[on](propListener);\n                }\n            });\n        },\n    };\n    managers.forEach(function (manager, i) {\n        lifecycles[\"on\" + names[i]] = function (handler) { return manager.add(handler); };\n        lifecycles[\"notify\" + names[i]] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return manager.notify.apply(manager, tslib.__spreadArray([], tslib.__read(args)));\n        };\n    });\n    return lifecycles;\n}\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    var _a;\n    for (var key in next) {\n        var nextValue = next[key];\n        var prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping to a new motion value, create a new motion value\n             * from that\n             */\n            element.addValue(key, motionValue(nextValue));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                var existingValue = element.getValue(key);\n                // TODO: Only update values that aren't being animated or even looked at\n                !existingValue.hasAnimated && existingValue.set(nextValue);\n            }\n            else {\n                element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n            }\n        }\n    }\n    // Handle removed values\n    for (var key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nfunction updateLayoutDeltas(_a, _b, treePath, transformOrigin) {\n    var delta = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;\n    var target = _b.target;\n    /**\n     * Reset the corrected box with the latest values from box, as we're then going\n     * to perform mutative operations on it.\n     */\n    resetBox(layoutCorrected, layout);\n    /**\n     * Apply all the parent deltas to this box to produce the corrected box. This\n     * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n     */\n    applyTreeDeltas(layoutCorrected, treeScale, treePath);\n    /**\n     * Update the delta between the corrected box and the target box before user-set transforms were applied.\n     * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n     * for our layout reprojection, but still allow them to be scaled correctly by the user.\n     * It might be that to simplify this we may want to accept that user-set scale is also corrected\n     * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n     * to allow people to choose whether these styles are corrected based on just the\n     * layout reprojection or the final bounding box.\n     */\n    updateBoxDelta(delta, layoutCorrected, target, transformOrigin);\n}\n\nvar FlatTree = /** @class */ (function () {\n    function FlatTree() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    FlatTree.prototype.add = function (child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.remove = function (child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.forEach = function (callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    };\n    return FlatTree;\n}());\n\nfunction setCurrentViewportBox(visualElement) {\n    var projectionParent = visualElement.getProjectionParent();\n    if (!projectionParent) {\n        visualElement.rebaseProjectionTarget();\n        return;\n    }\n    var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n    eachAxis(function (axis) {\n        visualElement.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);\n    });\n}\n\nvar visualElement = function (_a) {\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n    return function (_a, options) {\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState;\n        if (options === void 0) { options = {}; }\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\n        /**\n         * The instance of the render-specific node that will be hydrated by the\n         * exposed React ref. So for example, this visual element can host a\n         * HTMLElement, plain object, or Three.js object. The functions provided\n         * in VisualElementConfig allow us to interface with this instance.\n         */\n        var instance;\n        /**\n         * Manages the subscriptions for a visual element's lifecycle, for instance\n         * onRender and onViewportBoxUpdate.\n         */\n        var lifecycles = createLifecycles();\n        /**\n         *\n         */\n        var projection = createProjectionState();\n        /**\n         * A reference to the nearest projecting parent. This is either\n         * undefined if we haven't looked for the nearest projecting parent,\n         * false if there is no parent performing layout projection, or a reference\n         * to the projecting parent.\n         */\n        var projectionParent;\n        /**\n         * This is a reference to the visual state of the \"lead\" visual element.\n         * Usually, this will be this visual element. But if it shares a layoutId\n         * with other visual elements, only one of them will be designated lead by\n         * AnimateSharedLayout. All the other visual elements will take on the visual\n         * appearance of the lead while they crossfade to it.\n         */\n        var leadProjection = projection;\n        var leadLatestValues = latestValues;\n        var unsubscribeFromLeadVisualElement;\n        /**\n         * The latest layout measurements and calculated projections. This\n         * is seperate from the target projection data in visualState as\n         * many visual elements might point to the same piece of visualState as\n         * a target, whereas they might each have different layouts and thus\n         * projection calculations needed to project into the same viewport box.\n         */\n        var layoutState = createLayoutState();\n        /**\n         *\n         */\n        var crossfader;\n        /**\n         * Keep track of whether the viewport box has been updated since the\n         * last time the layout projection was re-calculated.\n         */\n        var hasViewportBoxUpdated = false;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        var values = new Map();\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        var valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        var prevMotionValues = {};\n        /**\n         * x/y motion values that track the progress of initiated layout\n         * animations.\n         *\n         * TODO: Target for removal\n         */\n        var projectionTargetProgress;\n        /**\n         * When values are removed from all animation props we need to search\n         * for a fallback value to animate to. These values are tracked in baseTarget.\n         */\n        var baseTarget = tslib.__assign({}, latestValues);\n        // Internal methods ========================\n        /**\n         * On mount, this will be hydrated with a callback to disconnect\n         * this visual element from its parent on unmount.\n         */\n        var removeFromVariantTree;\n        /**\n         *\n         */\n        function render() {\n            if (!instance)\n                return;\n            if (element.isProjectionReady()) {\n                /**\n                 * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n                 * This is the final box that we will then project into by calculating a transform delta and\n                 * applying it to the corrected box.\n                 */\n                applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n                /**\n                 * Update the delta between the corrected box and the final target box, after\n                 * user-set transforms are applied to it. This will be used by the renderer to\n                 * create a transform style that will reproject the element from its actual layout\n                 * into the desired bounding box.\n                 */\n                updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n            }\n            triggerBuild();\n            renderInstance(instance, renderState);\n        }\n        function triggerBuild() {\n            var valuesToRender = latestValues;\n            if (crossfader && crossfader.isActive()) {\n                var crossfadedValues = crossfader.getCrossfadeState(element);\n                if (crossfadedValues)\n                    valuesToRender = crossfadedValues;\n            }\n            build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n        }\n        function update() {\n            lifecycles.notifyUpdate(latestValues);\n        }\n        function updateLayoutProjection() {\n            if (!element.isProjectionReady())\n                return;\n            var delta = layoutState.delta, treeScale = layoutState.treeScale;\n            var prevTreeScaleX = treeScale.x;\n            var prevTreeScaleY = treeScale.y;\n            var prevDeltaTransform = layoutState.deltaTransform;\n            updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n            hasViewportBoxUpdated &&\n                element.notifyViewportBoxUpdate(leadProjection.target, delta);\n            hasViewportBoxUpdated = false;\n            var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n            if (deltaTransform !== prevDeltaTransform ||\n                // Also compare calculated treeScale, for values that rely on this only for scale correction\n                prevTreeScaleX !== treeScale.x ||\n                prevTreeScaleY !== treeScale.y) {\n                element.scheduleRender();\n            }\n            layoutState.deltaTransform = deltaTransform;\n        }\n        function updateTreeLayoutProjection() {\n            element.layoutTree.forEach(fireUpdateLayoutProjection);\n        }\n        /**\n         *\n         */\n        function bindToMotionValue(key, value) {\n            var removeOnChange = value.onChange(function (latestValue) {\n                latestValues[key] = latestValue;\n                props.onUpdate && sync__default['default'].update(update, false, true);\n            });\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n            valueSubscriptions.set(key, function () {\n                removeOnChange();\n                removeOnRenderRequest();\n            });\n        }\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\n        for (var key in initialMotionValues) {\n            var value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        var isControllingVariants = checkIfControllingVariants(props);\n        var isVariantNode = checkIfVariantNode(props);\n        var element = tslib.__assign(tslib.__assign({ treeType: treeType, \n            /**\n             * This is a mirror of the internal instance prop, which keeps\n             * VisualElement type-compatible with React's RefObject.\n             */\n            current: null, \n            /**\n             * The depth of this visual element within the visual element tree.\n             */\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \n            /**\n             * An ancestor path back to the root visual element. This is used\n             * by layout projection to quickly recurse back up the tree.\n             */\n            path: parent ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(parent.path)), [parent]) : [], layoutTree: parent ? parent.layoutTree : new FlatTree(), \n            /**\n             *\n             */\n            presenceId: presenceId,\n            projection: projection, \n            /**\n             * If this component is part of the variant tree, it should track\n             * any children that are also part of the tree. This is essentially\n             * a shadow tree to simplify logic around how to stagger over children.\n             */\n            variantChildren: isVariantNode ? new Set() : undefined, \n            /**\n             * Whether this instance is visible. This can be changed imperatively\n             * by AnimateSharedLayout, is analogous to CSS's visibility in that\n             * hidden elements should take up layout, and needs enacting by the configured\n             * render function.\n             */\n            isVisible: undefined, \n            /**\n             * Normally, if a component is controlled by a parent's variants, it can\n             * rely on that ancestor to trigger animations further down the tree.\n             * However, if a component is created after its parent is mounted, the parent\n             * won't trigger that mount animation so the child needs to.\n             *\n             * TODO: This might be better replaced with a method isParentMounted\n             */\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \n            /**\n             * This can be set by AnimatePresence to force components that mount\n             * at the same time as it to mount as if they have initial={false} set.\n             */\n            blockInitialAnimation: blockInitialAnimation, \n            /**\n             * Determine whether this component has mounted yet. This is mostly used\n             * by variant children to determine whether they need to trigger their\n             * own animations on mount.\n             */\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\n                instance = element.current = newInstance;\n                element.pointTo(element);\n                if (isVariantNode && parent && !isControllingVariants) {\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n                }\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n            },\n            /**\n             *\n             */\n            unmount: function () {\n                sync.cancelSync.update(update);\n                sync.cancelSync.render(render);\n                sync.cancelSync.preRender(element.updateLayoutProjection);\n                valueSubscriptions.forEach(function (remove) { return remove(); });\n                element.stopLayoutAnimation();\n                element.layoutTree.remove(element);\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n                lifecycles.clearAllListeners();\n            },\n            /**\n             * Add a child visual element to our set of children.\n             */\n            addVariantChild: function (child) {\n                var _a;\n                var closestVariantNode = element.getClosestVariantNode();\n                if (closestVariantNode) {\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n                    return function () { return closestVariantNode.variantChildren.delete(child); };\n                }\n            },\n            sortNodePosition: function (other) {\n                /**\n                 * If these nodes aren't even of the same type we can't compare their depth.\n                 */\n                if (!sortNodePosition || treeType !== other.treeType)\n                    return 0;\n                return sortNodePosition(element.getInstance(), other.getInstance());\n            }, \n            /**\n             * Returns the closest variant node in the tree starting from\n             * this visual element.\n             */\n            getClosestVariantNode: function () {\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n            }, \n            /**\n             * A method that schedules an update to layout projections throughout\n             * the tree. We inherit from the parent so there's only ever one\n             * job scheduled on the next frame - that of the root visual element.\n             */\n            scheduleUpdateLayoutProjection: parent\n                ? parent.scheduleUpdateLayoutProjection\n                : function () {\n                    return sync__default['default'].preRender(element.updateTreeLayoutProjection, false, true);\n                }, \n            /**\n             * Expose the latest layoutId prop.\n             */\n            getLayoutId: function () { return props.layoutId; }, \n            /**\n             * Returns the current instance.\n             */\n            getInstance: function () { return instance; }, \n            /**\n             * Get/set the latest static values.\n             */\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \n            /**\n             * Returns the latest motion value state. Currently only used to take\n             * a snapshot of the visual element - perhaps this can return the whole\n             * visual state\n             */\n            getLatestValues: function () { return latestValues; }, \n            /**\n             * Set the visiblity of the visual element. If it's changed, schedule\n             * a render to reflect these changes.\n             */\n            setVisibility: function (visibility) {\n                if (element.isVisible === visibility)\n                    return;\n                element.isVisible = visibility;\n                element.scheduleRender();\n            },\n            /**\n             * Make a target animatable by Popmotion. For instance, if we're\n             * trying to animate width from 100px to 100vw we need to measure 100vw\n             * in pixels to determine what we really need to animate to. This is also\n             * pluggable to support Framer's custom value types like Color,\n             * and CSS variables.\n             */\n            makeTargetAnimatable: function (target, canMutate) {\n                if (canMutate === void 0) { canMutate = true; }\n                return makeTargetAnimatable(element, target, props, canMutate);\n            },\n            // Motion values ========================\n            /**\n             * Add a motion value and bind it to this visual element.\n             */\n            addValue: function (key, value) {\n                // Remove existing value if it exists\n                if (element.hasValue(key))\n                    element.removeValue(key);\n                values.set(key, value);\n                latestValues[key] = value.get();\n                bindToMotionValue(key, value);\n            },\n            /**\n             * Remove a motion value and unbind any active subscriptions.\n             */\n            removeValue: function (key) {\n                var _a;\n                values.delete(key);\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n                valueSubscriptions.delete(key);\n                delete latestValues[key];\n                removeValueFromRenderState(key, renderState);\n            }, \n            /**\n             * Check whether we have a motion value for this key\n             */\n            hasValue: function (key) { return values.has(key); }, \n            /**\n             * Get a motion value for this key. If called with a default\n             * value, we'll create one if none exists.\n             */\n            getValue: function (key, defaultValue) {\n                var value = values.get(key);\n                if (value === undefined && defaultValue !== undefined) {\n                    value = motionValue(defaultValue);\n                    element.addValue(key, value);\n                }\n                return value;\n            }, \n            /**\n             * Iterate over our motion values.\n             */\n            forEachValue: function (callback) { return values.forEach(callback); }, \n            /**\n             * If we're trying to animate to a previously unencountered value,\n             * we need to check for it in our state and as a last resort read it\n             * directly from the instance (which might have performance implications).\n             */\n            readValue: function (key) { var _a; return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options); }, \n            /**\n             * Set the base target to later animate back to. This is currently\n             * only hydrated on creation and when we first read a value.\n             */\n            setBaseTarget: function (key, value) {\n                baseTarget[key] = value;\n            },\n            /**\n             * Find the base target for a value thats been removed from all animation\n             * props.\n             */\n            getBaseTarget: function (key) {\n                if (getBaseTarget) {\n                    var target = getBaseTarget(props, key);\n                    if (target !== undefined && !isMotionValue(target))\n                        return target;\n                }\n                return baseTarget[key];\n            } }, lifecycles), { \n            /**\n             * Build the renderer state based on the latest visual state.\n             */\n            build: function () {\n                triggerBuild();\n                return renderState;\n            },\n            /**\n             * Schedule a render on the next animation frame.\n             */\n            scheduleRender: function () {\n                sync__default['default'].render(render, false, true);\n            }, \n            /**\n             * Synchronously fire render. It's prefered that we batch renders but\n             * in many circumstances, like layout measurement, we need to run this\n             * synchronously. However in those instances other measures should be taken\n             * to batch reads/writes.\n             */\n            syncRender: render, \n            /**\n             * Update the provided props. Ensure any newly-added motion values are\n             * added to our map, old ones removed, and listeners updated.\n             */\n            setProps: function (newProps) {\n                props = newProps;\n                lifecycles.updatePropListeners(newProps);\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n            }, getProps: function () { return props; }, \n            // Variants ==============================\n            /**\n             * Returns the variant definition with a given name.\n             */\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \n            /**\n             * Returns the defined default transition on this component.\n             */\n            getDefaultTransition: function () { return props.transition; }, \n            /**\n             * Used by child variant nodes to get the closest ancestor variant props.\n             */\n            getVariantContext: function (startAtParent) {\n                if (startAtParent === void 0) { startAtParent = false; }\n                if (startAtParent)\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n                if (!isControllingVariants) {\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n                    if (props.initial !== undefined) {\n                        context_1.initial = props.initial;\n                    }\n                    return context_1;\n                }\n                var context = {};\n                for (var i = 0; i < numVariantProps; i++) {\n                    var name_1 = variantProps[i];\n                    var prop = props[name_1];\n                    if (isVariantLabel(prop) || prop === false) {\n                        context[name_1] = prop;\n                    }\n                }\n                return context;\n            },\n            // Layout projection ==============================\n            /**\n             * Enable layout projection for this visual element. Won't actually\n             * occur until we also have hydrated layout measurements.\n             */\n            enableLayoutProjection: function () {\n                projection.isEnabled = true;\n                element.layoutTree.add(element);\n            },\n            /**\n             * Lock the projection target, for instance when dragging, so\n             * nothing else can try and animate it.\n             */\n            lockProjectionTarget: function () {\n                projection.isTargetLocked = true;\n            },\n            unlockProjectionTarget: function () {\n                element.stopLayoutAnimation();\n                projection.isTargetLocked = false;\n            }, getLayoutState: function () { return layoutState; }, setCrossfader: function (newCrossfader) {\n                crossfader = newCrossfader;\n            }, isProjectionReady: function () {\n                return projection.isEnabled &&\n                    projection.isHydrated &&\n                    layoutState.isHydrated;\n            }, \n            /**\n             * Start a layout animation on a given axis.\n             */\n            startLayoutAnimation: function (axis, transition, isRelative) {\n                if (isRelative === void 0) { isRelative = false; }\n                var progress = element.getProjectionAnimationProgress()[axis];\n                var _a = isRelative\n                    ? projection.relativeTarget[axis]\n                    : projection.target[axis], min = _a.min, max = _a.max;\n                var length = max - min;\n                progress.clearListeners();\n                progress.set(min);\n                progress.set(min); // Set twice to hard-reset velocity\n                progress.onChange(function (v) {\n                    element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n                });\n                return element.animateMotionValue(axis, progress, 0, transition);\n            },\n            /**\n             * Stop layout animations.\n             */\n            stopLayoutAnimation: function () {\n                eachAxis(function (axis) {\n                    return element.getProjectionAnimationProgress()[axis].stop();\n                });\n            },\n            /**\n             * Measure the current viewport box with or without transforms.\n             * Only measures axis-aligned boxes, rotate and skew must be manually\n             * removed with a re-render to work.\n             */\n            measureViewportBox: function (withTransform) {\n                if (withTransform === void 0) { withTransform = true; }\n                var viewportBox = measureViewportBox(instance, options);\n                if (!withTransform)\n                    removeBoxTransforms(viewportBox, latestValues);\n                return viewportBox;\n            },\n            /**\n             * Get the motion values tracking the layout animations on each\n             * axis. Lazy init if not already created.\n             */\n            getProjectionAnimationProgress: function () {\n                projectionTargetProgress || (projectionTargetProgress = {\n                    x: motionValue(0),\n                    y: motionValue(0),\n                });\n                return projectionTargetProgress;\n            },\n            /**\n             * Update the projection of a single axis. Schedule an update to\n             * the tree layout projection.\n             */\n            setProjectionTargetAxis: function (axis, min, max, isRelative) {\n                if (isRelative === void 0) { isRelative = false; }\n                var target;\n                if (isRelative) {\n                    if (!projection.relativeTarget) {\n                        projection.relativeTarget = axisBox();\n                    }\n                    target = projection.relativeTarget[axis];\n                }\n                else {\n                    projection.relativeTarget = undefined;\n                    target = projection.target[axis];\n                }\n                projection.isHydrated = true;\n                target.min = min;\n                target.max = max;\n                // Flag that we want to fire the onViewportBoxUpdate event handler\n                hasViewportBoxUpdated = true;\n                lifecycles.notifySetAxisTarget();\n            },\n            /**\n             * Rebase the projection target on top of the provided viewport box\n             * or the measured layout. This ensures that non-animating elements\n             * don't fall out of sync differences in measurements vs projections\n             * after a page scroll or other relayout.\n             */\n            rebaseProjectionTarget: function (force, box) {\n                if (box === void 0) { box = layoutState.layout; }\n                var _a = element.getProjectionAnimationProgress(), x = _a.x, y = _a.y;\n                var shouldRebase = !projection.relativeTarget &&\n                    !projection.isTargetLocked &&\n                    !x.isAnimating() &&\n                    !y.isAnimating();\n                if (force || shouldRebase) {\n                    eachAxis(function (axis) {\n                        var _a = box[axis], min = _a.min, max = _a.max;\n                        element.setProjectionTargetAxis(axis, min, max);\n                    });\n                }\n            },\n            /**\n             * Notify the visual element that its layout is up-to-date.\n             * Currently Animate.tsx uses this to check whether a layout animation\n             * needs to be performed.\n             */\n            notifyLayoutReady: function (config) {\n                setCurrentViewportBox(element);\n                element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n            }, \n            /**\n             * Temporarily reset the transform of the instance.\n             */\n            resetTransform: function () { return resetTransform(element, instance, props); }, restoreTransform: function () { return restoreTransform(instance, renderState); }, updateLayoutProjection: updateLayoutProjection,\n            updateTreeLayoutProjection: function () {\n                element.layoutTree.forEach(fireResolveRelativeTargetBox);\n                /**\n                 * Schedule the projection updates at the end of the current preRender\n                 * step. This will ensure that all layout trees will first resolve\n                 * relative projection boxes into viewport boxes, and *then*\n                 * update projections.\n                 */\n                sync__default['default'].preRender(updateTreeLayoutProjection, false, true);\n                // sync.postRender(() => element.scheduleUpdateLayoutProjection())\n            },\n            getProjectionParent: function () {\n                if (projectionParent === undefined) {\n                    var foundParent = false;\n                    // Search backwards through the tree path\n                    for (var i = element.path.length - 1; i >= 0; i--) {\n                        var ancestor = element.path[i];\n                        if (ancestor.projection.isEnabled) {\n                            foundParent = ancestor;\n                            break;\n                        }\n                    }\n                    projectionParent = foundParent;\n                }\n                return projectionParent;\n            },\n            resolveRelativeTargetBox: function () {\n                var relativeParent = element.getProjectionParent();\n                if (!projection.relativeTarget || !relativeParent)\n                    return;\n                calcRelativeBox(projection, relativeParent.projection);\n                if (isDraggable(relativeParent)) {\n                    var target = projection.target;\n                    applyBoxTransforms(target, target, relativeParent.getLatestValues());\n                }\n            },\n            shouldResetTransform: function () {\n                return Boolean(props._layoutResetTransform);\n            },\n            /**\n             *\n             */\n            pointTo: function (newLead) {\n                leadProjection = newLead.projection;\n                leadLatestValues = newLead.getLatestValues();\n                /**\n                 * Subscribe to lead component's layout animations\n                 */\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n                unsubscribeFromLeadVisualElement = popmotion.pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n                    var _a;\n                    if (element.isPresent) {\n                        element.presence = Presence.Present;\n                    }\n                    else {\n                        (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n                    }\n                }));\n            }, \n            // TODO: Clean this up\n            isPresent: true, presence: Presence.Entering });\n        return element;\n    };\n};\nfunction fireResolveRelativeTargetBox(child) {\n    child.resolveRelativeTargetBox();\n}\nfunction fireUpdateLayoutProjection(child) {\n    child.updateLayoutProjection();\n}\nvar variantProps = tslib.__spreadArray([\"initial\"], tslib.__read(variantPriorityOrder));\nvar numVariantProps = variantProps.length;\n\nvar positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n]);\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\nvar hasPositionalKey = function (target) {\n    return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n    // Looks odd but setting it twice doesn't render, it'll just\n    // set both prev and current to the latest value\n    value.set(to, false);\n    value.set(to);\n};\nvar isNumOrPxType = function (v) {\n    return v === styleValueTypes.number || v === styleValueTypes.px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n    BoundingBoxDimension[\"width\"] = \"width\";\n    BoundingBoxDimension[\"height\"] = \"height\";\n    BoundingBoxDimension[\"left\"] = \"left\";\n    BoundingBoxDimension[\"right\"] = \"right\";\n    BoundingBoxDimension[\"top\"] = \"top\";\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n    return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform)\n        return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n}; };\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\nfunction removeNonTranslationalTransform(visualElement) {\n    var removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.syncRender();\n    return removedTransforms;\n}\nvar positionalValues = {\n    // Dimensions\n    width: function (_a) {\n        var x = _a.x;\n        return x.max - x.min;\n    },\n    height: function (_a) {\n        var y = _a.y;\n        return y.max - y.min;\n    },\n    top: function (_bbox, _a) {\n        var top = _a.top;\n        return parseFloat(top);\n    },\n    left: function (_bbox, _a) {\n        var left = _a.left;\n        return parseFloat(left);\n    },\n    bottom: function (_a, _b) {\n        var y = _a.y;\n        var top = _b.top;\n        return parseFloat(top) + (y.max - y.min);\n    },\n    right: function (_a, _b) {\n        var x = _a.x;\n        var left = _b.left;\n        return parseFloat(left) + (x.max - x.min);\n    },\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n    var originBbox = visualElement.measureViewportBox();\n    var element = visualElement.getInstance();\n    var elementComputedStyle = getComputedStyle(element);\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.syncRender();\n    var targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach(function (key) {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        var value = visualElement.getValue(key);\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n    if (origin === void 0) { origin = {}; }\n    if (transitionEnd === void 0) { transitionEnd = {}; }\n    target = tslib.__assign({}, target);\n    transitionEnd = tslib.__assign({}, transitionEnd);\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    var removedTransformValues = [];\n    var hasAttemptedToRemoveTransformValues = false;\n    var changedValueTypeKeys = [];\n    targetPositionalKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        var from = origin[key];\n        var to = target[key];\n        var fromType = findDimensionValueType(from);\n        var toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            var numKeyframes = to.length;\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    heyListen.invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    heyListen.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                var current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === styleValueTypes.px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                setAndResetVelocity(value, to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(function (_a) {\n                var _b = tslib.__read(_a, 2), key = _b[0], value = _b[1];\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.syncRender();\n        return { target: convertedTarget, transitionEnd: transitionEnd };\n    }\n    else {\n        return { target: target, transitionEnd: transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target: target, transitionEnd: transitionEnd };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\nfunction getComputedStyle$1(element) {\n    return window.getComputedStyle(element);\n}\nvar htmlConfig = {\n    treeType: \"dom\",\n    readValueFromInstance: function (domElement, key) {\n        if (isTransformProp(key)) {\n            var defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            var computedStyle = getComputedStyle$1(domElement);\n            return ((isCSSVariable$1(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0);\n        }\n    },\n    sortNodePosition: function (a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget: function (props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox: function (element, _a) {\n        var transformPagePoint = _a.transformPagePoint;\n        return getBoundingBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */\n    resetTransform: function (element, domElement, props) {\n        var transformTemplate = props.transformTemplate;\n        domElement.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform: function (instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromRenderState: function (key, _a) {\n        var vars = _a.vars, style = _a.style;\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */\n    makeTargetAnimatable: function (element, _a, _b, isMounted) {\n        var transformValues = _b.transformValues;\n        if (isMounted === void 0) { isMounted = true; }\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n        var origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            var parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return tslib.__assign({ transition: transition,\n            transitionEnd: transitionEnd }, target);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n    build: function (element, renderState, latestValues, projection, layoutState, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible\n                ? \"visible\"\n                : \"hidden\";\n        }\n        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n        buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform\n            ? buildLayoutProjectionTransformOrigin\n            : undefined);\n    },\n    render: renderHTML,\n};\nvar htmlVisualElement = visualElement(htmlConfig);\n\nvar svgVisualElement = visualElement(tslib.__assign(tslib.__assign({}, htmlConfig), { getBaseTarget: function (props, key) {\n        return props[key];\n    },\n    readValueFromInstance: function (domElement, key) {\n        var _a;\n        if (isTransformProp(key)) {\n            return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return domElement.getAttribute(key);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    build: function (_element, renderState, latestValues, projection, layoutState, options, props) {\n        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n        buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform\n            ? buildLayoutProjectionTransformOrigin\n            : undefined);\n    }, render: renderSVG }));\n\nvar createDomVisualElement = function (Component, options) {\n    return isSVGComponent(Component)\n        ? svgVisualElement(options, { enableHardwareAcceleration: false })\n        : htmlVisualElement(options, { enableHardwareAcceleration: true });\n};\n\nvar featureBundle = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, animations), gestureAnimations), drag), layoutAnimations);\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\nvar motion = /*@__PURE__*/ createMotionProxy(function (Component, config) {\n    return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement);\n});\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don't\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from \"framer-motion\"\n *\n * const motion = {\n *   div: createDomMotionComponent('div')\n * }\n * ```\n *\n * @public\n */\nfunction createDomMotionComponent(key) {\n    return createMotionComponent(createDomMotionConfig(key, { forwardMotionProps: false }, featureBundle, createDomVisualElement));\n}\n\n/**\n * @public\n */\nvar m = createMotionProxy(createDomMotionConfig);\n\nfunction useForceUpdate() {\n    var unloadingRef = React.useRef(false);\n    var _a = tslib.__read(React.useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    useUnmountEffect(function () { return (unloadingRef.current = true); });\n    return React.useCallback(function () {\n        !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\nfunction getPresenceId() {\n    var id = presenceId;\n    presenceId++;\n    return id;\n}\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useConstant(getPresenceId);\n    var context = React.useMemo(function () { return ({\n        id: id,\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            presenceChildren.set(childId, true);\n            var allComplete = true;\n            presenceChildren.forEach(function (isComplete) {\n                if (!isComplete)\n                    allComplete = false;\n            });\n            allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    }); }, \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    React.useMemo(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React__namespace.useEffect(function () {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [isPresent]);\n    return (React__namespace.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nfunction getChildKey(child) {\n    return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n            if (seenChildren.has(key)) {\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n            }\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    React.Children.forEach(children, function (child) {\n        if (React.isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var forceRender = useForceUpdate();\n    var layoutContext = React.useContext(SharedLayoutContext);\n    if (isSharedLayout(layoutContext)) {\n        forceRender = layoutContext.forceUpdate;\n    }\n    var isInitialRender = React.useRef(true);\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = React.useRef(filteredChildren);\n    // A lookup table to quickly reference components by key\n    var allChildren = React.useRef(new Map())\n        .current;\n    // A living record of all currently exiting components.\n    var exiting = React.useRef(new Set()).current;\n    updateChildLookup(filteredChildren, allChildren);\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    if (isInitialRender.current) {\n        isInitialRender.current = false;\n        return (React__namespace.createElement(React__namespace.Fragment, null, filteredChildren.map(function (child) { return (React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    var childrenToRender = tslib.__spreadArray([], tslib.__read(filteredChildren));\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n        else {\n            // In case this key has re-entered, remove from the exiting list\n            exiting.delete(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    presentChildren.current = childrenToRender;\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (React__namespace.createElement(React__namespace.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return React.cloneElement(child); })));\n};\n\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\nfunction animate(from, to, transition) {\n    if (transition === void 0) { transition = {}; }\n    var value = isMotionValue(from) ? from : motionValue(from);\n    startAnimation(\"\", value, to, transition);\n    return {\n        stop: function () { return value.stop(); },\n    };\n}\n\nfunction createCrossfader() {\n    /**\n     * The current state of the crossfade as a value between 0 and 1\n     */\n    var progress = motionValue(1);\n    var options = {\n        lead: undefined,\n        follow: undefined,\n        crossfadeOpacity: false,\n        preserveFollowOpacity: false,\n    };\n    var prevOptions = tslib.__assign({}, options);\n    var leadState = {};\n    var followState = {};\n    /**\n     *\n     */\n    var isActive = false;\n    /**\n     *\n     */\n    var finalCrossfadeFrame = null;\n    /**\n     * Framestamp of the last frame we updated values at.\n     */\n    var prevUpdate = 0;\n    function startCrossfadeAnimation(target, transition) {\n        var lead = options.lead, follow = options.follow;\n        isActive = true;\n        finalCrossfadeFrame = null;\n        var hasUpdated = false;\n        var onUpdate = function () {\n            hasUpdated = true;\n            lead && lead.scheduleRender();\n            follow && follow.scheduleRender();\n        };\n        var onComplete = function () {\n            isActive = false;\n            /**\n             * If the crossfade animation is no longer active, flag a frame\n             * that we're still allowed to crossfade\n             */\n            finalCrossfadeFrame = sync.getFrameData().timestamp;\n        };\n        transition = transition && getValueTransition(transition, \"crossfade\");\n        return animate(progress, target, tslib.__assign(tslib.__assign({}, transition), { onUpdate: onUpdate, onComplete: function () {\n                if (!hasUpdated) {\n                    progress.set(target);\n                    /**\n                     * If we never ran an update, for instance if this was an instant transition, fire a\n                     * simulated final frame to ensure the crossfade gets applied correctly.\n                     */\n                    sync__default['default'].read(onComplete);\n                }\n                else {\n                    onComplete();\n                }\n                onUpdate();\n            } }));\n    }\n    function updateCrossfade() {\n        var _a, _b;\n        /**\n         * We only want to compute the crossfade once per frame, so we\n         * compare the previous update framestamp with the current frame\n         * and early return if they're the same.\n         */\n        var timestamp = sync.getFrameData().timestamp;\n        var lead = options.lead, follow = options.follow;\n        if (timestamp === prevUpdate || !lead)\n            return;\n        prevUpdate = timestamp;\n        /**\n         * Merge each component's latest values into our crossfaded state\n         * before crossfading.\n         */\n        var latestLeadValues = lead.getLatestValues();\n        Object.assign(leadState, latestLeadValues);\n        var latestFollowValues = follow\n            ? follow.getLatestValues()\n            : options.prevValues;\n        Object.assign(followState, latestFollowValues);\n        var p = progress.get();\n        /**\n         * Crossfade the opacity between the two components. This will result\n         * in a different opacity for each component.\n         */\n        var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n        var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n        if (options.crossfadeOpacity && follow) {\n            leadState.opacity = popmotion.mix(\n            /**\n             * If the follow child has been completely hidden we animate\n             * this opacity from its previous opacity, but otherwise from completely transparent.\n             */\n            follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n            followState.opacity = options.preserveFollowOpacity\n                ? followTargetOpacity\n                : popmotion.mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n        }\n        else if (!follow) {\n            leadState.opacity = popmotion.mix(followTargetOpacity, leadTargetOpacity, p);\n        }\n        mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n    }\n    return {\n        isActive: function () {\n            return leadState &&\n                (isActive || sync.getFrameData().timestamp === finalCrossfadeFrame);\n        },\n        fromLead: function (transition) {\n            return startCrossfadeAnimation(0, transition);\n        },\n        toLead: function (transition) {\n            var initialProgress = 0;\n            if (!options.prevValues && !options.follow) {\n                /**\n                 * If we're not coming from anywhere, start at the end of the animation.\n                 */\n                initialProgress = 1;\n            }\n            else if (prevOptions.lead === options.follow &&\n                prevOptions.follow === options.lead) {\n                /**\n                 * If we're swapping follow/lead we can reverse the progress\n                 */\n                initialProgress = 1 - progress.get();\n            }\n            progress.set(initialProgress);\n            return startCrossfadeAnimation(1, transition);\n        },\n        reset: function () { return progress.set(1); },\n        stop: function () { return progress.stop(); },\n        getCrossfadeState: function (element) {\n            updateCrossfade();\n            if (element === options.lead) {\n                return leadState;\n            }\n            else if (element === options.follow) {\n                return followState;\n            }\n        },\n        setOptions: function (newOptions) {\n            prevOptions = options;\n            options = newOptions;\n            leadState = {};\n            followState = {};\n        },\n        getLatestValues: function () {\n            return leadState;\n        },\n    };\n}\nvar easeCrossfadeIn = compress(0, 0.5, popmotion.circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, popmotion.linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(popmotion.progress(min, max, p));\n    };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\" + borders[i] + \"Radius\";\n        var followRadius = getRadius(latestFollowValues, borderLabel);\n        var leadRadius = getRadius(latestLeadValues, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        /**\n         * Currently we're only crossfading between numerical border radius.\n         * It would be possible to crossfade between percentages for a little\n         * extra bundle size.\n         */\n        if (typeof followRadius === \"number\" &&\n            typeof leadRadius === \"number\") {\n            var radius = Math.max(popmotion.mix(followRadius, leadRadius, p), 0);\n            leadState[borderLabel] = followState[borderLabel] = radius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (latestFollowValues.rotate || latestLeadValues.rotate) {\n        var rotate = popmotion.mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n        leadState.rotate = followState.rotate = rotate;\n    }\n    /**\n     * We only want to mix the background color if there's a follow element\n     * that we're not crossfading opacity between. For instance with switch\n     * AnimateSharedLayout animations, this helps the illusion of a continuous\n     * element being animated but also cuts down on the number of paints triggered\n     * for elements where opacity is doing that work for us.\n     */\n    if (!hasFollowElement &&\n        latestLeadValues.backgroundColor &&\n        latestFollowValues.backgroundColor) {\n        /**\n         * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n         * We could probably create a mixer that runs at the start of the animation but\n         * the idea behind the crossfader is that it runs dynamically between two potentially\n         * changing targets (ie opacity or borderRadius may be animating independently via variants)\n         */\n        leadState.backgroundColor = followState.backgroundColor = popmotion.mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nfunction layoutStack() {\n    var stack = new Set();\n    var state = { leadIsExiting: false };\n    var prevState = tslib.__assign({}, state);\n    var prevValues;\n    var prevViewportBox;\n    var prevDragCursor;\n    var crossfader = createCrossfader();\n    var needsCrossfadeAnimation = false;\n    function getFollowViewportBox() {\n        return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n    }\n    function getFollowLayout() {\n        var _a;\n        return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n    }\n    return {\n        add: function (element) {\n            element.setCrossfader(crossfader);\n            stack.add(element);\n            /**\n             * Hydrate new element with previous drag position if we have one\n             */\n            if (prevDragCursor)\n                element.prevDragCursor = prevDragCursor;\n            if (!state.lead)\n                state.lead = element;\n        },\n        remove: function (element) {\n            stack.delete(element);\n        },\n        getLead: function () { return state.lead; },\n        updateSnapshot: function () {\n            if (!state.lead)\n                return;\n            prevValues = crossfader.isActive()\n                ? crossfader.getLatestValues()\n                : state.lead.getLatestValues();\n            prevViewportBox = state.lead.prevViewportBox;\n            var dragControls = elementDragControls.get(state.lead);\n            if (dragControls && dragControls.isDragging) {\n                prevDragCursor = dragControls.cursorProgress;\n            }\n        },\n        clearSnapshot: function () {\n            prevDragCursor = prevViewportBox = undefined;\n        },\n        updateLeadAndFollow: function () {\n            var _a;\n            prevState = tslib.__assign({}, state);\n            var lead;\n            var follow;\n            var order = Array.from(stack);\n            for (var i = order.length; i--; i >= 0) {\n                var element = order[i];\n                if (lead)\n                    follow !== null && follow !== void 0 ? follow : (follow = element);\n                lead !== null && lead !== void 0 ? lead : (lead = element);\n                if (lead && follow)\n                    break;\n            }\n            state.lead = lead;\n            state.follow = follow;\n            state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n            crossfader.setOptions({\n                lead: lead,\n                follow: follow,\n                prevValues: prevValues,\n                crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot),\n            });\n            if (\n            // Don't crossfade if we've just animated back from lead and switched the\n            // old follow to the new lead.\n            state.lead !== prevState.follow &&\n                (prevState.lead !== state.lead ||\n                    prevState.leadIsExiting !== state.leadIsExiting)) {\n                needsCrossfadeAnimation = true;\n            }\n        },\n        animate: function (child, shouldCrossfade) {\n            var _a;\n            if (shouldCrossfade === void 0) { shouldCrossfade = false; }\n            if (child === state.lead) {\n                if (shouldCrossfade) {\n                    /**\n                     * Point a lead to itself in case it was previously pointing\n                     * to a different visual element\n                     */\n                    child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(true);\n                }\n                var config = {};\n                var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n                if (prevParent) {\n                    /**\n                     * We'll use this to determine if the element or its layoutId has been reparented.\n                     */\n                    config.prevParent = prevParent;\n                }\n                if (child.presence === Presence.Entering) {\n                    config.originBox = getFollowViewportBox();\n                }\n                else if (child.presence === Presence.Exiting) {\n                    config.targetBox = getFollowLayout();\n                }\n                if (needsCrossfadeAnimation) {\n                    needsCrossfadeAnimation = false;\n                    var transition = child.getDefaultTransition();\n                    child.presence === Presence.Entering\n                        ? crossfader.toLead(transition)\n                        : crossfader.fromLead(transition);\n                }\n                child.notifyLayoutReady(config);\n            }\n            else {\n                if (shouldCrossfade) {\n                    state.lead && child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(false);\n                }\n            }\n        },\n    };\n}\n\nfunction resetRotate(child) {\n    // If there's no detected rotation values, we can early return without a forced render.\n    var hasRotate = false;\n    // Keep a record of all the values we've reset\n    var resetValues = {};\n    // Check the rotate value of all axes and reset to 0\n    for (var i = 0; i < transformAxes.length; i++) {\n        var axis = transformAxes[i];\n        var key = \"rotate\" + axis;\n        // If this rotation doesn't exist as a motion value, then we don't\n        // need to reset it\n        if (!child.hasValue(key) || child.getStaticValue(key) === 0)\n            continue;\n        hasRotate = true;\n        // Record the rotation and then temporarily set it to 0\n        resetValues[key] = child.getStaticValue(key);\n        child.setStaticValue(key, 0);\n    }\n    // If there's no rotation values, we don't need to do any more.\n    if (!hasRotate)\n        return;\n    // Force a render of this element to apply the transform with all rotations\n    // set to 0.\n    child.syncRender();\n    // Put back all the values we reset\n    for (var key in resetValues) {\n        child.setStaticValue(key, resetValues[key]);\n    }\n    // Schedule a render for the next frame. This ensures we won't visually\n    // see the element with the reset rotate value applied.\n    child.scheduleRender();\n}\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    tslib.__extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = tslib.__assign(tslib.__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = tslib.__assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) {\n            resetRotate(child);\n            if (child.shouldResetTransform())\n                child.resetTransform();\n        });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(snapshotViewportBox);\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (React__namespace.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(React__namespace.Component));\n\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction MotionConfig(_a) {\n    var children = _a.children, config = tslib.__rest(_a, [\"children\"]);\n    /**\n     * Inherit props from any parent MotionConfig components\n     */\n    config = tslib.__assign(tslib.__assign({}, React.useContext(MotionConfigContext)), config);\n    /**\n     * Don't allow isStatic to change between renders as it affects how many hooks\n     * motion components fire.\n     */\n    config.isStatic = useConstant(function () { return config.isStatic; });\n    /**\n     * Creating a new config context object will re-render every `motion` component\n     * every time it renders. So we only want to create a new one sparingly.\n     */\n    var transitionDependency = typeof config.transition === \"object\"\n        ? config.transition.toString()\n        : \"\";\n    var context = React.useMemo(function () { return config; }, [\n        transitionDependency,\n        config.transformPagePoint,\n    ]);\n    return (React__namespace.createElement(MotionConfigContext.Provider, { value: context }, children));\n}\n\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimations } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimations}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimations')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction LazyMotion(_a) {\n    var children = _a.children, features = _a.features, _b = _a.strict, strict = _b === void 0 ? false : _b;\n    var _c = tslib.__read(React.useState(!isLazyBundle(features)), 2), setIsLoaded = _c[1];\n    var loadedRenderer = React.useRef(undefined);\n    /**\n     * If this is a synchronous load, load features immediately\n     */\n    if (!isLazyBundle(features)) {\n        var renderer = features.renderer, loadedFeatures = tslib.__rest(features, [\"renderer\"]);\n        loadedRenderer.current = renderer;\n        loadFeatures(loadedFeatures);\n    }\n    React.useEffect(function () {\n        if (isLazyBundle(features)) {\n            features().then(function (_a) {\n                var renderer = _a.renderer, loadedFeatures = tslib.__rest(_a, [\"renderer\"]);\n                loadFeatures(loadedFeatures);\n                loadedRenderer.current = renderer;\n                setIsLoaded(true);\n            });\n        }\n    }, []);\n    return (React__namespace.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict: strict } }, children));\n}\nfunction isLazyBundle(features) {\n    return typeof features === \"function\";\n}\n\n/**\n * @public\n */\nvar domAnimation = tslib.__assign(tslib.__assign({ renderer: createDomVisualElement }, animations), gestureAnimations);\n\n/**\n * @public\n */\nvar domMax = tslib.__assign(tslib.__assign(tslib.__assign({}, domAnimation), drag), layoutAnimations);\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    var value = useConstant(function () { return motionValue(initial); });\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    if (isStatic) {\n        var _a = tslib.__read(React.useState(initial), 2), setLatest_1 = _a[1];\n        React.useEffect(function () { return value.onChange(setLatest_1); }, []);\n    }\n    return value;\n}\n\nfunction useOnChange(value, callback) {\n    React.useEffect(function () {\n        if (isMotionValue(value))\n            return value.onChange(callback);\n    }, [callback]);\n}\nfunction useMultiOnChange(values, handler) {\n    React.useEffect(function () {\n        var subscriptions = values.map(function (value) { return value.onChange(handler); });\n        return function () { return subscriptions.forEach(function (unsubscribe) { return unsubscribe(); }); };\n    });\n}\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    var value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    var updateValue = function () { return value.set(combineValues()); };\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useMultiOnChange(values, function () { return sync__default['default'].update(updateValue, false, true); });\n    return value;\n}\n\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\nfunction useMotionTemplate(fragments) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */\n    var numFragments = fragments.length;\n    function buildValue() {\n        var output = \"\";\n        for (var i = 0; i < numFragments; i++) {\n            output += fragments[i];\n            var value = values[i];\n            if (value)\n                output += values[i].get();\n        }\n        return output;\n    }\n    return useCombineMotionValues(values, buildValue);\n}\n\nvar isCustomValueType = function (v) {\n    return typeof v === \"object\" && v.mix;\n};\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\nfunction transform() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var useImmediate = !Array.isArray(args[0]);\n    var argOffset = useImmediate ? 0 : -1;\n    var inputValue = args[0 + argOffset];\n    var inputRange = args[1 + argOffset];\n    var outputRange = args[2 + argOffset];\n    var options = args[3 + argOffset];\n    var interpolator = popmotion.interpolate(inputRange, outputRange, tslib.__assign({ mixer: getMixer(outputRange[0]) }, options));\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    var transformer = typeof inputRangeOrTransformer === \"function\"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], function (_a) {\n            var _b = tslib.__read(_a, 1), latest = _b[0];\n            return transformer(latest);\n        });\n}\nfunction useListTransform(values, transformer) {\n    var latest = useConstant(function () { return []; });\n    return useCombineMotionValues(values, function () {\n        latest.length = 0;\n        var numValues = values.length;\n        for (var i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction useSpring(source, config) {\n    if (config === void 0) { config = {}; }\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    var activeSpringAnimation = React.useRef(null);\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    React.useMemo(function () {\n        return value.attach(function (v, set) {\n            /**\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n             * at that level, but this will work for now\n             */\n            if (isStatic)\n                return set(v);\n            if (activeSpringAnimation.current) {\n                activeSpringAnimation.current.stop();\n            }\n            activeSpringAnimation.current = popmotion.animate(tslib.__assign(tslib.__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config), { onUpdate: set }));\n            return value.get();\n        });\n    }, Object.values(config));\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\n    return value;\n}\n\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */\nfunction useVelocity(value) {\n    var velocity = useMotionValue(value.getVelocity());\n    React.useEffect(function () {\n        return value.velocityUpdateSubscribers.add(function (newVelocity) {\n            velocity.set(newVelocity);\n        });\n    }, [value]);\n    return velocity;\n}\n\nfunction createScrollMotionValues() {\n    return {\n        scrollX: motionValue(0),\n        scrollY: motionValue(0),\n        scrollXProgress: motionValue(0),\n        scrollYProgress: motionValue(0),\n    };\n}\nfunction setProgress(offset, maxOffset, value) {\n    value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\nfunction createScrollUpdater(values, getOffsets) {\n    var update = function () {\n        var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;\n        // Set absolute positions\n        values.scrollX.set(xOffset);\n        values.scrollY.set(yOffset);\n        // Set 0-1 progress\n        setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n        setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n    };\n    update();\n    return update;\n}\n\nvar getElementScrollOffsets = function (element) { return function () {\n    return {\n        xOffset: element.scrollLeft,\n        yOffset: element.scrollTop,\n        xMaxOffset: element.scrollWidth - element.offsetWidth,\n        yMaxOffset: element.scrollHeight - element.offsetHeight,\n    };\n}; };\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * This element must be set to `overflow: scroll` on either or both axes to report scroll offset.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction useElementScroll(ref) {\n    var values = useConstant(createScrollMotionValues);\n    useIsomorphicLayoutEffect(function () {\n        var element = ref.current;\n        heyListen.invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n        if (!element)\n            return;\n        var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n        var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, { passive: true });\n        var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n        return function () {\n            scrollListener && scrollListener();\n            resizeListener && resizeListener();\n        };\n    }, []);\n    return values;\n}\n\nvar viewportScrollValues;\nfunction getViewportScrollOffsets() {\n    return {\n        xOffset: window.pageXOffset,\n        yOffset: window.pageYOffset,\n        xMaxOffset: document.body.clientWidth - window.innerWidth,\n        yMaxOffset: document.body.clientHeight - window.innerHeight,\n    };\n}\nvar hasListeners = false;\nfunction addEventListeners() {\n    hasListeners = true;\n    if (typeof window === \"undefined\")\n        return;\n    var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n    addDomEvent(window, \"scroll\", updateScrollValues, { passive: true });\n    addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * **Warning:** Setting `body` or `html` to `height: 100%` or similar will break the `Progress`\n * values as this breaks the browser's capability to accurately measure the page length.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\nfunction useViewportScroll() {\n    /**\n     * Lazy-initialise the viewport scroll values\n     */\n    if (!viewportScrollValues) {\n        viewportScrollValues = createScrollMotionValues();\n    }\n    useIsomorphicLayoutEffect(function () {\n        !hasListeners && addEventListeners();\n    }, []);\n    return viewportScrollValues;\n}\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nvar prefersReducedMotion;\nfunction initPrefersReducedMotion() {\n    prefersReducedMotion = motionValue(null);\n    if (typeof window === \"undefined\")\n        return;\n    if (window.matchMedia) {\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n        var setReducedMotionPreferences = function () {\n            return prefersReducedMotion.set(motionMediaQuery_1.matches);\n        };\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.set(false);\n    }\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\nfunction useReducedMotion() {\n    /**\n     * Lazy initialisation of prefersReducedMotion\n     */\n    !prefersReducedMotion && initPrefersReducedMotion();\n    var _a = tslib.__read(React.useState(prefersReducedMotion.get()), 2), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\n    useOnChange(prefersReducedMotion, setShouldReduceMotion);\n    return shouldReduceMotion;\n}\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    var hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */\n    var pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */\n    var subscribers = new Set();\n    var controls = {\n        subscribe: function (visualElement) {\n            subscribers.add(visualElement);\n            return function () { return void subscribers.delete(visualElement); };\n        },\n        start: function (definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */\n            if (hasMounted) {\n                var animations_1 = [];\n                subscribers.forEach(function (visualElement) {\n                    animations_1.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride: transitionOverride,\n                    }));\n                });\n                return Promise.all(animations_1);\n            }\n            else {\n                return new Promise(function (resolve) {\n                    pendingAnimations.push({\n                        animation: [definition, transitionOverride],\n                        resolve: resolve,\n                    });\n                });\n            }\n        },\n        set: function (definition) {\n            heyListen.invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach(function (visualElement) {\n                setValues(visualElement, definition);\n            });\n        },\n        stop: function () {\n            subscribers.forEach(function (visualElement) {\n                stopAnimation(visualElement);\n            });\n        },\n        mount: function () {\n            hasMounted = true;\n            pendingAnimations.forEach(function (_a) {\n                var animation = _a.animation, resolve = _a.resolve;\n                controls.start.apply(controls, tslib.__spreadArray([], tslib.__read(animation))).then(resolve);\n            });\n            return function () {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimation() {\n    var controls = useConstant(animationControls);\n    React.useEffect(controls.mount, []);\n    return controls;\n}\n\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\nfunction useCycle() {\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    var index = React.useRef(0);\n    var _a = tslib.__read(React.useState(items[index.current]), 2), item = _a[0], setItem = _a[1];\n    return [\n        item,\n        function (next) {\n            index.current =\n                typeof next !== \"number\"\n                    ? popmotion.wrap(0, items.length, index.current + 1)\n                    : next;\n            setItem(items[index.current]);\n        },\n    ];\n}\n\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nvar DragControls = /** @class */ (function () {\n    function DragControls() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */\n    DragControls.prototype.subscribe = function (controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        return function () { return _this.componentControls.delete(controls); };\n    };\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */\n    DragControls.prototype.start = function (event, options) {\n        this.componentControls.forEach(function (controls) {\n            controls.start(event.nativeEvent || event, options);\n        });\n    };\n    DragControls.prototype.updateConstraints = function (flush) {\n        if (flush === void 0) { flush = true; }\n        this.componentControls.forEach(function (controls) {\n            controls.updateConstraints();\n        });\n        flush && flushLayout();\n    };\n    return DragControls;\n}());\nvar createDragControls = function () { return new DragControls(); };\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nfunction useDragControls() {\n    return useConstant(createDragControls);\n}\n\nvar createObject = function () { return ({}); };\nvar stateVisualElement = visualElement({\n    build: function () { },\n    measureViewportBox: axisBox,\n    resetTransform: function () { },\n    restoreTransform: function () { },\n    removeValueFromRenderState: function () { },\n    render: function () { },\n    scrapeMotionValuesFromProps: createObject,\n    readValueFromInstance: function (_state, key, options) {\n        return options.initialState[key] || 0;\n    },\n    makeTargetAnimatable: function (element, _a) {\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n        var origin = getOrigin(target, transition || {}, element);\n        checkTargetForNewValues(element, target, origin);\n        return tslib.__assign({ transition: transition, transitionEnd: transitionEnd }, target);\n    },\n});\nvar useVisualState = makeUseVisualState({\n    scrapeMotionValuesFromProps: createObject,\n    createRenderState: createObject,\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\nfunction useAnimatedState(initialState) {\n    var _a = tslib.__read(React.useState(initialState), 2), animationState = _a[0], setAnimationState = _a[1];\n    var visualState = useVisualState({}, false);\n    var element = useConstant(function () {\n        return stateVisualElement({ props: {}, visualState: visualState }, { initialState: initialState });\n    });\n    React.useEffect(function () {\n        element.mount({});\n        return element.unmount();\n    }, []);\n    React.useEffect(function () {\n        element.setProps({\n            onUpdate: function (v) { return setAnimationState(tslib.__assign({}, v)); },\n        });\n    });\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\n        return animateVisualElement(element, animationDefinition);\n    }; });\n    return [animationState, startAnimation];\n}\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nvar maxScale = 100000;\nvar invertScale = function (scale) {\n    return scale > 0.001 ? 1 / scale : maxScale;\n};\nvar hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @deprecated\n * @internal\n */\nfunction useInvertedScale(scale) {\n    var parentScaleX = useMotionValue(1);\n    var parentScaleY = useMotionValue(1);\n    var visualElement = useVisualElementContext();\n    heyListen.invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n    heyListen.warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n    hasWarned = true;\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    }\n    else if (visualElement) {\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\n    }\n    var scaleX = useTransform(parentScaleX, invertScale);\n    var scaleY = useTransform(parentScaleY, invertScale);\n    return { scaleX: scaleX, scaleY: scaleY };\n}\n\nexports.AnimatePresence = AnimatePresence;\nexports.AnimateSharedLayout = AnimateSharedLayout;\nexports.DragControls = DragControls;\nexports.FlatTree = FlatTree;\nexports.FramerTreeLayoutContext = FramerTreeLayoutContext;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyMotion = LazyMotion;\nexports.MotionConfig = MotionConfig;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.SharedLayoutContext = SharedLayoutContext;\nexports.addScaleCorrection = addScaleCorrection;\nexports.animate = animate;\nexports.animateVisualElement = animateVisualElement;\nexports.animationControls = animationControls;\nexports.batchLayout = batchLayout;\nexports.createBatcher = createBatcher;\nexports.createCrossfader = createCrossfader;\nexports.createDomMotionComponent = createDomMotionComponent;\nexports.createMotionComponent = createMotionComponent;\nexports.domAnimation = domAnimation;\nexports.domMax = domMax;\nexports.flushLayout = flushLayout;\nexports.isValidMotionProp = isValidMotionProp;\nexports.m = m;\nexports.motion = motion;\nexports.motionValue = motionValue;\nexports.resolveMotionValue = resolveMotionValue;\nexports.snapshotViewportBox = snapshotViewportBox;\nexports.transform = transform;\nexports.useAnimation = useAnimation;\nexports.useCycle = useCycle;\nexports.useDeprecatedAnimatedState = useAnimatedState;\nexports.useDeprecatedInvertedScale = useInvertedScale;\nexports.useDomEvent = useDomEvent;\nexports.useDragControls = useDragControls;\nexports.useElementScroll = useElementScroll;\nexports.useIsPresent = useIsPresent;\nexports.useMotionTemplate = useMotionTemplate;\nexports.useMotionValue = useMotionValue;\nexports.usePresence = usePresence;\nexports.useReducedMotion = useReducedMotion;\nexports.useSpring = useSpring;\nexports.useTransform = useTransform;\nexports.useVelocity = useVelocity;\nexports.useViewportScroll = useViewportScroll;\nexports.visualElement = visualElement;\n"]},"metadata":{},"sourceType":"script"}